<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-inevermore</title><link>http://www.cnblogs.com/inevermore/</link><description>学而时习之，不亦说乎</description><language>zh-cn</language><lastBuildDate>Sun, 25 Jan 2015 14:40:21 GMT</lastBuildDate><pubDate>Sun, 25 Jan 2015 14:40:21 GMT</pubDate><ttl>60</ttl><item><title>从range和xrange的性能对比到yield关键字（中）</title><link>http://www.cnblogs.com/inevermore/archive/2015/01/14/4224985.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 14 Jan 2015 14:03:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2015/01/14/4224985.html</guid><description><![CDATA[<p>上节提出了range和xrange的效率问题，这节我们来探究其中的原因</p>  <p>&#160;</p>  <p><strong><font size="4">yield的使用</font></strong></p>  <p>&#160;</p>  <p>我们看下面的程序：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> test():
    </span><span style="color: #0000ff">print</span> 4
    <span style="color: #0000ff">print</span> 2
    <span style="color: #0000ff">print</span> 5

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    test()</span></pre>
</div>



<p>这段代码的运行结果当然是没有任何疑问的。</p>

<p>但是如果我将代码修改一下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> test():
    </span><span style="color: #0000ff">yield</span> 4
    <span style="color: #0000ff">yield</span> 2
    <span style="color: #0000ff">yield</span> 5

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">print</span> test()</pre>
</div>

<p>运行结果有些奇怪：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>&lt;generator object test at 0xb71f1144&gt;</pre>
</div>

<p>我们尝试这样使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> test():
        </span><span style="color: #0000ff">print</span> i</pre>
</div>



<p>结果却出人意料：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>wing@ubuntu:~/Documents/py|⇒  python 17<span style="color: #000000">.py
</span>4
2
5</pre>
</div>



<p>这是什么原因呢？这里看起来，test()好像一个集合，里面存储了4，2，5，所以我们才能够依次遍历。</p>

<p>实际上，原因并非如此。</p>

<p>当一个函数中含有yield时，<font color="#ff0000">这个函数就不再是一个普通的函数</font>，而是一个可迭代的对象（实际上叫做生成器，不过现在不必关心概念）。</p>

<p>同样，执行该函数时，不再是马上执行其中的语句，而是生成一个可迭代对象。当执行迭代的时候，才真正运行其中的代码。</p>

<p><font color="#ff0000">当函数体执行到yield时，便退出这个函数</font>，此时yield具有return的功能。但是这里的关键是，当下次执行这个函数时，<font color="#ff0000"><strong>并不是从头开始执行，而是从上次yield退出的位置继续执行</strong></font>。</p>

<p>尝试下面的代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> test():
    </span><span style="color: #0000ff">yield</span> 4
    <span style="color: #0000ff">yield</span> 2
    <span style="color: #0000ff">yield</span> 5

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    t </span>=<span style="color: #000000"> test()
    it </span>=<span style="color: #000000"> iter(t)
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
    </span><span style="color: #0000ff">print</span> it.next()</pre>
</div>

<p>运行结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>wing@ubuntu:~/Documents/py|⇒  python 17<span style="color: #000000">.py
</span>4
2
5<span style="color: #000000">
Traceback (most recent call last):
  File </span><span style="color: #800000">&quot;</span><span style="color: #800000">17.py</span><span style="color: #800000">&quot;</span>, line 14, <span style="color: #0000ff">in</span> &lt;module&gt;
    <span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
StopIteration</span></pre>
</div>

<p>从这里的结果可以看出，test()语句没有执行代码段，而是生成了一个可以迭代的对象。</p>

<p>我们甚至可以得出结论，<font color="#ff0000">每当执行一次next，就向后执行到下一个yield语句</font>，或者所有的语句执行完毕。</p>

<p>&#160;</p>

<p><font color="#000000" size="4"><strong>range的实现</strong></font></p>

<p>&#160;</p>

<p>我们尝试实现range：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> _range(value):
    i </span>=<span style="color: #000000"> 0
    result </span>=<span style="color: #000000"> []
    </span><span style="color: #0000ff">while</span> i &lt;<span style="color: #000000"> value:
        result.append(i)
        i </span>+= 1
    <span style="color: #0000ff">return</span><span style="color: #000000"> result

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> _range(4<span style="color: #000000">):
        </span><span style="color: #0000ff">print</span> i</pre>
</div>

<p>range的逻辑比较简单，就是生成一个列表。</p>

<p>&#160;</p>

<p><font size="4"><strong>xrange的模拟实现</strong></font></p>

<p>&#160;</p>

<p>我们根据前面的结论，猜测xrange是一个含有yield的函数，于是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> _xrange(value):
    i </span>=<span style="color: #000000"> 0
    </span><span style="color: #0000ff">while</span> i &lt;<span style="color: #000000"> value:
        </span><span style="color: #0000ff">yield</span><span style="color: #000000"> i
        i </span>+= 1

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> _xrange(4<span style="color: #000000">):
        </span><span style="color: #0000ff">print</span> i</pre>
</div>

<p>运行一下，结果和我们预期一致。</p>

<p>当然，实际的xrange比我们这里编写的更加复杂，但是基本原理是一致的。</p>

<p>&#160;</p>

<p><font size="4"><strong>为何xrange比range高效？</strong></font></p>

<p>&#160;</p>

<p>答案很明显了，range是一次性生成所有的数据，而xrange，内部使用了yield关键字，每次只运行其中一部分，这样从头到尾都没有占用大量的内存和时间。所以效率较高。</p>

<p>&#160;</p>

<p>我们再次比较性能，这次比较的是我们自己编写的版本：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> sys
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> time

</span><span style="color: #0000ff">def</span><span style="color: #000000"> _range(value):
    i </span>=<span style="color: #000000"> 0
    result </span>=<span style="color: #000000"> []
    </span><span style="color: #0000ff">while</span> i &lt;<span style="color: #000000"> value:
        result.append(i)
        i </span>+= 1
    <span style="color: #0000ff">return</span><span style="color: #000000"> result

</span><span style="color: #0000ff">def</span><span style="color: #000000"> _xrange(value):
    i </span>=<span style="color: #000000"> 0
    </span><span style="color: #0000ff">while</span> i &lt;<span style="color: #000000"> value:
        </span><span style="color: #0000ff">yield</span><span style="color: #000000"> i
        i </span>+= 1

<span style="color: #0000ff">def</span><span style="color: #000000"> count_time(func):
    </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
        begin_time </span>=<span style="color: #000000"> time()
        result </span>= func(*args, **<span style="color: #000000">kargs)
        end_time </span>=<span style="color: #000000"> time()
        cost_time </span>= end_time -<span style="color: #000000"> begin_time
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">%s called cost time : %s ms</span><span style="color: #800000">'</span> %(func.<span style="color: #800080">__name__</span>, float(cost_time)*1000<span style="color: #000000">)
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> result
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped

@count_time
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test1(length):
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> _range(length):
        </span><span style="color: #0000ff">pass</span><span style="color: #000000">

@count_time
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test2(length):
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> _xrange(length):
        </span><span style="color: #0000ff">pass</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    length </span>= int(sys.argv[1<span style="color: #000000">])
    test1(length)
    test2(length)</span></pre>
</div>

<p>运行结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>wing@ubuntu:~/Documents/py|⇒  python 19.py 1000<span style="color: #000000">
test1 called cost time : </span>0.116109848022<span style="color: #000000"> ms
test2 called cost time : </span>0.0619888305664<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 19.py 10000<span style="color: #000000">
test1 called cost time : </span>2.39086151123<span style="color: #000000"> ms
test2 called cost time : </span>0.566959381104<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 19.py 100000<span style="color: #000000">
test1 called cost time : </span>15.5799388885<span style="color: #000000"> ms
test2 called cost time : </span>6.41298294067<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 19.py 1000000<span style="color: #000000">
test1 called cost time : </span>130.295038223<span style="color: #000000"> ms
test2 called cost time : </span>65.4468536377<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 19.py 10000000<span style="color: #000000">
test1 called cost time : </span>13238.3038998<span style="color: #000000"> ms
test2 called cost time : </span>652.212142944 ms</pre>
</div>











<p>显然，使用yield的版本更加高效。</p>

<p>&#160;</p>

<p>下文，我们探究生成器。</p>]]></description></item><item><title>使用装饰器时带括号与不带括号的区别</title><link>http://www.cnblogs.com/inevermore/archive/2015/01/12/4219882.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 12 Jan 2015 13:34:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2015/01/12/4219882.html</guid><description><![CDATA[<p>之前我们在<a href="http://www.cnblogs.com/inevermore/p/4194584.html" target="_blank">一个用于统计函数调用消耗时间的装饰器</a>中写了一个装饰器，用于统计函数调用时间。代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> time
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> count_time():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> tmp(func):
        </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
            begin_time </span>=<span style="color: #000000"> time()
            result </span>= func(*args, **<span style="color: #000000">kargs)
            end_time </span>=<span style="color: #000000"> time()
            cost_time </span>= end_time -<span style="color: #000000"> begin_time
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">%s called cost time : %s</span><span style="color: #800000">'</span> %(func.<span style="color: #800080">__name__</span><span style="color: #000000">, cost_time)
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> result
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span> tmp</pre>
</div>

<p>对于该装饰器，我们必须这样使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">@count_time()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test():
    sleep(</span>0.5<span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    test()</span></pre>
</div>

<p>这里注意，装饰器后面加了括号。</p>

<p>如果我们不加括号：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">@count_time
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test():
    sleep(</span>0.5<span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    test()</span></pre>
</div>

<p>就会产生错误：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">Traceback (most recent call last):
  File </span><span style="color: #800000">&quot;</span><span style="color: #800000">16.py</span><span style="color: #800000">&quot;</span>, line 16, <span style="color: #0000ff">in</span> &lt;module&gt;<span style="color: #000000">
    @count_time
TypeError: count_time() takes no arguments (</span>1 given)</pre>
</div>

<p>&#160;</p>

<p>但是很多装饰器使用时，是不必加括号的，那么这是怎么回事？</p>

<p>&#160;</p>

<p>我们将上面的装饰器进行改写：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> time
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep
</span><span style="color: #0000ff">import</span><span style="color: #000000"> sys

</span><span style="color: #0000ff">def</span><span style="color: #000000"> count_time(func):
    </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
        begin_time </span>=<span style="color: #000000"> time()
        result </span>= func(*args, **<span style="color: #000000">kargs)
        end_time </span>=<span style="color: #000000"> time()
        cost_time </span>= end_time -<span style="color: #000000"> begin_time
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">%s called cost time : %s ms</span><span style="color: #800000">'</span> %(func.<span style="color: #800080">__name__</span>, float(cost_time)*1000<span style="color: #000000">)
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> result
    </span><span style="color: #0000ff">return</span> wrapped</pre>
</div>

<p>此时，就不需要加括号了。</p>

<p>这二者的区别在于，<font color="#ff0000">第一个存在括号，允许用户传入自定义信息，所以需要额外包装一层</font>，不加括号的版本则不需要。</p>

<p>&#160;</p>

<p>所以当我们需要自定义装饰器内的某些message时，就需要采用加括号的方式。</p>

<p>对于这个统计时间的装饰器，我们可以这样自定义信息：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>
<span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> time
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> count_time(msg):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> tmp(func):
        </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
            begin_time </span>=<span style="color: #000000"> time()
            result </span>= func(*args, **<span style="color: #000000">kargs)
            end_time </span>=<span style="color: #000000"> time()
            cost_time </span>= end_time -<span style="color: #000000"> begin_time
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">msg: %s ,%s called cost time : %s</span><span style="color: #800000">'</span> %(msg, func.<span style="color: #800080">__name__</span><span style="color: #000000">, cost_time)
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> result
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span> tmp</pre>
</div>

<p>然后这样使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>@count_time(<span style="color: #800000">&quot;</span><span style="color: #800000">foobar</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test():
    sleep(</span>0.5<span style="color: #000000">)

@count_time(</span><span style="color: #800000">&quot;</span><span style="color: #800000">测试消息</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test2():
    sleep(</span>0.7<span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    test()
    test2()</span></pre>
</div>

<p>结果如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>msg: foobar ,test called cost time : 0.501540899277<span style="color: #000000">
msg: 测试消息 ,test2 called cost time : </span>0.701622009277</pre>
</div>

<p>&#160;</p>

<p>后面综合前面几篇，写一个完整的装饰器教程。</p>]]></description></item><item><title>从range和xrange的性能对比到yield关键字（上）</title><link>http://www.cnblogs.com/inevermore/archive/2015/01/11/4216918.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 11 Jan 2015 11:04:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2015/01/11/4216918.html</guid><description><![CDATA[<p><strong><font size="4">使用xrange</font></strong></p>  <p>&#160;</p>  <p>当我们获取某个数量的循环时，我们惯用的手法是for循环和range函数，例如：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(10<span style="color: #000000">):
    </span><span style="color: #0000ff">print</span> i</pre>
</div>

<p>这里range（10）生成了一个长度为10的列表，内容为从0到9，所以这里的for循环实际上是在遍历其中的元素。</p>

<p>如果循环次数过大的时候，range要生成一个巨大的列表，这将导致程序的性能降低。</p>

<p>解决方案是采用xrange，用法基本与range相同：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> xrange(10<span style="color: #000000">):
    </span><span style="color: #0000ff">print</span> i</pre>
</div>

<p>但是二者的性能差距到底有多大？</p>

<p>&#160;</p>

<p><strong><font size="4">性能测评</font></strong></p>

<p>&#160;</p>

<p>我们使用下面的程序做一个测试：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> time
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep
</span><span style="color: #0000ff">import</span><span style="color: #000000"> sys

</span><span style="color: #0000ff">def</span><span style="color: #000000"> count_time():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> tmp(func):
        </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
            begin_time </span>=<span style="color: #000000"> time()
            result </span>= func(*args, **<span style="color: #000000">kargs)
            end_time </span>=<span style="color: #000000"> time()
            cost_time </span>= end_time -<span style="color: #000000"> begin_time
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">%s called cost time : %s ms</span><span style="color: #800000">'</span> %(func.<span style="color: #800080">__name__</span>, float(cost_time)*1000<span style="color: #000000">)
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> result
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> tmp

@count_time()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test1(length):
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(length):
        </span><span style="color: #0000ff">pass</span><span style="color: #000000">

@count_time()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test2(length):
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> xrange(length):
        </span><span style="color: #0000ff">pass</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    length </span>= int(sys.argv[1<span style="color: #000000">])
    test1(length)
    test2(length)</span></pre>
</div>

<p>上面的代码中，count_time是一个装饰器，用于统计程序运行的时间。</p>

<p>我们下面开始正式的测试：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>wing@ubuntu:~/Documents/py|⇒  python 10.py 100000<span style="color: #000000">
test1 called cost time : </span>13.8590335846<span style="color: #000000"> ms
test2 called cost time : </span>3.76796722412<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 100000<span style="color: #000000">
test1 called cost time : </span>16.725063324<span style="color: #000000"> ms
test2 called cost time : </span>3.08418273926<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 200000<span style="color: #000000">
test1 called cost time : </span>34.875869751<span style="color: #000000"> ms
test2 called cost time : </span>7.85899162292<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 500000<span style="color: #000000">
test1 called cost time : </span>41.6638851166<span style="color: #000000"> ms
test2 called cost time : </span>17.1940326691<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 500000<span style="color: #000000">
test1 called cost time : </span>59.8731040955<span style="color: #000000"> ms
test2 called cost time : </span>14.0538215637<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 500000<span style="color: #000000">
test1 called cost time : </span>94.1109657288<span style="color: #000000"> ms
test2 called cost time : </span>8.5780620575<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 500000<span style="color: #000000">
test1 called cost time : </span>61.615228653<span style="color: #000000"> ms
test2 called cost time : </span>7.21502304077 ms</pre>
</div>

<p>结果令我们大吃一惊，二者的差距非常明显，最高的时候差距了十几倍。</p>

<p>我们再选取几个较小的数据：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>wing@ubuntu:~/Documents/py|⇒  python 10.py 10<span style="color: #000000">    
test1 called cost time : </span>0.00596046447754<span style="color: #000000"> ms
test2 called cost time : </span>0.0109672546387<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 20<span style="color: #000000">
test1 called cost time : </span>0.00619888305664<span style="color: #000000"> ms
test2 called cost time : </span>0.159025192261<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 50<span style="color: #000000">
test1 called cost time : </span>0.00786781311035<span style="color: #000000"> ms
test2 called cost time : </span>0.00405311584473<span style="color: #000000"> ms
wing@ubuntu:</span>~/Documents/py|⇒  python 10.py 100<span style="color: #000000">
test1 called cost time : </span>0.00786781311035<span style="color: #000000"> ms
test2 called cost time : </span>0.00309944152832 ms</pre>
</div>

<p>这次range的性能并不差，甚至开始还略显高。</p>

<p>我们可以得出结论，<font color="#ff0000"><strong>当n较小时，我们使用range，但当i超过一定范围时，我们就必须考虑使用xrange了</strong></font>。</p>

<p>但是，二者性能差距的原因在哪里？</p>

<p>我们下文分析。</p>]]></description></item><item><title>详解Python中的迭代器和使用</title><link>http://www.cnblogs.com/inevermore/archive/2015/01/11/4216848.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 11 Jan 2015 09:42:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2015/01/11/4216848.html</guid><description><![CDATA[<p>对于一个列表，a = [1, 2, 3, 4]，我们最常见的遍历方式就是：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>a = [1, 2, 3, 4<span style="color: #000000">]
</span><span style="color: #0000ff">for</span> item <span style="color: #0000ff">in</span><span style="color: #000000"> a:
    </span><span style="color: #0000ff">print</span> item</pre>
</div>

<p>这里我们研究一种新的方式，就是迭代器。</p>

<p>在C++的STL中大量使用了迭代器，迭代器的作用当然就是遍历容器中的元素，而且他的好处就在于分离了容器的实现和遍历操作，不管我们使用什么类型的容器，使用迭代器的操作几乎是如出一辙。</p>

<p>&#160;</p>

<p>看下面的代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>&gt;&gt;&gt; a = [2, 3, 4<span style="color: #000000">]
</span>&gt;&gt;&gt; it =<span style="color: #000000"> iter(a)
</span>&gt;&gt;&gt; <span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
</span>2
&gt;&gt;&gt; <span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
</span>3
&gt;&gt;&gt; <span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
</span>4
&gt;&gt;&gt; <span style="color: #0000ff">print</span><span style="color: #000000"> it.next()
Traceback (most recent call last):
  File </span><span style="color: #800000">&quot;</span><span style="color: #800000">&lt;stdin&gt;</span><span style="color: #800000">&quot;</span>, line 1, <span style="color: #0000ff">in</span> &lt;module&gt;<span style="color: #000000">
StopIteration
</span>&gt;&gt;&gt;</pre>
</div>

<p>在上面的代码中，iter函数创建了一个可以迭代的对象，然后每次调用next方法，都能从其中取出元素。当没有元素可以迭代时，便抛出一个异常StopIteration。</p>

<p>&#160;</p>

<p>所以我们上面的for循环可以这样改写：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>a = [1, 2, 3, 4<span style="color: #000000">]

it </span>=<span style="color: #000000"> iter(a)
item </span>=<span style="color: #000000"> None
</span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
    </span><span style="color: #0000ff">try</span><span style="color: #000000">:
        item </span>=<span style="color: #000000"> it.next()
    </span><span style="color: #0000ff">except</span><span style="color: #000000"> StopIteration:
        </span><span style="color: #0000ff">break</span>
    <span style="color: #0000ff">print</span> item    <span style="color: #008000">#</span><span style="color: #008000">do_something</span></pre>
</div>

<p>&#160;</p>

<p><strong><font size="4">如何创建迭代器</font></strong></p>

<p>&#160;</p>

<p>现在我们想对我们自定义的class进行迭代操作，应该怎么办？</p>

<p>这里的关键是实现__iter__和next两个函数。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">!/usr/bin/env python</span><span style="color: #008000">
#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> IterList:
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, elem):
        self.iter </span>=<span style="color: #000000"> iter(elem) 
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__iter__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> self
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> next(self):
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> self.iter.next()

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    a </span>= [1, 2, 3, 4<span style="color: #000000">]
    test </span>=<span style="color: #000000"> IterList(a)
    </span><span style="color: #0000ff">for</span> item <span style="color: #0000ff">in</span><span style="color: #000000"> test:
        </span><span style="color: #0000ff">print</span> item</pre>
</div>

<p>这里我们仅仅是对class内部持有的元素做了一个包装，我们的__iter__返回的是自身，next则是调用的存储的iter的next方法。</p>

<p>&#160;</p>

<p>现在我们提供一个稍微复杂的版本，这个版本可以允许向next函数传递参数，指定取出几个值。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">!/usr/bin/env python</span><span style="color: #008000">
#</span><span style="color: #008000">coding: utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> IterList:
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, elem):
        self.iter </span>=<span style="color: #000000"> iter(elem) 
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__iter__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> self
    </span><span style="color: #0000ff">def</span> next(self, howmany=1<span style="color: #000000">):
        result </span>=<span style="color: #000000"> []
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(howmany):
            </span><span style="color: #0000ff">try</span><span style="color: #000000">:
                result.append(self.iter.next())
            </span><span style="color: #0000ff">except</span><span style="color: #000000"> StopIteration:
                </span><span style="color: #0000ff">raise</span>
        <span style="color: #0000ff">return</span><span style="color: #000000"> result

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    s </span>= range(20<span style="color: #000000">)
    test </span>=<span style="color: #000000"> IterList(s)
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> test.next()
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> test.next()
    </span><span style="color: #0000ff">print</span> test.next(3)</pre>
</div>
这个例子能够让我们更加清晰的认识到next函数的工作原理。 

<p>&#160;</p>

<p><strong><font size="4">用迭代器实现斐波那契数列</font></strong></p>

<p>&#160;</p>

<p>我们再给出最后一个关于斐波那契数列的例子：</p>

<p>对于斐波那契数列，我们可以这样实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">def</span><span style="color: #000000"> fab(max): 
    n, a, b </span>= 0, 0, 1<span style="color: #000000"> 
    L </span>=<span style="color: #000000"> [] 
    </span><span style="color: #0000ff">while</span> n &lt;<span style="color: #000000"> max: 
        L.append(b) 
        a, b </span>= b, a +<span style="color: #000000"> b 
        n </span>= n + 1 
    <span style="color: #0000ff">return</span><span style="color: #000000"> L

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> fab(5<span style="color: #000000">):
        </span><span style="color: #0000ff">print</span> i</pre>
</div>

<p>上面的fab函数返回一个列表，记录斐波那契数列的值。</p>

<p>但是，当max过大的时候，fab就必须生成一个巨大的列表，这不仅占用大量内存，也会消耗过多的时间。</p>

<p>下面我们使用迭代器，给出一个更加高效的实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Fab(object): 

    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, max): 
        self.max </span>=<span style="color: #000000"> max 
        self.n, self.a, self.b </span>= 0, 0, 1 

    <span style="color: #0000ff">def</span> <span style="color: #800080">__iter__</span><span style="color: #000000">(self): 
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> self 

    </span><span style="color: #0000ff">def</span><span style="color: #000000"> next(self): 
        </span><span style="color: #0000ff">if</span> self.n &lt;<span style="color: #000000"> self.max: 
            r </span>=<span style="color: #000000"> self.b 
            self.a, self.b </span>= self.b, self.a +<span style="color: #000000"> self.b 
            self.n </span>= self.n + 1 
            <span style="color: #0000ff">return</span><span style="color: #000000"> r 
        </span><span style="color: #0000ff">raise</span><span style="color: #000000"> StopIteration()

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> Fab(5<span style="color: #000000">):
        </span><span style="color: #0000ff">print</span> i</pre>
</div>

<p>这个版本高效在何处？</p>

<p>之前的版本是预先把一个巨大的结果生成，然后逐个去遍历，而这里调用Fab时，仅仅做了一个简单的初始化工作，<font color="#ff0000">真正的计算则是发生在每次迭代调用next的时候</font>。所以这里不会占用过大的内存，而且不需要预先计算，也节约了时间。</p>

<p>&#160;</p>

<p>本文最后部分参考了：<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank">http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/</a></p>]]></description></item><item><title>Ubuntu14.04使用samba服务器共享Home目录</title><link>http://www.cnblogs.com/inevermore/archive/2015/01/03/4199820.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 03 Jan 2015 10:43:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2015/01/03/4199820.html</guid><description><![CDATA[<p>这里记录一下，以Ubuntu 14.04为例。</p>  <p>&#160;</p>  <p>1.安装samba服务器。</p>  <blockquote>   <p>sudo apt-get install samba</p> </blockquote>  <p>2.修改配置文件</p>  <blockquote>   <p>sudo vim /etc/samba/smb.conf</p> </blockquote>  <p>然后找到home目录共享的部分，大概是190-214行，将前面的注释去掉，如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000"># Un-comment the following (and tweak the other settings below to suit)
# to enable the default home directory shares. This will share each
# user's home directory as \\server\username
[homes]
   comment = Home Directories
   browseable = yes

# By default, the home directories are exported read-only. Change the
# next parameter to 'no' if you want to be able to write to them.
   read only = no

# File creation mask is set to 0700 for security reasons. If you want to
# create files with group=rw permissions, set next parameter to 0775.
   create mask = 0666

# Directory creation mask is set to 0700 for security reasons. If you want to
# create dirs. with group=rw permissions, set next parameter to 0775.
   directory mask = 0755

# By default, \\server\username shares can be connected to by anyone
# with access to the samba server.
# Un-comment the following parameter to make sure that only &quot;username&quot;
# can connect to \\server\username
# This might need tweaking when using external authentication schemes
   valid users = %S</span></pre>
</div>



<p>这里的掩码我稍微做了修改。</p>

<p>&#160;</p>

<p>3.修改samba用户密码。</p>

<p>例如我的用户名是wing，那么需要创建一个相应的密码，用于samba共享，这个密码跟系统账户那个是不同的。</p>

<blockquote>
  <p>sudo smbpasswd -a wing</p>
</blockquote>

<p>然后重启samba服务</p>

<blockquote>
  <p>sudo service smbd restart</p>
</blockquote>

<p>4.在windows的资源管理器中打开<a href="file://\\192.168.1.6\homes">\\192.168.1.6\homes</a>(这里我的IP为192.168.1.6)，输入用户名和密码（注意是刚才设置的samba用户密码），就可以看到设置成功。</p>

<p>&#160;</p>

<p>如果感觉不太方便，可以把这个地址映射为文件夹或者一个虚拟的磁盘。</p>]]></description></item><item><title>使用Python发送电子邮件</title><link>http://www.cnblogs.com/inevermore/archive/2015/01/01/4197186.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 01 Jan 2015 05:43:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2015/01/01/4197186.html</guid><description><![CDATA[<p>使用python发送邮件并不难，这里使用的是SMTP协议。</p>  <p>Python标准库中内置了smtplib，使用它发送邮件只需提供邮件内容与发送者的凭证即可。</p>  <p>代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000"> coding:utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> smtplib
</span><span style="color: #0000ff">from</span> email.mime.text <span style="color: #0000ff">import</span><span style="color: #000000"> MIMEText
</span><span style="color: #0000ff">import</span><span style="color: #000000"> time
</span><span style="color: #0000ff">import</span><span style="color: #000000"> os
</span><span style="color: #0000ff">import</span><span style="color: #000000"> sys

</span><span style="color: #0000ff">def</span> send_mail(subject, body, mail_to, username, password, mail_type=<span style="color: #800000">'</span><span style="color: #800000">plain</span><span style="color: #800000">'</span><span style="color: #000000">):
    </span><span style="color: #0000ff">assert</span> isinstance(mail_to, list) ==<span style="color: #000000"> True
    msg </span>= MIMEText(body, _subtype=<span style="color: #000000">mail_type)
    </span><span style="color: #008000">#</span><span style="color: #008000"> 定义标题</span>
    msg[<span style="color: #800000">'</span><span style="color: #800000">Subject</span><span style="color: #800000">'</span>] =<span style="color: #000000"> subject
    </span><span style="color: #008000">#</span><span style="color: #008000"> 定义发信人</span>
    msg[<span style="color: #800000">'</span><span style="color: #800000">From</span><span style="color: #800000">'</span>] =<span style="color: #000000"> username
    </span><span style="color: #008000">#</span> 
    msg[<span style="color: #800000">'</span><span style="color: #800000">To</span><span style="color: #800000">'</span>] = <span style="color: #800000">'</span><span style="color: #800000">;</span><span style="color: #800000">'</span><span style="color: #000000">.join(mail_to)
    </span><span style="color: #008000">#</span><span style="color: #008000"> 定义发送时间（不定义的可能有的邮件客户端会不显示发送时间）</span>
    msg[<span style="color: #800000">'</span><span style="color: #800000">date</span><span style="color: #800000">'</span>] = time.strftime(<span style="color: #800000">'</span><span style="color: #800000">%a, %d %b %Y %H:%M:%S %z</span><span style="color: #800000">'</span><span style="color: #000000">)
    </span><span style="color: #0000ff">try</span><span style="color: #000000">:
        smtp </span>=<span style="color: #000000"> smtplib.SMTP()
        </span><span style="color: #008000">#</span><span style="color: #008000"> 连接SMTP服务器，</span>
        smtp.connect(<span style="color: #800000">'</span><span style="color: #800000">smtp.exmail.qq.com</span><span style="color: #800000">'</span><span style="color: #000000">)
        </span><span style="color: #008000">#</span><span style="color: #008000"> 用户名密码</span>
<span style="color: #000000">        smtp.login(username, password)
        smtp.sendmail(username, mail_to, msg.as_string())
        smtp.quit()
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> True
    </span><span style="color: #0000ff">except</span><span style="color: #000000"> Exception as e:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">&quot;</span><span style="color: #800000">send mail error:%s</span><span style="color: #800000">&quot;</span>%<span style="color: #000000">e
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> False

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">&quot;</span><span style="color: #800000">__main__</span><span style="color: #800000">&quot;</span><span style="color: #000000">:

    </span><span style="color: #0000ff">if</span> len(sys.argv) &lt; 2<span style="color: #000000">:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Usage : python mail.py object_mail</span><span style="color: #800000">'</span><span style="color: #000000">
        sys.exit()

    subject </span>= <span style="color: #800000">'</span><span style="color: #800000">你好，这是一封测试邮件</span><span style="color: #800000">'</span><span style="color: #000000">
    body </span>= <span style="color: #800000">'''</span><span style="color: #800000">
这是经过我们的python程序发送的一封邮件，请勿直接回复
    </span><span style="color: #800000">'''</span><span style="color: #000000">
    mail_to </span>= [sys.argv[1<span style="color: #000000">]]
    username </span>= <span style="color: #800000">'</span><span style="color: #800000">inevermore@foxmail.com</span><span style="color: #800000">'</span><span style="color: #000000">
    password </span>= os.getenv(<span style="color: #800000">'</span><span style="color: #800000">PASSWORD</span><span style="color: #800000">'</span><span style="color: #000000">)
    send_mail(subject, body, mail_to, username, password)</span></pre>
</div>

<p>这里有几点：</p>

<blockquote>
  <p>1.我把邮箱的密码设置在了环境变量中，可以使用 export PASSWORD=’XXXXXXXX’ 设置</p>
</blockquote>

<blockquote>
  <p>2.发送者的邮箱必须开通SMTP发送服务，否则程序会抛出异常。</p>
</blockquote>

<blockquote>
  <p>3.使用 python mail.py 收件人的地址 即可发送成功 </p></blockquote>]]></description></item><item><title>一个用于统计函数调用消耗时间的装饰器</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/30/4194584.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Tue, 30 Dec 2014 13:31:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/30/4194584.html</guid><description><![CDATA[<p>装饰器前面提过了，采用python的闭包特性实现：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> time
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> count_time():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> tmp(func):
        </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
            begin_time </span>=<span style="color: #000000"> time()
            result </span>= func(*args, **<span style="color: #000000">kargs)
            end_time </span>=<span style="color: #000000"> time()
            cost_time </span>= end_time -<span style="color: #000000"> begin_time
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">%s called cost time : %s</span><span style="color: #800000">'</span> %(func.<span style="color: #800080">__name__</span><span style="color: #000000">, cost_time)
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> result
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> tmp

@count_time()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test():
    sleep(</span>0.5<span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    test()</span></pre>
</div>

<p>我们尝试以下的代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Test:
    @count_time()
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> test(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
</span><span style="color: #008000">#</span><span style="color: #008000">    test()</span>
    a =<span style="color: #000000"> Test()
    a.test()</span></pre>
</div>

<p>代码仍然可以正常工作，因为a.test()仅仅就是给test添加了一个额外的参数a而已。</p>]]></description></item><item><title>使用Tornado实现Ajax请求</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/29/4192615.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 29 Dec 2014 15:16:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/29/4192615.html</guid><description><![CDATA[<p>Ajax，指的是网页异步刷新，一般的实现均为js代码向server发POST请求，然后将收到的结果返回在页面上。</p>  <p>&#160;</p>  <p>这里我编写一个简单的页面，ajax.html</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>测试Ajax<span style="color: #0000ff">&lt;/</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">meta </span><span style="color: #ff0000">http-equiv</span><span style="color: #0000ff">=&quot;Content-Type&quot;</span><span style="color: #ff0000"> content</span><span style="color: #0000ff">=&quot;text/html; charset=utf-8&quot;</span> <span style="color: #0000ff">/&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">script </span><span style="color: #ff0000">src</span><span style="color: #0000ff">=&quot;http://code.jquery.com/jquery-1.9.1.min.js&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">script</span><span style="color: #0000ff">&gt;</span>  

    <span style="color: #0000ff">&lt;</span><span style="color: #800000">style </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text/css&quot;</span><span style="color: #0000ff">&gt;</span><span style="background-color: #f5f5f5; color: #800000">
#result</span><span style="background-color: #f5f5f5; color: #000000">{</span><span style="background-color: #f5f5f5; color: #ff0000">
    border</span><span style="background-color: #f5f5f5; color: #000000">:</span><span style="background-color: #f5f5f5; color: #0000ff"> 10px</span><span style="background-color: #f5f5f5; color: #000000">;</span><span style="background-color: #f5f5f5; color: #ff0000">
    font-size</span><span style="background-color: #f5f5f5; color: #000000">:</span><span style="background-color: #f5f5f5; color: #0000ff"> 50px</span><span style="background-color: #f5f5f5; color: #000000">;</span><span style="background-color: #f5f5f5; color: #ff0000">
    background</span><span style="background-color: #f5f5f5; color: #000000">:</span><span style="background-color: #f5f5f5; color: #0000ff"> #ff0fef</span><span style="background-color: #f5f5f5; color: #000000">;</span>
<span style="background-color: #f5f5f5; color: #000000">}</span>


    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">style</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>

    <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> id</span><span style="color: #0000ff">=&quot;word&quot;</span> <span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">button </span><span style="color: #ff0000">id</span><span style="color: #0000ff">=&quot;foo&quot;</span><span style="color: #0000ff">&gt;</span>点击<span style="color: #0000ff">&lt;/</span><span style="color: #800000">button</span><span style="color: #0000ff">&gt;</span>

    <span style="color: #0000ff">&lt;</span><span style="color: #800000">div </span><span style="color: #ff0000">id</span><span style="color: #0000ff">=&quot;result&quot;</span><span style="color: #0000ff">&gt;</span>

    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">div</span><span style="color: #0000ff">&gt;</span>


<span style="color: #0000ff">&lt;</span><span style="color: #800000">script </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text/javascript&quot;</span><span style="color: #0000ff">&gt;</span><span style="background-color: #f5f5f5; color: #000000">
    $(</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">#foo</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">).click(</span><span style="background-color: #f5f5f5; color: #0000ff">function</span><span style="background-color: #f5f5f5; color: #000000">()
    {
        </span><span style="background-color: #f5f5f5; color: #0000ff">var</span><span style="background-color: #f5f5f5; color: #000000"> word </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> $(</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">#word</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">).val(); </span><span style="background-color: #f5f5f5; color: #008000">//</span><span style="background-color: #f5f5f5; color: #008000">获取文本框的输入</span>

        <span style="background-color: #f5f5f5; color: #008000">//</span><span style="background-color: #f5f5f5; color: #008000">把word发给后台php程序</span>
        <span style="background-color: #f5f5f5; color: #008000">//</span><span style="background-color: #f5f5f5; color: #008000">返回的数据放在data中，返回状态放在status</span>
<span style="background-color: #f5f5f5; color: #000000">        $.post(</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">/test</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">,{message:word}, </span><span style="background-color: #f5f5f5; color: #0000ff">function</span><span style="background-color: #f5f5f5; color: #000000">(data,status){
            </span><span style="background-color: #f5f5f5; color: #0000ff">if</span><span style="background-color: #f5f5f5; color: #000000">(status </span><span style="background-color: #f5f5f5; color: #000000">==</span> <span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">success</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">)
            {
                $(</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">#result</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">).html(data);
            }
            </span><span style="background-color: #f5f5f5; color: #0000ff">else</span><span style="background-color: #f5f5f5; color: #000000">
            {
                alert(</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">Ajax 失败</span><span style="background-color: #f5f5f5; color: #000000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">);
            }
        });
    });


</span><span style="color: #0000ff">&lt;/</span><span style="color: #800000">script</span><span style="color: #0000ff">&gt;</span>

<span style="color: #0000ff">&lt;/</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>注意，从上面的代码可以看出，数据存储在“message”字段中。</p>

<p>所以后台从message中解析数据，我们记得是get_argument方法。</p>

<p>所以后台的python代码为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.render(</span><span style="color: #800000">&quot;</span><span style="color: #800000">ajax.html</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> AjaxHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        </span><span style="color: #008000">#</span><span style="color: #008000">self.write(&quot;hello world&quot;)</span>
        self.write(self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">message</span><span style="color: #800000">&quot;</span><span style="color: #000000">))

application </span>=<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/test</span><span style="color: #800000">&quot;</span><span style="color: #000000">, AjaxHandler),
    ])

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>
访问首页，就渲染ajax前端页面，而AjaxHandler处理真正的ajax异步请求。 

<p>&#160;</p>

<p>这里总结下流程：</p>

<blockquote>
  <p>1.用户访问home页面，tornado使用MainHandler返回其中的ajax.html页面</p>
</blockquote>

<blockquote>
  <p>2.用户填写信息，点击按钮，因为之前加载js代码，注册了回调函数，所以触发Ajax</p>
</blockquote>

<blockquote>
  <p>3.js向后台发post请求。</p>
</blockquote>

<blockquote>
  <p>4.根据请求的URL，tornado使用AjaxHandler处理post请求，将信息原样返回。</p>
</blockquote>

<blockquote>
  <p>5.js收到数据，调用之前的回调函数，将结果显示在html页面上。</p></blockquote>]]></description></item><item><title>使用tornado实现用户认证</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/29/4192487.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 29 Dec 2014 13:54:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/29/4192487.html</guid><description><![CDATA[<p>关于用户的登录状态，一部分的应用程序是采用session实现的。</p>  <p>HTTP是一个无状态协议，用户的每次请求都是相互独立的，HTTP本身意识不到用户是否登录。</p>  <p>很多web框架选择将session存放在cookies中，本节我们也是这样实现：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> BaseHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get_current_user(self):
        </span><span style="color: #0000ff">return</span> self.get_secure_cookie(<span style="color: #800000">&quot;</span><span style="color: #800000">user</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(BaseHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> self.current_user:
            self.redirect(</span><span style="color: #800000">&quot;</span><span style="color: #800000">/login</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
            </span><span style="color: #0000ff">return</span><span style="color: #000000">
        name </span>=<span style="color: #000000"> tornado.escape.xhtml_escape(self.current_user)
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">Hello, </span><span style="color: #800000">&quot;</span> +<span style="color: #000000"> name)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> LoginHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.render(</span><span style="color: #800000">&quot;</span><span style="color: #800000">login.html</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        self.set_secure_cookie(</span><span style="color: #800000">&quot;</span><span style="color: #800000">user</span><span style="color: #800000">&quot;</span>, self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">name</span><span style="color: #800000">&quot;</span><span style="color: #000000">))
        self.redirect(</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

application </span>=<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/login</span><span style="color: #800000">&quot;</span><span style="color: #000000">, LoginHandler)
    ], cookie_secret</span>=<span style="color: #800000">&quot;</span><span style="color: #800000">61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>

<p>这里的核心便是LoginHandler类，他的get方法对于HTTP的GET请求，返回一个表单，对于post方法，则认为是用户的登录动作。</p>

<p>登录页面login.html代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>Login<span style="color: #0000ff">&lt;/</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">form </span><span style="color: #ff0000">action</span><span style="color: #0000ff">=&quot;/login&quot;</span><span style="color: #ff0000"> method</span><span style="color: #0000ff">=&quot;post&quot;</span><span style="color: #ff0000"> accept-charset</span><span style="color: #0000ff">=&quot;utf-8&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;name&quot;</span><span style="color: #ff0000"> value</span><span style="color: #0000ff">=&quot;your username&quot;</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #ff0000"> value</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">form</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>这里处理实际登录的逻辑是，在cookies中存入相应的数据。</p>

<p>这样，<font color="#ff0000">我们检测用户是否登录，只需检测cookies即可，这是BaseHandler的核心逻辑，它重写了父类的get_current_user方法</font>。</p>

<p>注意MainHandler的逻辑：</p>

<blockquote>
  <p>如果用户没有登录，那么跳转到登录页面。</p>
</blockquote>

<blockquote>
  <p>如果用户登录，那么打印出欢迎的语句。</p>
</blockquote>

<p><strong><font size="3">采用装饰器</font></strong></p>

<p>&#160;</p>

<p>这里的检查登录的代码，我们可以使用闭包写一个装饰器，这样可以减少代码的冗余：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>login_url = <span style="color: #800000">&quot;</span><span style="color: #800000">login.html</span><span style="color: #800000">&quot;</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> require_login():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> temp(func):
        </span><span style="color: #0000ff">def</span> wrapped(self, *args, **<span style="color: #000000">kargs):
            </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> self.current_user:
                self.redirect(login_url</span><span style="color: #000000">)
            </span><span style="color: #0000ff">return</span>
        <span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span> temp</pre>
</div>

<p>这样我们在MainHandler中只需要采用装饰器修饰即可：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(BaseHandler):
    @require_login()
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        name </span>=<span style="color: #000000"> tornado.escape.xhtml_escape(self.current_user)
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">Hello, </span><span style="color: #800000">&quot;</span> + name)</pre>
</div>

<p>&#160;</p>

<p><strong><font size="3">采用框架提供的装饰器</font></strong></p>

<p>&#160;</p>

<p>MainHandler需要检测用户是否登录，<font color="#ff0000">我们可以采用装饰器@tornado.web.authenticated来帮助我们完成这一目标，而不需要手工写出检测的代码</font>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> BaseHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get_current_user(self):
        </span><span style="color: #0000ff">return</span> self.get_secure_cookie(<span style="color: #800000">&quot;</span><span style="color: #800000">user</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(BaseHandler):
    @tornado.web.authenticated
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        name </span>=<span style="color: #000000"> tornado.escape.xhtml_escape(self.current_user)
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">Hello, </span><span style="color: #800000">&quot;</span> +<span style="color: #000000"> name)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> LoginHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.render(</span><span style="color: #800000">&quot;</span><span style="color: #800000">login.html</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        self.set_secure_cookie(</span><span style="color: #800000">&quot;</span><span style="color: #800000">user</span><span style="color: #800000">&quot;</span>, self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">name</span><span style="color: #800000">&quot;</span><span style="color: #000000">))
        self.redirect(</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

settings </span>=<span style="color: #000000"> {
        </span><span style="color: #800000">&quot;</span><span style="color: #800000">cookie_secret</span><span style="color: #800000">&quot;</span>: <span style="color: #800000">&quot;</span><span style="color: #800000">61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o</span><span style="color: #800000">&quot;</span><span style="color: #000000">,
        </span><span style="color: #800000">&quot;</span><span style="color: #800000">login_url</span><span style="color: #800000">&quot;</span>: <span style="color: #800000">&quot;</span><span style="color: #800000">/login</span><span style="color: #800000">&quot;</span><span style="color: #000000">,
}

application </span>=<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/login</span><span style="color: #800000">&quot;</span><span style="color: #000000">, LoginHandler)
    ], </span>**<span style="color: #000000">settings) 

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>

<p>很显然，@tornado.web.authenticated这个装饰器的功能<font color="#ff0000">与我们编写的require_login功能相似</font>。</p>

<p>另外，在自己编写的装饰器中，<font color="#ff0000">我们将login_url单独做成了变量，保证可配置性，所以这里我们也需要配置login_url选项</font>。</p>]]></description></item><item><title>Tornado框架中视图模板Template的使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/28/4190382.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Dec 2014 12:12:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/28/4190382.html</guid><description><![CDATA[<p>上文的程序中有这样一段：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">class</span><span style="color: #000000"> MessageHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">'''</span><span style="color: #800000">
&lt;html&gt;
&lt;head&gt;
        &lt;title&gt;Please Input Message&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
        &lt;form action=&quot;/message&quot; method=&quot;post&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;br&gt;
                &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
        &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</span><span style="color: #800000">'''</span><span style="color: #000000"> 
        )
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        </span><span style="color: #008000">#</span><span style="color: #008000">self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span>
        self.write(<span style="color: #800000">&quot;</span><span style="color: #800000">You wrote &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">message</span><span style="color: #800000">&quot;</span>) + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span>)</pre>
</div>

<p>当收到GET请求时，返回一段HTML表单。</p>

<p>上面的这种写法，将html写在python代码中，灵活性差，而且view代码与controller代码混合在一块，不符合MVC的原则。</p>

<p>所以我们采用Tornado中的模板。</p>

<p>新建form.html：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>{{title}}<span style="color: #0000ff">&lt;/</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">form </span><span style="color: #ff0000">action</span><span style="color: #0000ff">=&quot;/message&quot;</span><span style="color: #ff0000"> method</span><span style="color: #0000ff">=&quot;post&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;message&quot;</span><span style="color: #ff0000"> value</span><span style="color: #0000ff">=&quot;please input.&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #ff0000"> value</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">form</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>然后将上面的python代码修改为：</p>

<p>&#160;</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> MessageHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.render(</span><span style="color: #800000">&quot;</span><span style="color: #800000">form.html</span><span style="color: #800000">&quot;</span>, title=<span style="color: #800000">&quot;</span><span style="color: #800000">Input Message</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        </span><span style="color: #008000">#</span><span style="color: #008000">self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span>
        self.write(<span style="color: #800000">&quot;</span><span style="color: #800000">You wrote &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">message</span><span style="color: #800000">&quot;</span>) + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span>)</pre>
</div>

<p>这样代码简洁了很多。</p>

<p>&#160;</p>





<p>完整的代码是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">&lt;h1&gt;This is Home Page!&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> StoryHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self, story_id):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">You request the story &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + story_id + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MessageHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.render(</span><span style="color: #800000">&quot;</span><span style="color: #800000">form.html</span><span style="color: #800000">&quot;</span>, title=<span style="color: #800000">&quot;</span><span style="color: #800000">Input Message</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        </span><span style="color: #008000">#</span><span style="color: #008000">self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span>
        self.write(<span style="color: #800000">&quot;</span><span style="color: #800000">You wrote &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">message</span><span style="color: #800000">&quot;</span>) + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

application </span>=<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/story/([0-9]+)</span><span style="color: #800000">&quot;</span><span style="color: #000000">, StoryHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/message</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MessageHandler),
    ])

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>]]></description></item><item><title>Tornado框架的初步使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/28/4190289.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Dec 2014 11:06:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/28/4190289.html</guid><description><![CDATA[<p>Tornado的搭建很简单，使用pip，或者下载源码均可。</p>  <p>&#160;</p>  <p>我们先看一个最简单的程序：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">&lt;h1&gt;Hello World&lt;h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

application </span>= tornado.web.Application([(r<span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),])

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>

<p>我们运行这个程序，打开浏览器输入：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>http://localhost:8888/</pre>
</div>

<p>就可以看到加粗的helloworld。</p>

<p>&#160;</p>

<p>那么这段代码到底什么意思：</p>

<p>我们先看 </p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">Hello, world</span><span style="color: #800000">&quot;</span>)</pre>
</div>



<p>这里<font color="#ff0000">定义了一个处理器，里面定义个一个get方法，对应Http协议中的GET请求</font>。</p>

<p>然后是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>application =<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
])</span></pre>
</div>

<p>这里的含义是：如果用户输入的路径是“/”，也就是根路径，那么将使用我们刚才编写的MainHandler，<font color="#ff0000">如果该请求使用的GET，那么调用MainHandler的get方法，如果是POST请求，则去调用MainHandler中的post方法</font>。</p>

<p>&#160;</p>

<p>所以我们输入上面的网址，tornado调用了MainHandler中的get方法，返回&quot;&lt;h1&gt;Hello World&lt;h1&gt;&quot;</p>

<p>&#160;</p>

<p>我们再看一个稍微复杂的程序：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">&lt;h1&gt;This is Home Page!&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> StoryHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self, story_id):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">You request the story &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + story_id + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

application </span>=<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/story/([0-9]+)</span><span style="color: #800000">&quot;</span><span style="color: #000000">, StoryHandler),
    ])

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>

<p>上面代码的含义是：</p>

<blockquote>
  <p>对于/根目录，使用MainHandler，处理GET请求。</p>

  <p><font color="#ff0000">对于/story/99这种，使用StoryHandler，处理GET请求</font>。</p>
</blockquote>

<p>下面看一个更加复杂的程序：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.ioloop
</span><span style="color: #0000ff">import</span><span style="color: #000000"> tornado.web

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MainHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">&lt;h1&gt;This is Home Page!&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> StoryHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self, story_id):
        self.write(</span><span style="color: #800000">&quot;</span><span style="color: #800000">You request the story &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + story_id + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MessageHandler(tornado.web.RequestHandler):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> get(self):
        self.write(</span><span style="color: #800000">'''</span><span style="color: #800000">
&lt;html&gt;
&lt;head&gt;
        &lt;title&gt;Please Input Message&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
        &lt;form action=&quot;/message&quot; method=&quot;post&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;br&gt;
                &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
        &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</span><span style="color: #800000">'''</span><span style="color: #000000"> 
        )
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> post(self):
        </span><span style="color: #008000">#</span><span style="color: #008000">self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span>
        self.write(<span style="color: #800000">&quot;</span><span style="color: #800000">You wrote &lt;h1&gt;</span><span style="color: #800000">&quot;</span> + self.get_argument(<span style="color: #800000">&quot;</span><span style="color: #800000">message</span><span style="color: #800000">&quot;</span>) + <span style="color: #800000">&quot;</span><span style="color: #800000">&lt;/h1&gt;</span><span style="color: #800000">&quot;</span><span style="color: #000000">)

application </span>=<span style="color: #000000"> tornado.web.Application([
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MainHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/story/([0-9]+)</span><span style="color: #800000">&quot;</span><span style="color: #000000">, StoryHandler),
    (r</span><span style="color: #800000">&quot;</span><span style="color: #800000">/message</span><span style="color: #800000">&quot;</span><span style="color: #000000">, MessageHandler),
    ])

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    application.listen(</span>8888<span style="color: #000000">)
    tornado.ioloop.IOLoop.instance().start()</span></pre>
</div>


这里，输入/message这个URL，使用的是MessageHandler，调用其中的get方法，返回一段HTML代码，其中含有一个表单，提交后，<font color="#ff0000">仍使用/message，但是此时采用POST请求提交</font>。后端Tornado收到这段数据，采用MessageHandler的post方法，处理这段文本，将其回显给用户。]]></description></item><item><title>使用Python实现生产者消费者问题</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/28/4189958.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Dec 2014 06:36:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/28/4189958.html</guid><description><![CDATA[<p>之前用C++写过一篇生产者消费者的实现。</p>  <p>生产者和消费者主要是处理互斥和同步的问题：</p>  <blockquote>   <p>队列作为缓冲区，需要互斥操作</p> </blockquote>  <blockquote>   <p>队列中没有产品，消费者需要等待，直到生产者放入产品并通知它。队列慢的情况类似。</p> </blockquote>  <p>这里我使用list模拟Python标准库的Queue，这里我设置一个大小限制为5：</p>  <p>SyncQueue.py</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">from</span> threading <span style="color: #0000ff">import</span><span style="color: #000000"> Lock
</span><span style="color: #0000ff">from</span> threading <span style="color: #0000ff">import</span><span style="color: #000000"> Condition
</span><span style="color: #0000ff">class</span><span style="color: #000000"> Queue():
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self):
        self.mutex </span>=<span style="color: #000000"> Lock()
        self.full </span>=<span style="color: #000000"> Condition(self.mutex)
        self.empty </span>=<span style="color: #000000"> Condition(self.mutex)
        self.data </span>=<span style="color: #000000"> []

    </span><span style="color: #0000ff">def</span><span style="color: #000000"> push(self, element):
        self.mutex.acquire()
        </span><span style="color: #0000ff">while</span> len(self.data) &gt;= 5<span style="color: #000000">:
            self.empty.wait()
            
        self.data.append(element)
        self.full.notify()    
        self.mutex.release()


    </span><span style="color: #0000ff">def</span><span style="color: #000000"> pop(self):
        self.mutex.acquire()
        </span><span style="color: #0000ff">while</span> len(self.data) ==<span style="color: #000000"> 0:
            self.full.wait()
        data </span>=<span style="color: #000000"> self.data[0]
        self.data.pop(0)
        self.empty.notify()
        self.mutex.release()

        </span><span style="color: #0000ff">return</span><span style="color: #000000"> data

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    q </span>=<span style="color: #000000"> Queue()
    q.push(</span>10<span style="color: #000000">)
    q.push(</span>2<span style="color: #000000">)
    q.push(</span>13<span style="color: #000000">)

    </span><span style="color: #0000ff">print</span><span style="color: #000000"> q.pop()
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> q.pop()
    </span><span style="color: #0000ff">print</span> q.pop()</pre>
</div>



<p>这是最核心的代码，注意里面判断条件要使用while循环。</p>

<p>接下来是生产者进程，producer.py</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> threading <span style="color: #0000ff">import</span><span style="color: #000000"> Thread
</span><span style="color: #0000ff">from</span> random <span style="color: #0000ff">import</span><span style="color: #000000"> randrange
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep
</span><span style="color: #0000ff">from</span> SyncQueue <span style="color: #0000ff">import</span><span style="color: #000000"> Queue

</span><span style="color: #0000ff">class</span><span style="color: #000000"> ProducerThread(Thread):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, queue):
        Thread.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self)
        self.queue </span>=<span style="color: #000000"> queue
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> run(self):
        </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
            data </span>= randrange(0, 100<span style="color: #000000">)
            self.queue.push(data)
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">push %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (data)
            sleep(</span>1<span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    q </span>=<span style="color: #000000"> Queue()
    t </span>=<span style="color: #000000"> ProducerThread(q)
    t.start()
    t.join()</span></pre>
</div>



<p>消费者,Condumer.py</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> threading <span style="color: #0000ff">import</span><span style="color: #000000"> Thread
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep
</span><span style="color: #0000ff">from</span> SyncQueue <span style="color: #0000ff">import</span><span style="color: #000000"> Queue

</span><span style="color: #0000ff">class</span><span style="color: #000000"> ConsumerThread(Thread):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, queue):
        Thread.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self)
        self.queue </span>=<span style="color: #000000"> queue
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> run(self):
        </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
            data </span>=<span style="color: #000000"> self.queue.pop()
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">pop %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (data)
            sleep(</span>1<span style="color: #000000">)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    q </span>=<span style="color: #000000"> Queue()
    t </span>=<span style="color: #000000"> ConsumerThread(q)
    t.start()
    t.join()</span></pre>
</div>



<p>最后我们写一个车间类,可以指定线程数量:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> SyncQueue <span style="color: #0000ff">import</span><span style="color: #000000"> Queue
</span><span style="color: #0000ff">from</span> Producer <span style="color: #0000ff">import</span><span style="color: #000000"> ProducerThread
</span><span style="color: #0000ff">from</span> Consumer <span style="color: #0000ff">import</span><span style="color: #000000"> ConsumerThread

</span><span style="color: #0000ff">class</span><span style="color: #000000"> WorkShop():
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, producerNums, consumerNums):
        self.producers </span>=<span style="color: #000000"> []
        self.consumers </span>=<span style="color: #000000"> []
        self.queue </span>=<span style="color: #000000"> Queue()
        self.producerNums </span>=<span style="color: #000000"> producerNums
        self.consumerNums </span>=<span style="color: #000000"> consumerNums
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> start(self):
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(self.producerNums):
            self.producers.append(ProducerThread(self.queue))
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(self.consumerNums):
            self.consumers.append(ConsumerThread(self.queue))
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(len(self.producers)):
            self.producers[i].start()
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(len(self.consumers)):
            self.consumers[i].start()
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(len(self.producers)):
            self.producers[i].join()
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> range(len(self.consumers)):
            self.consumers[i].join()

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    w </span>= WorkShop(3, 4<span style="color: #000000">)
    w.start()</span></pre>
</div>



<p>最后写一个main模块:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> WorkShop <span style="color: #0000ff">import</span><span style="color: #000000"> WorkShop

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    w </span>= WorkShop(2, 3<span style="color: #000000">)
    w.start()</span></pre>
</div>]]></description></item><item><title>Python实现快速排序</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/27/4189258.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 27 Dec 2014 14:10:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/27/4189258.html</guid><description><![CDATA[<p>这里采用的是算法导论的划分方式：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">import</span><span style="color: #000000"> random

</span><span style="color: #0000ff">def</span><span style="color: #000000"> partition(array, left, right):
    pivot </span>=<span style="color: #000000"> array[left]
    i </span>=<span style="color: #000000"> left
    </span><span style="color: #008000">#</span><span style="color: #008000">j left +1 -&gt; right</span>
    <span style="color: #0000ff">for</span> j <span style="color: #0000ff">in</span> range(left + 1, right + 1<span style="color: #000000">):
        </span><span style="color: #0000ff">if</span> array[j] &lt;<span style="color: #000000"> pivot:
            i </span>+= 1<span style="color: #000000">
            temp </span>=<span style="color: #000000"> array[i]
            array[i] </span>=<span style="color: #000000"> array[j]
            array[j] </span>=<span style="color: #000000"> temp
    temp </span>=<span style="color: #000000"> array[left]
    array[left] </span>=<span style="color: #000000"> array[i]
    array[i] </span>=<span style="color: #000000"> temp
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> i

</span><span style="color: #0000ff">def</span><span style="color: #000000"> quickSort(array, left, right):
    </span><span style="color: #0000ff">if</span> left &lt;<span style="color: #000000"> right:
        pos </span>=<span style="color: #000000"> partition(array, left, right)
        quickSort(array, left, pos</span>-1<span style="color: #000000">)
        quickSort(array, pos</span>+1<span style="color: #000000">, right)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    arr </span>=<span style="color: #000000"> []
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(40<span style="color: #000000">):
        arr.append(random.randrange(</span>10,100<span style="color: #000000">))
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> arr
    quickSort(arr, 0, len(arr)</span>-1<span style="color: #000000">)
    </span><span style="color: #0000ff">print</span> arr</pre>
</div>

<p>&#160;</p>

<p>运行结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>~/Documents/py python 5<span style="color: #000000">.py
[</span>44, 46, 89, 97, 89, 68, 36, 28, 43, 74, 19, 62, 62, 53, 30, 30, 32, 98, 62, 25, 63, 37, 94, 21, 46, 93, 63, 80, 76, 62, 57, 24, 53, 49, 90, 67, 48, 75, 96, 75<span style="color: #000000">]
[</span>19, 21, 24, 25, 28, 30, 30, 32, 36, 37, 43, 44, 46, 46, 48, 49, 53, 53, 57, 62, 62, 62, 62, 63, 63, 67, 68, 74, 75, 75, 76, 80, 89, 89, 90, 93, 94, 96, 97, 98]</pre>
</div>

<p>这里代码的风格仍侧重于C语言。</p>

<p>我将两个数字交换的代码,写成python风格:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">def</span><span style="color: #000000"> partition(array, left, right):
    pivot </span>=<span style="color: #000000"> array[left]
    i </span>=<span style="color: #000000"> left
    </span><span style="color: #008000">#</span><span style="color: #008000">j left +1 -&gt; right</span>
    <span style="color: #0000ff">for</span> j <span style="color: #0000ff">in</span> range(left + 1, right + 1<span style="color: #000000">):
        </span><span style="color: #0000ff">if</span> array[j] &lt;<span style="color: #000000"> pivot:
            i </span>+= 1<span style="color: #000000">
            array[i], array[j] </span>=<span style="color: #000000"> array[j], array[i]
    array[left], array[i] </span>=<span style="color: #000000"> array[i], array[left]
    </span><span style="color: #0000ff">return</span> i</pre>
</div>


这样就简洁了很多]]></description></item><item><title>Python闭包的高级应用-装饰器的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/27/4189225.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 27 Dec 2014 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/27/4189225.html</guid><description><![CDATA[<p>我们先看一个闭包的例子：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

</span><span style="color: #0000ff">def</span><span style="color: #000000"> before_call(f):
    </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">before calling, now is %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> ctime()
        </span><span style="color: #0000ff">return</span> f(*args, **<span style="color: #000000">kargs)
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped

</span><span style="color: #0000ff">def</span><span style="color: #000000"> test(name):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">hello, %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (name)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    before_call(test)(</span><span style="color: #800000">&quot;</span><span style="color: #800000">lucky</span><span style="color: #800000">&quot;</span>)</pre>
</div>



<p>我们先看运行结果：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>~/Documents/py python 2<span style="color: #000000">.py 
before calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:30:18 2014<span style="color: #000000">
hello, lucky</span></pre>
</div>



<p>上面的代码使用了闭包，因为子函数wrapped将父函数的内部变量f与之绑定。</p>

<p>这样，wrapped这个闭包函数，实际上先打印时间，然后调用f，所以正如结果打印的一般，<font color="#ff0000">before_call起到的是一种装饰的作用</font>。</p>

<p>&#160;</p>

<p>这里我扩展它的功能，增加一个调用函数后，打印时间：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

</span><span style="color: #0000ff">def</span><span style="color: #000000"> before_call(f):
    </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">before calling, now is %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> ctime()
        </span><span style="color: #0000ff">return</span> f(*args, **<span style="color: #000000">kargs)
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped

</span><span style="color: #0000ff">def</span><span style="color: #000000"> after_call(f):
    </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
        </span><span style="color: #0000ff">try</span><span style="color: #000000">:
            </span><span style="color: #0000ff">return</span> f(*args, **<span style="color: #000000">kargs)
        </span><span style="color: #0000ff">finally</span><span style="color: #000000">:
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">after calling, now is %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> ctime()
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped

</span><span style="color: #0000ff">def</span><span style="color: #000000"> test(name):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">hello, %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (name)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    before_call(test)(</span><span style="color: #800000">&quot;</span><span style="color: #800000">lucky</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    after_call(test)(</span><span style="color: #800000">&quot;</span><span style="color: #800000">peter</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    before_call(after_call(test))(</span><span style="color: #800000">&quot;</span><span style="color: #800000">john</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    after_call(before_call(test))(</span><span style="color: #800000">'</span><span style="color: #800000">marry</span><span style="color: #800000">'</span>)</pre>
</div>



<p>运行结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>~/Documents/py python 2<span style="color: #000000">.py 
before calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:37:24 2014<span style="color: #000000">
hello, lucky
hello, peter
after calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:37:24 2014<span style="color: #000000">
before calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:37:24 2014<span style="color: #000000">
hello, john
after calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:37:24 2014<span style="color: #000000">
before calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:37:24 2014<span style="color: #000000">
hello, marry
after calling, now </span><span style="color: #0000ff">is</span> Sat Dec 27 21:37:24 2014</pre>
</div>

<p>运行结果是正确的。注意最后两个，顺序交换了，对结果无影响。</p>

<p>&#160;</p>

<p>下面我们再包装一层：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">def</span><span style="color: #000000"> after_call():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> after(f):
        </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
            </span><span style="color: #0000ff">try</span><span style="color: #000000">:
                </span><span style="color: #0000ff">return</span> f(*args, **<span style="color: #000000">kargs)
            </span><span style="color: #0000ff">finally</span><span style="color: #000000">:
                </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">after calling, now is %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> ctime()
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> after


</span><span style="color: #0000ff">def</span><span style="color: #000000"> before_call():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> before(f):
        </span><span style="color: #0000ff">def</span> wrapped(*args, **<span style="color: #000000">kargs):
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">before calling, now is %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> ctime()
            </span><span style="color: #0000ff">return</span> f(*args, **<span style="color: #000000">kargs)
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrapped
    </span><span style="color: #0000ff">return</span> before</pre>
</div>



<p>那么如何使用呢？这里就是python装饰器的语法，</p>

<p>如果我们这样使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">@before_call()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test(name):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">hello, %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (name)

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    test(</span><span style="color: #800000">&quot;</span><span style="color: #800000">lucky</span><span style="color: #800000">&quot;</span>)</pre>
</div>



<p>注意test函数前加了装饰的符号。</p>

<p>还可以这样：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">@after_call()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test(name):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">hello, %s</span><span style="color: #800000">'</span> % (name)</pre>
</div>

<p>甚至可以嵌套多层：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">@before_call()
@after_call()
</span><span style="color: #0000ff">def</span><span style="color: #000000"> test(name):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">hello, %s</span><span style="color: #800000">'</span> % (name)</pre>
</div>



<p>&#160;</p>

<p>这就是python中装饰器的原理，内部采用了闭包。</p>]]></description></item><item><title>Python之闭包</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/27/4189211.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 27 Dec 2014 13:32:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/27/4189211.html</guid><description><![CDATA[<p>最近要使用python，研究下闭包特性。</p>  <p>&#160;</p>  <p>看下列的代码：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">def</span> counter(start_at =<span style="color: #000000"> 0):
    count </span>=<span style="color: #000000"> [start_at]
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> incr():
        count[0] </span>+= 1
        <span style="color: #0000ff">return</span><span style="color: #000000"> count[0]
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> incr

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    count </span>= counter(5<span style="color: #000000">)
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> count()
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> count()

    count2 </span>= counter(100<span style="color: #000000">)
    </span><span style="color: #0000ff">print</span><span style="color: #000000"> count2()
    </span><span style="color: #0000ff">print</span> count()</pre>
</div>

<p>&#160;</p>

<p>counter返回一个内部的函数，如果是别的语言，每次函数执行的结果应该是相同的，但是这里的运行结果是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>~/Documents/py python 1<span style="color: #000000">.py
</span>6
7
101
8</pre>
</div>

<p>显然，count和count2是两个相互独立的作用域。</p>

<p>&#160;</p>

<p>python的作用域有两种，一是全局作用域，一个是局部作用域。</p>

<p>但是下面的代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">def</span> counter(start_at =<span style="color: #000000"> 0):
    count </span>=<span style="color: #000000"> [start_at]
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> incr():
        count[0] </span>+= 1
        <span style="color: #0000ff">return</span><span style="color: #000000"> count[0]
    </span><span style="color: #0000ff">return</span> incr</pre>
</div>



<p>如果只看第一行，那么count这个变量，生成于counter被调用，当函数调用结束时，count便销毁。</p>

<p>但是这里借助嵌套的函数incr，<font color="#ff0000">延长了count的声明周期</font>。</p>

<p>这就形成了一种单独的作用域。</p>

<p>在上面的代码中，<font color="#ff0000">count和count2内部持有了一个count变量作为它的状态</font>，所以count每次调用的结果是不同的。</p>

<p>当我们调用一次counter函数时，就产生了一个闭包函数，例如count，他的内部持有一个状态count。</p>

<p>所以上面的四次调用，产生了两个闭包函数。</p>

<p>当count和count2销毁时，内部持有的闭包变量才会销毁。</p>]]></description></item><item><title>Struts2数据校验</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/24/4182516.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 24 Dec 2014 07:14:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/24/4182516.html</guid><description><![CDATA[<p>回到之前的LoginAction，我们只是简单的回显了数据，但我们的操作都是假设数据是正确的。但是假设我们在输入age的时候输入了字符串，服务器就会throw异常，而且age也无法接收到正确的值。</p>  <p>所以我们需要对数据进行校验。</p>  <p>&#160;</p>  <p>Struts2中的数据不合法分两种情况：</p>  <blockquote>   <p>一是Field级别的错误，例如给age输入字符串，还有Date不按格式输入</p> </blockquote>  <blockquote>   <p>二是Action级别的逻辑错误，例如username不能过长，两次password必须相同等。</p> </blockquote>  <p>下面以一个注册RegisterAction说明Struts2如何进行数据校验。</p>  <p>&#160;</p>  <p>我们先编写jsp页面。</p>  <p>register.jsp的内容如下：</p>  <p>&#160;</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="background-color: #ffff00; color: #000000">&lt;%</span><span style="background-color: #f5f5f5; color: #000000">@ page language</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">java</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> import</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">java.util.*</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> pageEncoding</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">UTF-8</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #ffff00; color: #000000">%&gt;</span>
<span style="background-color: #ffff00; color: #000000">&lt;%</span><span style="background-color: #f5f5f5; color: #000000">@ taglib prefix</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">s</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> uri</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">/struts-tags</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span> <span style="background-color: #ffff00; color: #000000">%&gt;</span>
<span style="background-color: #ffff00; color: #000000">&lt;%</span>
<span style="background-color: #f5f5f5; color: #0000ff">String</span><span style="background-color: #f5f5f5; color: #000000"> path </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> request.getContextPath();
</span><span style="background-color: #f5f5f5; color: #0000ff">String</span><span style="background-color: #f5f5f5; color: #000000"> basePath </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> request.getScheme()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">://</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">request.getServerName()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">:</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">request.getServerPort()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">path</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">/</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">;
</span><span style="background-color: #ffff00; color: #000000">%&gt;</span>

<span style="color: #0000ff">&lt;!</span><span style="color: #ff00ff">DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span>
  <span style="color: #0000ff">&lt;</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">base </span><span style="color: #ff0000">href</span><span style="color: #0000ff">=&quot;&lt;%=basePath%&gt;&quot;</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>用户注册<span style="color: #0000ff">&lt;/</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>

  <span style="color: #0000ff">&lt;/</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
  
  <span style="color: #0000ff">&lt;</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
      <span style="color: #0000ff">&lt;</span><span style="color: #800000">h2</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">font </span><span style="color: #ff0000">color</span><span style="color: #0000ff">=&quot;blue&quot;</span><span style="color: #0000ff">&gt;</span>用户注册<span style="color: #0000ff">&lt;/</span><span style="color: #800000">font</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">h2</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">s:actionerror </span><span style="color: #ff0000">cssStyle</span><span style="color: #0000ff">=&quot;color:red&quot;</span><span style="color: #0000ff">/&gt;</span><span style="color: #000000">
    ----------------------------------------
    </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:fielderror </span><span style="color: #ff0000">cssStyle</span><span style="color: #0000ff">=&quot;color:blue&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:fielderror</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    ----------------------------------------
    </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:form </span><span style="color: #ff0000">action</span><span style="color: #0000ff">=&quot;registerAction&quot;</span><span style="color: #ff0000"> theme</span><span style="color: #0000ff">=&quot;simple&quot;</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        username: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:textfield </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;username&quot;</span><span style="color: #ff0000"> label</span><span style="color: #0000ff">=&quot;username&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:textfield</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        password: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:password </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;password&quot;</span><span style="color: #ff0000"> label</span><span style="color: #0000ff">=&quot;password&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:password</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        repassword: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:password </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;repassword&quot;</span><span style="color: #ff0000"> label</span><span style="color: #0000ff">=&quot;repassword&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:password</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        age: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:textfield </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;age&quot;</span><span style="color: #ff0000"> label</span><span style="color: #0000ff">=&quot;age&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:textfield</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        birthday: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:textfield </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;birthday&quot;</span><span style="color: #ff0000"> label</span><span style="color: #0000ff">=&quot;birthday&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:textfield</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        graduation: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:textfield </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;graduation&quot;</span><span style="color: #ff0000"> label</span><span style="color: #0000ff">=&quot;graduation&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:textfield</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">s:submit </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">s:submit</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">s:form</span><span style="color: #0000ff">&gt;</span>
  <span style="color: #0000ff">&lt;/</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>register_result.jsp内容如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="background-color: #ffff00; color: #000000">&lt;%</span><span style="background-color: #f5f5f5; color: #000000">@ page language</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">java</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> import</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">java.util.*</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> pageEncoding</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">UTF-8</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #ffff00; color: #000000">%&gt;</span>
<span style="background-color: #ffff00; color: #000000">&lt;%</span><span style="background-color: #f5f5f5; color: #000000">@ taglib prefix</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">s</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> uri</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">/struts-tags</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span> <span style="background-color: #ffff00; color: #000000">%&gt;</span>
<span style="background-color: #ffff00; color: #000000">&lt;%</span>
<span style="background-color: #f5f5f5; color: #0000ff">String</span><span style="background-color: #f5f5f5; color: #000000"> path </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> request.getContextPath();
</span><span style="background-color: #f5f5f5; color: #0000ff">String</span><span style="background-color: #f5f5f5; color: #000000"> basePath </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> request.getScheme()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">://</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">request.getServerName()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">:</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">request.getServerPort()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">path</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">/</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">;
</span><span style="background-color: #ffff00; color: #000000">%&gt;</span>

<span style="color: #0000ff">&lt;!</span><span style="color: #ff00ff">DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span>
  <span style="color: #0000ff">&lt;</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">base </span><span style="color: #ff0000">href</span><span style="color: #0000ff">=&quot;&lt;%=basePath%&gt;&quot;</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>用户注册结果<span style="color: #0000ff">&lt;/</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>

  <span style="color: #0000ff">&lt;/</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
  
  <span style="color: #0000ff">&lt;</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
  
    username: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:property </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;username&quot;</span><span style="color: #0000ff">/&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    password: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:property </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;password&quot;</span><span style="color: #0000ff">/&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    age:</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:property </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;age&quot;</span><span style="color: #0000ff">/&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    birthday:</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:property </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;birthday&quot;</span><span style="color: #0000ff">/&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    graduate:</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:property </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;graduation&quot;</span><span style="color: #0000ff">/&gt;</span>
  <span style="color: #0000ff">&lt;/</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span></pre>
</div>



<p>&#160;</p>

<p>然后我们编写核心的RegisterAction，</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.action;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.Date;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.opensymphony.xwork2.ActionSupport;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> RegisterAction <span style="color: #0000ff">extends</span><span style="color: #000000"> ActionSupport
{
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String username;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String password;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String repassword;
    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span><span style="color: #000000"> age;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> Date birthday;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> Date graduation;

    </span><span style="color: #008000">//</span><span style="color: #008000">get 和 set方法</span>
<span style="color: #000000">
    

    @Override
    </span><span style="color: #0000ff">public</span> String execute() <span style="color: #0000ff">throws</span><span style="color: #000000"> Exception
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> SUCCESS;
    }
}</span></pre>
</div>



<p>&#160;</p>

<p>这跟以前我们编写的步骤完全相同，但是这里我们需要进行数据校验。所以我们添加一个validate方法，这个也是对基类的重写。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">@Override
    </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span><span style="color: #000000"> validate()
    {
        </span><span style="color: #0000ff">if</span> (username == <span style="color: #0000ff">null</span> || username.length() &lt; 4 || username.length() &gt; 8<span style="color: #000000">)
        {
            </span><span style="color: #0000ff">this</span>.addActionError(&quot;username invalid!.&quot;<span style="color: #000000">);
        }

        </span><span style="color: #0000ff">if</span> (password == <span style="color: #0000ff">null</span> || password.length() &lt; 4 || password.length() &gt; 8<span style="color: #000000">)
        {
            </span><span style="color: #0000ff">this</span>.addActionError(&quot;password invalid!!&quot;<span style="color: #000000">);
        }
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (!<span style="color: #000000">password.equals(repassword))
        {
            </span><span style="color: #0000ff">this</span>.addActionError(&quot;the passwords not the same&quot;<span style="color: #000000">);
        }

        </span><span style="color: #0000ff">if</span> (!<span style="color: #000000">birthday.before(graduation))
        {
            </span><span style="color: #0000ff">this</span>.addActionError(&quot;birthday must be earlier than graduation!!&quot;<span style="color: #000000">);
        }
        
        </span><span style="color: #0000ff">if</span>(birthday != <span style="color: #0000ff">null</span> &amp;&amp; graduation != <span style="color: #0000ff">null</span> &amp;&amp; !<span style="color: #000000">birthday.before(graduation))
        {
            </span><span style="color: #0000ff">this</span>.addActionError(&quot;birthday must be earlier than graduation!!&quot;<span style="color: #000000">);
        }
    }</span></pre>
</div>



<p>我们可以看上，上面就是对username等进行逻辑上的校验。</p>

<p>然后我们修改struts.xml，可以去查看结果。</p>

<p>&#160;</p>

<p>还有一种校验，是采用配置文件，我们将上面的validate注释掉，然后在action包下面，新建文件RegisterAction-validation.xml文件，内容为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;?</span><span style="color: #ff00ff">xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;</span><span style="color: #0000ff">?&gt;</span>

<span style="color: #0000ff">&lt;!</span><span style="color: #ff00ff">DOCTYPE validators PUBLIC &quot;-//OpenSymphony Group//XWork Validator 1.0.2//EN&quot; 
&quot;http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd&quot;</span><span style="color: #0000ff">&gt;</span>

<span style="color: #0000ff">&lt;</span><span style="color: #800000">validators</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">field </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;username&quot;</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;requiredstring&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>username can't be blank!<span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;stringlength&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;minLength&quot;</span><span style="color: #0000ff">&gt;</span>4<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;maxLength&quot;</span><span style="color: #0000ff">&gt;</span>8<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message </span><span style="color: #ff0000">key</span><span style="color: #0000ff">=&quot;username.invalid&quot;</span><span style="color: #0000ff">&gt;&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">field </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;password&quot;</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;requiredstring&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>password can't be blank!<span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;stringlength&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;minLength&quot;</span><span style="color: #0000ff">&gt;</span>4<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;maxLength&quot;</span><span style="color: #0000ff">&gt;</span>8<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
                length of password should be between ${minLength} and ${maxLength}
            </span><span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">field </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;age&quot;</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;required&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>age can't be blank!<span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;int&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;min&quot;</span><span style="color: #0000ff">&gt;</span>10<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;max&quot;</span><span style="color: #0000ff">&gt;</span>40<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>age should be between ${min} and ${max}<span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
        
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">field </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;birthday&quot;</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;required&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>birthday can't be blank!<span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">field-validator </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;date&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;min&quot;</span><span style="color: #0000ff">&gt;</span>2005-1-1<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">param </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;max&quot;</span><span style="color: #0000ff">&gt;</span>2007-12-31<span style="color: #0000ff">&lt;/</span><span style="color: #800000">param</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>birthday should be between ${min} and ${max}<span style="color: #0000ff">&lt;/</span><span style="color: #800000">message</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field-validator</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">field</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">validators</span><span style="color: #0000ff">&gt;</span></pre>
</div>



<p>起到的作用是相同的，当然，这种方式相对于第一种比较死板。</p>

<p>&#160;</p>

<p>上面的校验都是Action级别的错误。如果是Field级别的错误，系统默认信息是XXX invalid，我们可以配置信息，显示更具体一些：</p>

<p>在action下新建文件RegisterAction.properties。内容如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">invalid.fieldvalue.age \u5E74\u9F84\u5FC5\u987B\u4E3A\u6574\u6570
invalid.fieldvalue.birthday=\u751F\u65E5\u4E0D\u5408\u6CD5
invalid.fieldvalue.graduation=\u6BD5\u4E1A\u65E5\u671F\u4E0D\u5408\u6CD5</span></pre>
</div>


这里的信息是中文。此时我们在age中输入字符串时，显示的就是中文错误提示。]]></description></item><item><title>Struts2数据类型转换之批量数据转换</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/24/4182446.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 24 Dec 2014 06:52:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/24/4182446.html</guid><description><![CDATA[<p>前面我们实现了从字符串到User对象的转换。如果表单中有多个User数据，我们可以批量转换。</p>  <p>我们把input.jsp修改为：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">h1</span><span style="color: #0000ff">&gt;</span>使用分号隔开username password<span style="color: #0000ff">&lt;/</span><span style="color: #800000">h1</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">form </span><span style="color: #ff0000">action</span><span style="color: #0000ff">=&quot;userAction2.action&quot;</span><span style="color: #0000ff">&gt;</span>
    
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        
        
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">form</span><span style="color: #0000ff">&gt;</span></pre>
</div>



<p>然后新建action，UserAction2：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.action;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.List;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.opensymphony.xwork2.ActionSupport;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> UserAction2 <span style="color: #0000ff">extends</span><span style="color: #000000"> ActionSupport
{
    </span><span style="color: #0000ff">private</span> List&lt;String&gt;<span style="color: #000000"> user;

    </span><span style="color: #0000ff">public</span> List&lt;String&gt;<span style="color: #000000"> getUser()
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> user;
    }

    </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> setUser(List&lt;String&gt;<span style="color: #000000"> user)
    {
        </span><span style="color: #0000ff">this</span>.user =<span style="color: #000000"> user;
    }
    
    @Override
    </span><span style="color: #0000ff">public</span> String execute() <span style="color: #0000ff">throws</span><span style="color: #000000"> Exception
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> SUCCESS;
    }
}</span></pre>
</div>

<p>&#160;</p>

<p>下面我们就要进行转换，此时我们需要的是将表单上一堆字符串，转化成一个String集合。</p>

<p>编写转换器，UserConverter3：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.converter;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.ArrayList;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.List;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.Map;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.StringTokenizer;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> org.apache.struts2.util.StrutsTypeConverter;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.test.bean.User;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> UserConverter3 <span style="color: #0000ff">extends</span><span style="color: #000000"> StrutsTypeConverter
{
    @Override
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> Object convertFromString(Map context, String[] values, Class toClass)
    {
        List</span>&lt;User&gt; users = <span style="color: #0000ff">new</span> ArrayList&lt;User&gt;<span style="color: #000000">();
        
        </span><span style="color: #0000ff">for</span><span style="color: #000000">(String value : values)
        {
            StringTokenizer st </span>= <span style="color: #0000ff">new</span> StringTokenizer(value, &quot;;&quot;<span style="color: #000000">);
            String username </span>=<span style="color: #000000"> st.nextToken();
            String password </span>=<span style="color: #000000"> st.nextToken();
            
            User user </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> User();
            user.setUsername(username);
            user.setPassword(password);
            
            users.add(user);
        }
        
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> users;
    }
    
    @Override
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> String convertToString(Map context, Object o)
    {
        @SuppressWarnings(</span>&quot;unchecked&quot;<span style="color: #000000">)
        List</span>&lt;User&gt; list = (List&lt;User&gt;<span style="color: #000000">)o;
        
        StringBuffer sbuf </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> StringBuffer();
        
        </span><span style="color: #0000ff">for</span><span style="color: #000000">(User user : list)
        {
            sbuf.append(</span>&quot;username: &quot; + user.getUsername() + &quot;, password: &quot; + user.getPassword() + &quot;\n&quot;<span style="color: #000000">);
        }
        
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> sbuf.toString();
    }
}</span></pre>
</div>



<p>然后建立类型转换的配置文件和修改struts.xml。</p>

<p>启动服务器，是可以正常工作的。</p>]]></description></item><item><title>Struts2数据类型转换之自定义数据类型转换（二）</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/20/4175963.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 20 Dec 2014 14:22:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/20/4175963.html</guid><description><![CDATA[<p>对于自定义的类型转换器来说，需要提供三个信息：</p> <blockquote> <p>Action的名字、Action中带转换的属性名、该属性对应的转换器类</p></blockquote> <p>其中，action的名字是通过属性文件名来获取的，action中待转换的属性名是通过文件中的key获得的，该属性对应的转换器类是通过该key对应的value获取的。</p> <p>例如上节中的UserAction-converter.properties，其文件内容为：</p> <blockquote><pre>user=com.test.converter.UserConverter</pre></blockquote><pre>这就告诉我们，<font color="#ff0000">对于UserAction这个action，我们可以使用</font></pre><pre><font color="#ff0000">com.test.converter.UserConverter这个类完成user这个属性的转换工作</font>。</pre><pre>&nbsp;</pre><pre>上节中我们的转换器类使用的是ognl提供的DefaultTypeConverter类，现在我们采用Struts提供的StrutsTypeConverter来简化代码的编写。</pre><pre>&nbsp;</pre><pre>StrutsTypeConverter继承自DefaultTypeConverter，并且<font color="#ff0000">提供了两个抽象方法：converterFromString与convertToString</font>，分别表示从页面的String转化为后台对象，以及从后台对象转化为页面的字符串。</pre><pre>&nbsp;</pre><pre>我们只需要实现这两个抽象方法即可。</pre><pre>我们新建一个类，UserConverter2：</pre>
<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code"><pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.converter;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.Map;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.StringTokenizer;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> org.apache.struts2.util.StrutsTypeConverter;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.test.bean.User;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> UserConverter2 <span style="color: #0000ff">extends</span><span style="color: #000000"> StrutsTypeConverter
{
    @Override
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> Object convertFromString(Map context, String[] values, Class toClass)
    {
        User user </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> User();

        String str </span>= values[0<span style="color: #000000">];

        StringTokenizer st </span>= <span style="color: #0000ff">new</span> StringTokenizer(str, ";"<span style="color: #000000">);
        String username </span>=<span style="color: #000000"> st.nextToken();
        String password </span>=<span style="color: #000000"> st.nextToken();

        user.setUsername(username);
        user.setPassword(password);

        </span><span style="color: #0000ff">return</span><span style="color: #000000"> user;
    }

    @Override
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> String convertToString(Map context, Object o)
    {
        User user </span>=<span style="color: #000000"> (User) o;

        String username </span>=<span style="color: #000000"> user.getUsername();
        String password </span>=<span style="color: #000000"> user.getPassword();
        String userInfo </span>= "username: " + username + ", password: " +<span style="color: #000000"> password;

        </span><span style="color: #0000ff">return</span><span style="color: #000000"> userInfo;
    }
}</span></pre></div>
<p>然后在UserAction-converter.properties将原来的内容注释掉，修改为：</p>
<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code"><pre>user=com.test.converter.UserConverter2</pre></div>

<p>&nbsp;</p>
<p>重新打开页面，发现仍然可以正常工作。</p>
<p>&nbsp;</p>
<p>如果在项目中大量使用User类，我们可以写一个全局的配置文件。在src下新建xwork-conversion.properties，内容为：</p>
<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code"><pre>com.test.bean.User=com.test.converter.UserConverter2</pre></div>
这意味着，凡是需要转换User类型的属性，如果我们没有像上面那样针对某个Action写配置，那么就采用默认的UserConverter2类去实现转换。]]></description></item><item><title>Struts2数据类型转换之自定义数据类型转换</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/20/4175846.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 20 Dec 2014 13:02:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/20/4175846.html</guid><description><![CDATA[<p>前面提到，对于Java内置的int String和Date等，struts可以帮助我们完成数据的转化，但是对于自定义类型，必须手动实现转化方法。</p>  <p>下面我们自己实现一个User对象的转换。</p>  <p>&#160;</p>  <p>1.首先我们自定义一个Java bean。建一个package com.test.bean，新建class为User：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.bean;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span><span style="color: #000000"> User
{
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String username;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String password;
    
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> String getUsername()
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> username;
    }
    </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span><span style="color: #000000"> setUsername(String username)
    {
        </span><span style="color: #0000ff">this</span>.username =<span style="color: #000000"> username;
    }
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> String getPassword()
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> password;
    }
    </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span><span style="color: #000000"> setPassword(String password)
    {
        </span><span style="color: #0000ff">this</span>.password =<span style="color: #000000"> password;
    }

}</span></pre>
</div>

<p>2.建立一个input.jsp 和一个output.jsp</p>

<p>input的内容为一个表单：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">h1</span><span style="color: #0000ff">&gt;</span>使用分号隔开username password<span style="color: #0000ff">&lt;/</span><span style="color: #800000">h1</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">form </span><span style="color: #ff0000">action</span><span style="color: #0000ff">=&quot;userAction.action&quot;</span><span style="color: #0000ff">&gt;</span>
    
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">form</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>output的内容为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">s:property </span><span style="color: #ff0000">value</span><span style="color: #0000ff">=&quot;user&quot;</span><span style="color: #0000ff">/&gt;</span></pre>
</div>

<p>这里使用了struts自定义的标签，所以顶部第二行加上：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="background-color: #ffff00; color: #000000">&lt;%</span><span style="background-color: #f5f5f5; color: #000000">@ taglib prefix</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">s</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> uri</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">/struts-tags</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span> <span style="background-color: #ffff00; color: #000000">%&gt;</span></pre>
</div>

<p>3.在struts.xml中配置一个路由表：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">action </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;userAction&quot;</span><span style="color: #ff0000"> class</span><span style="color: #0000ff">=&quot;com.test.action.UserAction&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">result </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;success&quot;</span><span style="color: #0000ff">&gt;</span>/output.jsp<span style="color: #0000ff">&lt;/</span><span style="color: #800000">result</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">action</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>4.编写一个UserAction：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.action;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.opensymphony.xwork2.ActionSupport;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.test.bean.User;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> UserAction <span style="color: #0000ff">extends</span><span style="color: #000000"> ActionSupport
{
    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">final</span> <span style="color: #0000ff">long</span> serialVersionUID = 1L<span style="color: #000000">;
    
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> User user;
    
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> User getUser()
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> user;
    }

    </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span><span style="color: #000000"> setUser(User user)
    {
        </span><span style="color: #0000ff">this</span>.user =<span style="color: #000000"> user;
    }


    @Override
    </span><span style="color: #0000ff">public</span> String execute() <span style="color: #0000ff">throws</span><span style="color: #000000"> Exception
    {
        System.out.println(</span>&quot;username : &quot; +<span style="color: #000000"> user.getUsername());
        System.out.println(</span>&quot;password : &quot; +<span style="color: #000000"> user.getPassword());

        </span><span style="color: #0000ff">return</span><span style="color: #000000"> SUCCESS;
    }
}</span></pre>
</div>

<p>5.下面就开始真正的转换：</p>

<p>新建一个package com.test.converter 新建类UserConverter</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.converter;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.Map;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.StringTokenizer;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> ognl.DefaultTypeConverter;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.test.bean.User;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> UserConverter <span style="color: #0000ff">extends</span><span style="color: #000000"> DefaultTypeConverter
{
    @Override
    </span><span style="color: #0000ff">public</span><span style="color: #000000"> Object convertValue(Map context, Object value, Class toType)
    {
        </span><span style="color: #0000ff">if</span> (User.<span style="color: #0000ff">class</span> == toType) <span style="color: #008000">//</span><span style="color: #008000"> 把网页上的字符串转化为User对象</span>
<span style="color: #000000">        {
            String[] str </span>=<span style="color: #000000"> (String[]) value;
            String firstValue </span>= str[0<span style="color: #000000">];

            StringTokenizer st </span>= <span style="color: #0000ff">new</span> StringTokenizer(firstValue, &quot;;&quot;<span style="color: #000000">);

            String username </span>=<span style="color: #000000"> st.nextToken();
            String password </span>=<span style="color: #000000"> st.nextToken();

            User user </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> User();
            user.setUsername(username);
            user.setPassword(password);

            </span><span style="color: #0000ff">return</span><span style="color: #000000"> user;
        }
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (String.<span style="color: #0000ff">class</span> == toType)<span style="color: #008000">//</span><span style="color: #008000"> 将User对象转化为字符串</span>
<span style="color: #000000">        {
            User user </span>=<span style="color: #000000"> (User) value;

            String username </span>=<span style="color: #000000"> user.getUsername();
            String password </span>=<span style="color: #000000"> user.getPassword();

            String userInfo </span>= &quot;username: &quot; + username + &quot;, password: &quot;
                    +<span style="color: #000000"> password;

            </span><span style="color: #0000ff">return</span><span style="color: #000000"> userInfo;
        }

        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">null</span><span style="color: #000000">;
    }
}</span></pre>
</div>

<p>可以看到，我们的转化器类继承了ognl提供的DefaultTypeConverter类。</p>

<p>6.在package converter下面，新建一个文件，名字为UserAction-converter.properties</p>

<p>内容只有一行：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>user=com.test.converter.UserConverter</pre>
</div>

<p><strong><font color="#ff0000">它的意思是，如果要转化UserAction中的成员变量user，应该使用com.test.converter.UserConverter这个类</font></strong>。</p>

<p><font color="#ff0000">注意这个文件的命名规则和大小写</font>。</p>

<p>&#160;</p>

<p>打开浏览器，输入
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre>http://localhost:8080/struts2/input.jsp</pre>
  </div>
</p>

















<p>输入：</p>

<blockquote>
  <p>hello;world</p>
</blockquote>

<p>可以看到：</p>

<blockquote>
  <p>username: hello, password: world </p>
</blockquote>

<p>下面我们分析一下流程：</p>

<p>当我们在jsp页面中输入hello;world时，后台server根据我们的配置文件交给UserAction去处理，但是这个User不是内置类型，所以他通过UserAction-converter.properties这个配置文件，找到UserConverter这个类，将字符串转化为一个User对象。</p>

<p>&#160;</p>

<p>下文采用struts2提供的转化器，简化流程。</p>]]></description></item><item><title>Struts2之简单数据类型转换</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/20/4174949.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 19 Dec 2014 16:38:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/20/4174949.html</guid><description><![CDATA[<p>如果我们在网页表单上填写数字，那么在后台我们是否需要手工把字符串转化为数字呢？</p>  <p>&#160;</p>  <p>我们编写以下的程序：</p>  <p>1.创建文件login.jsp，核心内容如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">form </span><span style="color: #ff0000">action</span><span style="color: #0000ff">=&quot;login.action&quot;</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        username: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;username&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        password: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;password&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;password&quot;</span><span style="color: #0000ff">&gt;&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        age: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;age&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
        date: </span><span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;text&quot;</span><span style="color: #ff0000"> name</span><span style="color: #0000ff">=&quot;date&quot;</span><span style="color: #0000ff">&gt;</span> <span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">input </span><span style="color: #ff0000">type</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #ff0000"> value</span><span style="color: #0000ff">=&quot;submit&quot;</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">form</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>2.创建文件login_result.jsp核心内容如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>username: ${requestScope.username}<span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    password: ${requestScope.password }</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    age: ${requestScope.age }</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span><span style="color: #000000">
    date: ${requestScope.date }</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">br</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>打印出四个变量的内容。</p>

<p>3.在struts.xml配置如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">action </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;login&quot;</span><span style="color: #ff0000"> class</span><span style="color: #0000ff">=&quot;com.test.action.LoginAction&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">result </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;success&quot;</span><span style="color: #0000ff">&gt;</span>/login_result.jsp<span style="color: #0000ff">&lt;/</span><span style="color: #800000">result</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">action</span><span style="color: #0000ff">&gt;</span></pre>
</div>

<p>4.最后我们编写LoginAction类。</p>

<p>因为表单上我们编写了四个内容，所以类中对应四个变量。</p>

<p>&#160;</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.action;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.Date;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span><span style="color: #000000"> LoginAction
{
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String username;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> String password;
    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span><span style="color: #000000"> age;
    </span><span style="color: #0000ff">private</span><span style="color: #000000"> Date date;
    
    </span><span style="color: #008000">//</span><span style="color: #008000">set and get method</span>
    
    <span style="color: #0000ff">public</span><span style="color: #000000"> String execute()
    {
        </span><span style="color: #0000ff">return</span> &quot;success&quot;<span style="color: #000000">;
    }
}</span></pre>
</div>

<p>然后我们重新部署程序，发现运行是正常的，说明struts2自动帮我们完成了转换，当然如果我们填写的数据不合法，例如age填写了字符串，那么会抛出异常。</p>

<p>&#160;</p>

<p>事实上，<font color="#ff0000">对于Java内置的数据类型，struts2会自动帮我们完整转化。但是对于我们自定义的类型，我们必须手工进行转化</font>。</p>]]></description></item><item><title>Struts2环境搭建以及helloworld编写</title><link>http://www.cnblogs.com/inevermore/archive/2014/12/20/4174926.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 19 Dec 2014 16:10:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/12/20/4174926.html</guid><description><![CDATA[<p>Struts是一个经典的Java Web开发框架。现在我们编写一个简易的helloworld界面。</p>  <p>&#160;</p>  <p>Struts的环境搭建比较简单，加载相应的jar包即可。</p>  <p>我这里的开发环境是windows7 + Myeclipse10.0</p>  <p>Struts2采用的是2.2.1.1版本</p>  <p>&#160;</p>  <p>1.加载Struts2的必备jar包，我这里是6个，还有另外的两个jar文件。</p>  <blockquote>   <p>这六个分别是：</p>    <p>1.commons_fileupload-1.2.1.jar</p>    <p>2.commons-io_1.3.2.jar</p>    <p>3.commons-logging-1.0.4.jar</p>    <p>4.ognl-3.0.jar</p>    <p>5.struts2-core-2.2.1.1.jar</p>    <p>6.xwork-core-2.2.1.1.jar</p> </blockquote>  <blockquote>   <p>此外，还需要freemarker-2.3.16.jar以及javassist-3.7.ga.jar文件</p> </blockquote>  <p>2.编辑web.xml文件</p>  <p>内容为：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">&lt;?</span><span style="color: #ff00ff">xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;</span><span style="color: #0000ff">?&gt;</span>
<span style="color: #0000ff">&lt;</span><span style="color: #800000">web-app </span><span style="color: #ff0000">version</span><span style="color: #0000ff">=&quot;2.5&quot;</span><span style="color: #ff0000"> xmlns</span><span style="color: #0000ff">=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><span style="color: #ff0000">
    xmlns:xsi</span><span style="color: #0000ff">=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><span style="color: #ff0000">
    xsi:schemaLocation</span><span style="color: #0000ff">=&quot;http://java.sun.com/xml/ns/javaee 
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><span style="color: #0000ff">&gt;</span>

    <span style="color: #0000ff">&lt;</span><span style="color: #800000">filter</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">filter-name</span><span style="color: #0000ff">&gt;</span>struts2<span style="color: #0000ff">&lt;/</span><span style="color: #800000">filter-name</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">filter-class</span><span style="color: #0000ff">&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span style="color: #0000ff">&lt;/</span><span style="color: #800000">filter-class</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">filter</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">filter-mapping</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">filter-name</span><span style="color: #0000ff">&gt;</span>struts2<span style="color: #0000ff">&lt;/</span><span style="color: #800000">filter-name</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">url-pattern</span><span style="color: #0000ff">&gt;</span>/*<span style="color: #0000ff">&lt;/</span><span style="color: #800000">url-pattern</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">filter-mapping</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">web-app</span><span style="color: #0000ff">&gt;</span></pre>
</div>



<p>这个xml文档不需要验证，即使上面的网址失效也无妨。</p>

<p>&#160;</p>

<p>3.在src目录下创建struts.xml文件，内容为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">&lt;?</span><span style="color: #ff00ff">xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;</span><span style="color: #0000ff">?&gt;</span>
<span style="color: #0000ff">&lt;!</span><span style="color: #ff00ff">DOCTYPE struts PUBLIC
&quot;-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN&quot;
&quot;http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;</span><span style="color: #0000ff">&gt;</span>

<span style="color: #0000ff">&lt;</span><span style="color: #800000">struts</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">package </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;struts2&quot;</span><span style="color: #ff0000"> extends</span><span style="color: #0000ff">=&quot;struts-default&quot;</span><span style="color: #0000ff">&gt;</span>
    
        <span style="color: #0000ff">&lt;</span><span style="color: #800000">action </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;helloworld&quot;</span><span style="color: #ff0000"> class</span><span style="color: #0000ff">=&quot;com.test.action.HelloWorldAction&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">result </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;success&quot;</span><span style="color: #0000ff">&gt;</span>/helloworld.jsp<span style="color: #0000ff">&lt;/</span><span style="color: #800000">result</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">action</span><span style="color: #0000ff">&gt;</span>
    
    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">package</span><span style="color: #0000ff">&gt;</span>
    
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">struts</span><span style="color: #0000ff">&gt;</span></pre>
</div>



<p>这个xml文档是最关键的配置部分。<font color="#ff0000">而且需要DTD验证，所以必须保证上面的dtd文件是可用</font>的。</p>

<p>&#160;</p>

<p>4.创建一个package为com.test.action，创建class为HelloWorldAction。</p>

<p>该class的定义为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.test.action;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> com.opensymphony.xwork2.ActionSupport;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> HelloWorldAction <span style="color: #0000ff">extends</span><span style="color: #000000"> ActionSupport
{
    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">final</span> <span style="color: #0000ff">long</span> serialVersionUID = 1L<span style="color: #000000">;

    @Override
    </span><span style="color: #0000ff">public</span> String execute() <span style="color: #0000ff">throws</span><span style="color: #000000"> Exception
    {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> SUCCESS;
    }
}</span></pre>
</div>

<p>这里比较简单，我们也可以不继承ActionSupport类，<font color="#ff0000">只要这个类具备execute函数即可</font>。</p>

<p>5.创建一个jsp文件，为helloworld.jsp</p>

<p>内容如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="background-color: #ffff00; color: #000000">&lt;%</span><span style="background-color: #f5f5f5; color: #000000">@ page language</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">java</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> import</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">java.util.*</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000"> pageEncoding</span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">UTF-8</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #ffff00; color: #000000">%&gt;</span>
<span style="background-color: #ffff00; color: #000000">&lt;%</span>
<span style="background-color: #f5f5f5; color: #0000ff">String</span><span style="background-color: #f5f5f5; color: #000000"> path </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> request.getContextPath();
</span><span style="background-color: #f5f5f5; color: #0000ff">String</span><span style="background-color: #f5f5f5; color: #000000"> basePath </span><span style="background-color: #f5f5f5; color: #000000">=</span><span style="background-color: #f5f5f5; color: #000000"> request.getScheme()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">://</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">request.getServerName()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">:</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">request.getServerPort()</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #000000">path</span><span style="background-color: #f5f5f5; color: #000000">+</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #800000">/</span><span style="background-color: #f5f5f5; color: #800000">&quot;</span><span style="background-color: #f5f5f5; color: #000000">;
</span><span style="background-color: #ffff00; color: #000000">%&gt;</span>

<span style="color: #0000ff">&lt;!</span><span style="color: #ff00ff">DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span>
  <span style="color: #0000ff">&lt;</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">base </span><span style="color: #ff0000">href</span><span style="color: #0000ff">=&quot;&lt;%=basePath%&gt;&quot;</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>我的第一个Struts界面<span style="color: #0000ff">&lt;/</span><span style="color: #800000">title</span><span style="color: #0000ff">&gt;</span>
  <span style="color: #0000ff">&lt;/</span><span style="color: #800000">head</span><span style="color: #0000ff">&gt;</span>
  
  <span style="color: #0000ff">&lt;</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
    <span style="color: #0000ff">&lt;</span><span style="color: #800000">h1</span><span style="color: #0000ff">&gt;</span>Hello World<span style="color: #0000ff">&lt;/</span><span style="color: #800000">h1</span><span style="color: #0000ff">&gt;</span>
  <span style="color: #0000ff">&lt;/</span><span style="color: #800000">body</span><span style="color: #0000ff">&gt;</span>
<span style="color: #0000ff">&lt;/</span><span style="color: #800000">html</span><span style="color: #0000ff">&gt;</span></pre>
</div>



<p>&#160;</p>

<p>现在我们把程序部署到tomcat上，然后启动server，在浏览器中访问：</p>

<blockquote>
  <p><a title="http://localhost:8080/struts2/helloworld" href="http://localhost:8080/struts2/helloworld">http://localhost:8080/struts2/helloworld</a> 注意我的项目名称是struts2</p>
</blockquote>

<p>就可以看到加粗后的helloworld。</p>

<p>&#160;</p>

<p>下面分析访问helloworld页面的流程。</p>

<p>1.首先web.xml中，我们为所有的url都配置了一个分配器，所以当我们输入上面的网址时，server接收到的是/helloworld。</p>

<p>2.到了关键的地方，我们看
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre><span style="color: #0000ff">&lt;</span><span style="color: #800000">action </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;helloworld&quot;</span><span style="color: #ff0000"> class</span><span style="color: #0000ff">=&quot;com.test.action.HelloWorldAction&quot;</span><span style="color: #0000ff">&gt;</span>
            <span style="color: #0000ff">&lt;</span><span style="color: #800000">result </span><span style="color: #ff0000">name</span><span style="color: #0000ff">=&quot;success&quot;</span><span style="color: #0000ff">&gt;</span>/helloworld.jsp<span style="color: #0000ff">&lt;/</span><span style="color: #800000">result</span><span style="color: #0000ff">&gt;</span>
        <span style="color: #0000ff">&lt;/</span><span style="color: #800000">action</span><span style="color: #0000ff">&gt;</span></pre>
  </div>
</p>

<p>他的意思是，<font color="#ff0000"><strong>对于helloworld，我们去执行HelloWorldAction这个类的execute方法。</strong></font></p>

<p><font color="#ff0000"><strong>如果返回结果为success，那么执行helloworld.jsp页面</strong></font>。</p>

<p>于是我们在浏览器中就看到了helloworld页面。</p>]]></description></item><item><title>模板：什么是Traits</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/26/4122278.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Tue, 25 Nov 2014 16:17:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/26/4122278.html</guid><description><![CDATA[<p>Traits不是一种语法特性，而是一种模板编程技巧。Traits在C++标准库，尤其是STL中，有着不可替代的作用。</p>  <p>&#160;</p>  <p><font size="4"><strong>如何在编译期间区分类型</strong></font></p>  <p>&#160;</p>  <p>下面我们看一个实例，有四个类，Farm、Worker、Teacher和Doctor，我们需要区分他们是脑力劳动者还是体力劳动者。以便于做出不同的行动。</p>  <p>这里的问题在于，我们需要<strong><font color="#ff0000">为两种类型提供一个统一的接口，但是对于不同的类型，必须做出不同的实现</font></strong>。</p>  <p>我们不希望写两个函数，然后让用户去区分。</p>  <p>于是我们借助了函数重载，在每个类的内部内置一个work_type，然后根据每个类的word_type，借助强大的函数重载机制，实现了编译期的类型区分，也就是编译期多态。</p>  <p>代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;iostream&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #008000">//</span><span style="color: #008000">两个标签类</span>
<span style="color: #0000ff">struct</span> brain_worker {}; <span style="color: #008000">//</span><span style="color: #008000">脑力劳动</span>
<span style="color: #0000ff">struct</span> physical_worker {}; <span style="color: #008000">//</span><span style="color: #008000">体力劳动</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Worker
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef physical_worker worker_type;
};

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Farmer
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef physical_worker worker_type;
};

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Teacher
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Doctor
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> __distinction(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">t, brain_worker)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">脑力劳动者</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> __distinction(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">t, physical_worker)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">体力劳动者</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> distinction(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">t)
{
    typename T::worker_type _type; </span><span style="color: #008000">//</span><span style="color: #008000">为了实现重载</span>
<span style="color: #000000">    __distinction(t, _type);
}

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    Worker w;
    distinction(w);
    Farmer f;
    distinction(f);
    Teacher t;
    distinction(t);
    Doctor d;
    distinction(d);
    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>在distinction函数中，我们先从类型中提取出worker_type，然后根据它的类型，选取不同的实现。</p>

<p>&#160;</p>

<p>问题来了，如果不在类中内置worker_type，或者有的类已经写好了，无法更改了，那么怎么办？</p>

<p>&#160;</p>

<p><font color="#000000" size="4"><strong>使用Traits</strong></font></p>

<p>&#160;</p>

<p>我们的解决方案是，借助一种叫做traits的技巧。</p>

<p>我们写一个模板类，但是不提供任何实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">类型traits </span>
template &lt;typename T&gt;
<span style="color: #0000ff">class</span> TypeTraits;</pre>
</div>

<p>然后我们<font color="#ff0000">为每个类型提供一个模板特化</font>：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">为每个类型提供一个特化版本</span>
template &lt;&gt;
<span style="color: #0000ff">class</span> TypeTraits&lt;Worker&gt;<span style="color: #000000">
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef physical_worker worker_type;
};

template </span>&lt;&gt;
<span style="color: #0000ff">class</span> TypeTraits&lt;Farmer&gt;<span style="color: #000000">
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef physical_worker worker_type;
};

template </span>&lt;&gt;
<span style="color: #0000ff">class</span> TypeTraits&lt;Teacher&gt;<span style="color: #000000">
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};

template </span>&lt;&gt;
<span style="color: #0000ff">class</span> TypeTraits&lt;Doctor&gt;<span style="color: #000000">
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};</span></pre>
</div>



<p>然后在distinction函数中，<font color="#ff0000">不再是直接寻找内置类型，而是通过traits抽取出来</font>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>template &lt;typename T&gt;
<span style="color: #0000ff">void</span> distinction(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">t)
{
    </span><span style="color: #008000">//</span><span style="color: #008000">typename T::worker_type _type;</span>
    typename TypeTraits&lt;T&gt;<span style="color: #000000">::worker_type _type;
    __distinction(t, _type);
}</span></pre>
</div>

<p>&#160;</p>

<p>上面两种方式的<font color="#ff0000">本质区别在于，第一种是在class的内部内置type，第二种则是在类的外部，使用模板特化，class本身对于type并不知情。</font></p>

<p>&#160;</p>

<p><font size="4"><strong>两种方式结合</strong></font></p>

<p>&#160;</p>

<p>上面我们实现了目的，类中没有work_type时，也可以正常运行，但是模板特化相对于内置类型，还是麻烦了一些。</p>

<p>于是，我们仍然使用内置类型，也仍然使用traits抽取work_type，方法就是<font color="#ff0000">为TypeTraits提供一个默认实现，默认去使用内置类型，</font><font color="#000000">把二者结合起来。</font></p>

<p>这样我们去使用TypeTraits&lt;T&gt;::worker_type时，<font color="#ff0000">有内置类型的就使用默认实现，无内置类型的就需要提供特化版本</font>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Worker
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef physical_worker worker_type;
};

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Farmer
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef physical_worker worker_type;
};

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Teacher
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Doctor
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};


</span><span style="color: #008000">//</span><span style="color: #008000">类型traits </span>
template &lt;typename T&gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> TypeTraits
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef typename T::worker_type worker_type;
};</span></pre>
</div>

<p>OK，我们现在想添加一个新的class，于是我们有两种选择，</p>

<blockquote>
  <p>一是在class的内部内置work_type，通过traits的默认实现去抽取type。</p>
</blockquote>

<blockquote>
  <p>一种是不内置work_type，而是通过<font color="#ff0000">模板的特化</font>，提供work_type。</p>
</blockquote>

<p>例如：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Staff
{
};

template </span>&lt;&gt;
<span style="color: #0000ff">class</span> TypeTraits&lt;Staff&gt;<span style="color: #000000">
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef brain_worker worker_type;
};</span></pre>
</div>

<p>测试仍然正常：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">Staff s;
distinction(s);</span></pre>
</div>



<p>&#160;</p>

<p>&#160;</p>

<p><font size="4"><strong>进一步简化</strong></font></p>

<p>&#160;</p>

<p>这里我们考虑的是内置的情形。对于那些要内置type的类，如果type个数过多，程序编写就容易出现问题，我们考虑使用继承，先定义一个base类：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>template &lt;typename T&gt;
<span style="color: #0000ff">struct</span><span style="color: #000000"> type_base
{
    typedef T worker_type;
};</span></pre>
</div>

<p>所有的类型，<font color="#ff0000">通过public继承这个类即可</font>：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span> Worker : <span style="color: #0000ff">public</span> type_base&lt;physical_worker&gt;<span style="color: #000000">
{
};

</span><span style="color: #0000ff">class</span> Farmer : <span style="color: #0000ff">public</span> type_base&lt;physical_worker&gt;<span style="color: #000000">
{
};

</span><span style="color: #0000ff">class</span> Teacher : <span style="color: #0000ff">public</span> type_base&lt;brain_worker&gt;<span style="color: #000000">
{
};

</span><span style="color: #0000ff">class</span> Doctor : <span style="color: #0000ff">public</span> type_base&lt;brain_worker&gt;<span style="color: #000000">
{
};</span></pre>
</div>

<p>&#160;</p>

<p>看到这里，我们应该明白，traits相对于简单内置类型的做法，<font color="#ff0000">强大之处在于：如果一个类型无法内置type，那么就可以借助函数特化，从而借助于traits</font>。而内置类型仅仅使用于class类型。</p>

<p>&#160;</p>

<p>以STL中的迭代器为例，很多情况下我们需要辨别迭代器的类型，</p>

<p>例如distance函数计算两个迭代器的距离，有的迭代器具有随机访问能力，如vector，有的则不能，如list，我们计算两个迭代器的距离，就需要先判断迭代器能否相减，因为只有具备随机访问能力的迭代器才具有这个能力。</p>

<p>我们可以使用内置类型来解决。</p>

<p>可是，许多迭代器是使用指针实现的，指针不是class，无法内置类型，于是，STL采用了traits来辨别迭代器的类型。</p>

<p>&#160;</p>

<p>最后，我们应该认识到，<font color="#ff0000"><strong>traits的基石是模板特化</strong></font>。</p>

<p>&#160;</p>

<p>下篇文章，我们使用traits，来辨别一个类型是否是pod类型。</p>]]></description></item><item><title>getopt函数的用法</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/25/4121981.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Tue, 25 Nov 2014 13:31:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/25/4121981.html</guid><description><![CDATA[<p>Linux提供了一个解析命令行参数的函数。</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;unistd.h&gt;

       <span style="color: #0000ff">int</span> getopt(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> * <span style="color: #0000ff">const</span><span style="color: #000000"> argv[],
                  </span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">optstring);

       </span><span style="color: #0000ff">extern</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">optarg;
       </span><span style="color: #0000ff">extern</span> <span style="color: #0000ff">int</span> optind, opterr, optopt;</pre>
</div>

<p>使用这个函数，我们可以这样运行命令</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>./a.<span style="color: #0000ff">out</span> -n -t <span style="color: #800080">100</span></pre>
</div>

<p>n后面不需要参数，t需要一个数值作为参数。</p>

<p>代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include &lt;stdio.h&gt;<span style="color: #000000">
#include </span>&lt;stdlib.h&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>.h&gt;<span style="color: #000000">
#include </span>&lt;unistd.h&gt;<span style="color: #000000">
#include </span>&lt;errno.h&gt;
<span style="color: #0000ff">#define</span> ERR_EXIT(m) \
    <span style="color: #0000ff">do</span><span style="color: #000000"> { \
        perror(m);\
        exit(EXIT_FAILURE);\
    }</span><span style="color: #0000ff">while</span>(<span style="color: #800080">0</span><span style="color: #000000">)


</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> opt;
    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        opt </span>= getopt(argc, argv, <span style="color: #800000">&quot;</span><span style="color: #800000">nt:</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">if</span>(opt == <span style="color: #800000">'</span><span style="color: #800000">?</span><span style="color: #800000">'</span><span style="color: #000000">)
            exit(EXIT_FAILURE);
        </span><span style="color: #0000ff">if</span>(opt == -<span style="color: #800080">1</span><span style="color: #000000">)
            </span><span style="color: #0000ff">break</span><span style="color: #000000">;

        </span><span style="color: #0000ff">switch</span><span style="color: #000000">(opt)
        {
            </span><span style="color: #0000ff">case</span> <span style="color: #800000">'</span><span style="color: #800000">n</span><span style="color: #800000">'</span><span style="color: #000000">:
                printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">AAAAAAAA\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                </span><span style="color: #0000ff">break</span><span style="color: #000000">;
            </span><span style="color: #0000ff">case</span> <span style="color: #800000">'</span><span style="color: #800000">t</span><span style="color: #800000">'</span><span style="color: #000000">:
                printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">BBBBBBBB\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                </span><span style="color: #0000ff">int</span> n =<span style="color: #000000"> atoi(optarg);
                printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">n = %d\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, n);
        }
    }
    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>当输入非法参数时，getopt返回’?’，当解析完毕时，返回-1.</p>

<p>如果需要参数，那么使用optarg获取，这是一个全局变量。</p>

<p>注意getopt的第三个参数”nt:”，说明可用的参数有n和t，t后面有一个冒号，说明t需要额外的参数。</p>

<p>运行结果如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #800080">5</span>:<span style="color: #800080">30</span>:<span style="color: #800080">22</span> wing@ubuntu msg ./getopt_test -<span style="color: #000000">n
AAAAAAAA
</span><span style="color: #800080">5</span>:<span style="color: #800080">30</span>:<span style="color: #800080">26</span> wing@ubuntu msg ./getopt_test -<span style="color: #000000">t 
.</span>/getopt_test: option requires an argument -- <span style="color: #800000">'</span><span style="color: #800000">t</span><span style="color: #800000">'</span>
<span style="color: #800080">5</span>:<span style="color: #800080">30</span>:<span style="color: #800080">31</span> wing@ubuntu msg ./getopt_test -t <span style="color: #800080">100</span>                                           <span style="color: #800080">1</span><span style="color: #000000"> ↵
BBBBBBBB
n </span>= <span style="color: #800080">100</span></pre>
</div>]]></description></item><item><title>Python学习笔记（七）函数的使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/14/4098271.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 14 Nov 2014 13:56:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/14/4098271.html</guid><description><![CDATA[<p>python中的函数使用较简单，这里列出值得注意的几点：</p>  <p>&#160;</p>  <p><font size="4"><strong>内嵌函数</strong></font></p>  <p>&#160;</p>  <p>例如：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> foo():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> bar():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">bar() called.</span><span style="color: #800000">'</span>
    <span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">foo() called.</span><span style="color: #800000">'</span><span style="color: #000000">

foo()
bar()</span></pre>
</div>

<p>对bar的调用是非法的，因为bar的作用域仅限于foo内，除非使用闭包将其返回。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> foo():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> bar():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">bar() called.</span><span style="color: #800000">'</span>
    <span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">foo() called.</span><span style="color: #800000">'</span>
    <span style="color: #0000ff">return</span><span style="color: #000000"> bar

s </span>=<span style="color: #000000"> foo()
s()</span></pre>
</div>

<p>此时对s的调用就是合法的，因为我们在外部引用了bar。</p>

<p>&#160;</p>

<p>&#160;</p>



<p><font size="4"><strong>装饰器</strong></font></p>

<p>&#160;</p>

<p>我们在类中编写static函数时，就使用了static包装器，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Test():
    @staticmethod
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> foo():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">static method</span><span style="color: #800000">'</span><span style="color: #000000">

Test.foo()</span></pre>
</div>



<p>实际上，<font color="#ff0000">包装器就是函数</font>。</p>

<p>下面看一个demo：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

</span><span style="color: #0000ff">def</span><span style="color: #000000"> testfunc(func):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> wrappedFunc():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">[%s] %s() called.</span><span style="color: #800000">'</span> % (ctime(), func.<span style="color: #800080">__name__</span><span style="color: #000000">)
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> func()
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrappedFunc

@testfunc
</span><span style="color: #0000ff">def</span><span style="color: #000000"> foo():
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">foo called.</span><span style="color: #800000">'</span><span style="color: #000000">


foo()</span></pre>
</div>



<p>运行结果如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>5:34:25 wing@ubuntu func python 2<span style="color: #000000">.py  
[Fri Nov </span>14 05:36:31 2014<span style="color: #000000">] foo() called.
foo called.</span></pre>
</div>

<p>上面如果不对foo添加装饰器，还可以这样调用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

</span><span style="color: #0000ff">def</span><span style="color: #000000"> testfunc(func):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> wrappedFunc():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">[%s] %s() called.</span><span style="color: #800000">'</span> % (ctime(), func.<span style="color: #800080">__name__</span><span style="color: #000000">)
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> func()
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> wrappedFunc

</span><span style="color: #008000">#</span><span style="color: #008000">@testfunc</span>
<span style="color: #0000ff">def</span><span style="color: #000000"> foo():
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">foo called.</span><span style="color: #800000">'</span><span style="color: #000000">

foo </span>=<span style="color: #000000"> testfunc(foo)
foo()</span></pre>
</div>
效果相同。

<p>&#160;</p>

<p>&#160;</p>

<p><font size="4"><strong>函数的参数</strong></font></p>

<p>&#160;</p>

<p>在C++中，参数的位置是绝对不可以更改的，但是python中如果指定参数名，那么可以更改，例如：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span><span style="color: #000000"> foo(a, b):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">a = %d, b = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (a, b)

foo(</span>4, 3<span style="color: #000000">)
foo(a </span>= 4, b = 3<span style="color: #000000">)
foo(b </span>= 3, a = 4)</pre>
</div>

<p>最后一行调用，a和b就更换了位置。</p>

<p>&#160;</p>

<p><font size="4"><strong>函数的缺省参数</strong></font></p>

<p>&#160;</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span> foo(a, b = 20<span style="color: #000000">):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">a = %d, b = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (a, b)

foo(</span>23<span style="color: #000000">)
foo(a </span>= 12<span style="color: #000000">)
foo(</span>4, 3<span style="color: #000000">)
foo(a </span>= 4, b = 3<span style="color: #000000">)
foo(b </span>= 3, a = 4)</pre>
</div>

<p>存在缺省参数时，也可以指定参数名，这样就可以调换位置</p>

<p>再比如：</p>







<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span> foo(name, age = 20, sex = <span style="color: #800000">'</span><span style="color: #800000">male</span><span style="color: #800000">'</span><span style="color: #000000">):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">name = %s, age = %d, sex = %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (name, age, sex)

foo(</span><span style="color: #800000">'</span><span style="color: #800000">zhangsan</span><span style="color: #800000">'</span>, 23, <span style="color: #800000">'</span><span style="color: #800000">male</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">lisi</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">lisi</span><span style="color: #800000">'</span>, sex = <span style="color: #800000">'</span><span style="color: #800000">female</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(sex </span>= <span style="color: #800000">'</span><span style="color: #800000">male</span><span style="color: #800000">'</span>, name = <span style="color: #800000">'</span><span style="color: #800000">gaga</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>, 34<span style="color: #000000">)
foo(age </span>= 23, name = <span style="color: #800000">'</span><span style="color: #800000">lucy</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(sex </span>= <span style="color: #800000">'</span><span style="color: #800000">female</span><span style="color: #800000">'</span>, age = 88, name = <span style="color: #800000">'</span><span style="color: #800000">wangwu</span><span style="color: #800000">'</span>)</pre>
</div>

<p>&#160;</p>

<p><font size="4"><strong>不带关键字的可变参数</strong></font></p>

<p>&#160;</p>

<p>C语言中的printf函数，可以使用可变参数，意思就是参数的个数和类型是不确定的，Python同样支持这种用法。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span> foo(a, b = <span style="color: #800000">'</span><span style="color: #800000">default Value</span><span style="color: #800000">'</span>, *<span style="color: #000000">theList):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">a = </span><span style="color: #800000">'</span><span style="color: #000000">, a
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">b = </span><span style="color: #800000">'</span><span style="color: #000000">, b
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> theList:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">other argument :</span><span style="color: #800000">'</span><span style="color: #000000">, i

foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span>23, 4.56<span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span>, 123, <span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span>, 123, <span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span>, <span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>, <span style="color: #800000">'</span><span style="color: #800000">gaga</span><span style="color: #800000">'</span>, 34)</pre>
</div>

<p>我们在参数的最后一个位置写入*theList，意思就是多余的参数写入一个元组中。</p>

<p>注意这里的参数都是不带关键字的，如果我们使用了c = 5，那么导致运行错误。</p>

<p>&#160;</p>

<p><font size="4"><strong>带关键字的可变参数</strong></font></p>

<p>&#160;</p>

<p>如果我们真的需要使用c = 5这种额外的参数，可以使用**theRest，将多余的参数放入字典。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span> foo(a, b = <span style="color: #800000">'</span><span style="color: #800000">default Value</span><span style="color: #800000">'</span>, **<span style="color: #000000">theDict):
    </span><span style="color: #800000">'</span><span style="color: #800000">除了a和b外，其余的参数放入</span><span style="color: #800000">'</span>
    <span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">a = </span><span style="color: #800000">'</span><span style="color: #000000">, a
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">b = </span><span style="color: #800000">'</span><span style="color: #000000">, b
    </span><span style="color: #0000ff">for</span> eachKey <span style="color: #0000ff">in</span><span style="color: #000000"> theDict.keys():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Other argument %s: %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (eachKey, theDict[eachKey])

foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span>23, 4.56<span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span>, 123, c = <span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span>, 123, c = <span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span>, d = <span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>, e = <span style="color: #800000">'</span><span style="color: #800000">gaga</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(c </span>= <span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span>, a = <span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>, b = <span style="color: #800000">'</span><span style="color: #800000">gaga</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span>, c = <span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>, b = <span style="color: #800000">'</span><span style="color: #800000">gaga</span><span style="color: #800000">'</span><span style="color: #000000">)
foo(</span><span style="color: #800000">'</span><span style="color: #800000">hehe</span><span style="color: #800000">'</span>, c = <span style="color: #800000">'</span><span style="color: #800000">c</span><span style="color: #800000">'</span>)</pre>
</div>

<p>&#160;</p>

<p>二者还可以结合使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>

<span style="color: #0000ff">def</span> foo(a, b = <span style="color: #800000">'</span><span style="color: #800000">default Value</span><span style="color: #800000">'</span>, *theList, **<span style="color: #000000">theDict):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">a = </span><span style="color: #800000">'</span><span style="color: #000000">, a
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">b = </span><span style="color: #800000">'</span><span style="color: #000000">, b
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span><span style="color: #000000"> theList:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">argument :</span><span style="color: #800000">'</span><span style="color: #000000">, i
    </span><span style="color: #0000ff">for</span> eachKey <span style="color: #0000ff">in</span><span style="color: #000000"> theDict.keys():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Other argument %s: %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (eachKey, theDict[eachKey])

foo(</span><span style="color: #800000">'</span><span style="color: #800000">abc</span><span style="color: #800000">'</span>, 123, <span style="color: #800000">'</span><span style="color: #800000">zhangsan</span><span style="color: #800000">'</span>, c = <span style="color: #800000">'</span><span style="color: #800000">xyz</span><span style="color: #800000">'</span>, d = <span style="color: #800000">'</span><span style="color: #800000">haha</span><span style="color: #800000">'</span>, e = <span style="color: #800000">'</span><span style="color: #800000">gaga</span><span style="color: #800000">'</span>)</pre>
</div>

<p>&#160;</p>

<p>对于上面的代码，尝试调用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>foo(2, 4, *(6, 8), **{<span style="color: #800000">'</span><span style="color: #800000">foo</span><span style="color: #800000">'</span> : 12, <span style="color: #800000">'</span><span style="color: #800000">bar</span><span style="color: #800000">'</span> : 24})</pre>
</div>

<p>运行结果为：</p>

<p>
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre>a =  2<span style="color: #000000">
b </span>=  4<span style="color: #000000">
argument : </span>6<span style="color: #000000">
argument : </span>8<span style="color: #000000">
Other argument foo: </span>12<span style="color: #000000">
Other argument bar: </span>24</pre>
  </div>
这与我们手工列出各项变量，结果是一致的。</p>

<p>注意不带关键字的集合未必是元组，只要是序列就可以，于是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>foo(2, 4, *<span style="color: #800000">&quot;</span><span style="color: #800000">abcdefg</span><span style="color: #800000">&quot;</span>, **{<span style="color: #800000">'</span><span style="color: #800000">foo</span><span style="color: #800000">'</span> : 12, <span style="color: #800000">'</span><span style="color: #800000">bar</span><span style="color: #800000">'</span> : 24})</pre>
</div>

<p>打印结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>a =  2<span style="color: #000000">
b </span>=  4<span style="color: #000000">
argument : a
argument : b
argument : c
argument : d
argument : e
argument : f
argument : g
Other argument foo: </span>12<span style="color: #000000">
Other argument bar: </span>24</pre>
</div>

<p>如果我们将元组和字典提前定义，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>aTuple = (6, 8<span style="color: #000000">)
bDict </span>= {<span style="color: #800000">'</span><span style="color: #800000">foo</span><span style="color: #800000">'</span> : 12, <span style="color: #800000">'</span><span style="color: #800000">bar</span><span style="color: #800000">'</span> : 24<span style="color: #000000">}
foo(</span>2, 4, *aTuple, **bDict)</pre>
</div>

<p>结果与上面是一致的。</p>

<p>不过值得注意的是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>foo(1, 2, 3, x = 4, y = 5, *aTuple, **bDict)</pre>
</div>

<p>结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>a =  1<span style="color: #000000">
b </span>=  2<span style="color: #000000">
argument : </span>3<span style="color: #000000">
argument : </span>6<span style="color: #000000">
argument : </span>8<span style="color: #000000">
Other argument y: </span>5<span style="color: #000000">
Other argument x: </span>4<span style="color: #000000">
Other argument foo: </span>12<span style="color: #000000">
Other argument bar: </span>24</pre>
</div>

<p>解释器自动帮我们进行了合并。</p>

<p>&#160;</p>

<p>这里我们应该认识到，<font color="#ff0000">*</font><font color="#ff0000">和**在函数调用时的作用就是讲元组或者字典展开，这与C语言中的*解引用操作语义一致</font>。</p>]]></description></item><item><title>Python学习笔记（六）多进程实现并发服务器</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/13/4096151.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 13 Nov 2014 15:07:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/13/4096151.html</guid><description><![CDATA[<p>这个相对于多进程更加简单，每accept一个新的连接就创建一个新的线程。代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> socket
</span><span style="color: #0000ff">import</span><span style="color: #000000"> sys
</span><span style="color: #0000ff">import</span><span style="color: #000000"> errno
</span><span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

</span><span style="color: #0000ff">class</span><span style="color: #000000"> ClientThread(threading.Thread):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, client_socket, client_address):
        threading.Thread.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self)
        self.client_socket </span>=<span style="color: #000000"> client_socket
        self.client_address </span>=<span style="color: #000000"> client_address

    </span><span style="color: #0000ff">def</span><span style="color: #000000"> run(self):
        self.handle_connection()

    </span><span style="color: #0000ff">def</span><span style="color: #000000"> handle_connection(self):
        </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
            data </span>= self.client_socket.recv(1024<span style="color: #000000">)
            </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
                </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">disconnect</span><span style="color: #800000">'</span><span style="color: #000000">, self.client_address
                self.client_socket.close()
                </span><span style="color: #0000ff">break</span><span style="color: #000000">;
            </span><span style="color: #0000ff">else</span><span style="color: #000000">:
                self.client_socket.send(</span><span style="color: #800000">'</span><span style="color: #800000">[%s] %s</span><span style="color: #800000">'</span> % (ctime(), data)) <span style="color: #008000">#</span><span style="color: #008000">回显消息</span>


<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    server_socket </span>=<span style="color: #000000"> socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_address </span>= (<span style="color: #800000">'</span><span style="color: #800000">localhost</span><span style="color: #800000">'</span>, 9981<span style="color: #000000">)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, </span>1<span style="color: #000000">)
    server_socket.bind(listen_address)
    server_socket.listen(</span>10<span style="color: #000000">)

    </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
        </span><span style="color: #0000ff">try</span><span style="color: #000000">:
            (client_socket, client_address) </span>=<span style="color: #000000"> server_socket.accept()
        </span><span style="color: #0000ff">except</span><span style="color: #000000"> IOError, e:            
            </span><span style="color: #0000ff">if</span> e.errno ==<span style="color: #000000"> errno.EINTR:
                </span><span style="color: #0000ff">continue</span> <span style="color: #008000">#</span><span style="color: #008000">继续等待</span>
            <span style="color: #0000ff">else</span><span style="color: #000000">:
                </span><span style="color: #0000ff">raise</span> <span style="color: #008000">#</span><span style="color: #008000">将异常向外throw</span>
        <span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Got connection from </span><span style="color: #800000">'</span><span style="color: #000000">, client_address
        t </span>=<span style="color: #000000"> ClientThread(client_socket, client_address)
        t.start()</span></pre>
</div>

<p>注意这里<font color="#ff0000">的thread不能进行join，否则会阻塞主线程，丧失并发能力</font>。</p>

<p>另外，<font color="#ff0000">python中的线程不需要进行detach</font>。</p>]]></description></item><item><title>Python学习笔记（五）多进程实现并发服务器</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/13/4096140.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 13 Nov 2014 15:03:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/13/4096140.html</guid><description><![CDATA[<p>&#160;</p>  <p>每创建一个TCP连接，就创建一个进程。</p>  <p>代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> socket
</span><span style="color: #0000ff">import</span><span style="color: #000000"> os
</span><span style="color: #0000ff">import</span><span style="color: #000000"> sys
</span><span style="color: #0000ff">import</span><span style="color: #000000"> signal
</span><span style="color: #0000ff">import</span><span style="color: #000000"> errno
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

</span><span style="color: #0000ff">def</span><span style="color: #000000"> hanlde_sigchld(a, b):
    (pid, status) </span>=<span style="color: #000000"> os.wait()
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Child %d Finish, status = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (pid, status)

</span><span style="color: #0000ff">def</span><span style="color: #000000"> handle_connection(client_socket, client_address):
    </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
        data </span>= client_socket.recv(1024<span style="color: #000000">)
        </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">disconnect</span><span style="color: #800000">'</span><span style="color: #000000">, client_address
            client_socket.close()
            </span><span style="color: #0000ff">break</span><span style="color: #000000">;
        </span><span style="color: #0000ff">else</span><span style="color: #000000">:
            client_socket.send(</span><span style="color: #800000">'</span><span style="color: #800000">[%s] %s</span><span style="color: #800000">'</span> % (ctime(), data)) <span style="color: #008000">#</span><span style="color: #008000">回显消息</span>


<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    signal.signal(signal.SIGCHLD, hanlde_sigchld) </span><span style="color: #008000">#</span><span style="color: #008000">安装SIGCHLD的处理函数</span>
<span style="color: #000000">
    server_socket </span>=<span style="color: #000000"> socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_address </span>= (<span style="color: #800000">'</span><span style="color: #800000">localhost</span><span style="color: #800000">'</span>, 9981<span style="color: #000000">)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, </span>1<span style="color: #000000">)
    server_socket.bind(listen_address)
    server_socket.listen(</span>10<span style="color: #000000">)

    </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
        </span><span style="color: #0000ff">try</span><span style="color: #000000">:
            (client_socket, client_address) </span>=<span style="color: #000000"> server_socket.accept()
        </span><span style="color: #0000ff">except</span><span style="color: #000000"> IOError, e:            
            </span><span style="color: #0000ff">if</span> e.errno ==<span style="color: #000000"> errno.EINTR:
                </span><span style="color: #0000ff">continue</span> <span style="color: #008000">#</span><span style="color: #008000">继续等待</span>
            <span style="color: #0000ff">else</span><span style="color: #000000">:
                </span><span style="color: #0000ff">raise</span> <span style="color: #008000">#</span><span style="color: #008000">将异常向外throw</span>
        <span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Got connection from </span><span style="color: #800000">'</span><span style="color: #000000">, client_address
        pid </span>=<span style="color: #000000"> os.fork()
        </span><span style="color: #0000ff">if</span> pid ==<span style="color: #000000"> 0:
            server_socket.close()
            handle_connection(client_socket, client_address)
            sys.exit(0)    </span><span style="color: #008000">#</span><span style="color: #008000">防止子进程中忘记exit</span>
        <span style="color: #0000ff">elif</span> pid &gt;<span style="color: #000000"> 0:
            client_socket.close() </span><span style="color: #008000">#</span><span style="color: #008000">必须关闭</span></pre>
</div>



<p>这里有几点需要注意：</p>

<p>1.子进程中需要关闭server套接字，因为子进程只需要客户套接字即可。</p>

<p>2.父进程必须关闭客户套接字，<font color="#ff0000">因为该socket是基于引用计数的，父进程不关闭，会导致该套接字永远不会真正的关闭</font>。</p>

<p>3.注意处理子进程的消亡，避免僵尸进程。这里<font color="#ff0000">不能直接使用wait或者waitpid函数，因为该函数会使得进程阻塞</font>，这样不具备并发能力。</p>]]></description></item><item><title>Python学习笔记（四）多进程的使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/12/4093561.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 12 Nov 2014 13:29:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/12/4093561.html</guid><description><![CDATA[<p>python中多进程与Linux 下的C基本相同。</p>  <p>&#160;</p>  <p><strong><font size="4">fork的基本使用</font></strong></p>  <p>&#160;</p>  <p>先看最简单的例子：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> os

</span><span style="color: #0000ff">def</span><span style="color: #000000"> my_fork():
    pid </span>=<span style="color: #000000"> os.fork()
    </span><span style="color: #0000ff">if</span> pid ==<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">this is child, pid = %d, parent id = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (os.getpid(), os.getppid())
    </span><span style="color: #0000ff">elif</span> pid &gt;<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">this is parent, pid = %d, child id = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (os.getpid(), pid)
        os.waitpid(pid, 0) </span><span style="color: #008000">#</span><span style="color: #008000">等待子进程结束</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    my_fork()</span></pre>
</div>



<p>这个例子演示了fork的基本使用，还有就是我们最后使用了waitpid来回收子进程。</p>

<p>如果不知道具体的子进程号码，可以使用wait函数。</p>

<p>&#160;</p>

<p><font size="4"><strong>管道pipe的使用</strong></font></p>

<p>&#160;</p>

<p>代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> os
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> my_fork():
    r, w </span>=<span style="color: #000000"> os.pipe()
    pid </span>=<span style="color: #000000"> os.fork()
    </span><span style="color: #0000ff">if</span> pid ==<span style="color: #000000"> 0:
        os.close(r) </span><span style="color: #008000">#</span><span style="color: #008000">关闭读端</span>
        w = os.fdopen(w, <span style="color: #800000">&quot;</span><span style="color: #800000">w</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
        </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(10<span style="color: #000000">):
            w.write(</span><span style="color: #800000">'</span><span style="color: #800000">%s\n</span><span style="color: #800000">'</span> % (str(i+1))) <span style="color: #008000">#</span><span style="color: #008000">最后加上\n</span>
            w.flush()  <span style="color: #008000">#</span><span style="color: #008000">这里记得刷新</span>
            sleep(0.5<span style="color: #000000">)
        w.close()
    </span><span style="color: #0000ff">elif</span> pid &gt;<span style="color: #000000"> 0:
        os.close(w) </span><span style="color: #008000">#</span><span style="color: #008000">关闭写端</span>
        r = os.fdopen(r, <span style="color: #800000">&quot;</span><span style="color: #800000">r</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
        </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
            data </span>= r.readline() <span style="color: #008000">#</span><span style="color: #008000">不要使用read</span>
            <span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
                </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">close.</span><span style="color: #800000">'</span>
                <span style="color: #0000ff">break</span><span style="color: #000000">;
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">received : %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (data)
        os.waitpid(pid, 0)  </span><span style="color: #008000">#</span><span style="color: #008000">等待子进程结束</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    my_fork()</span></pre>
</div>



<p>在子进程中，连续10次发送数字。</p>

<p>这里有几点值得注意：</p>

<blockquote>
  <p>write时加上\n符号</p>

  <p>接收时使用readline函数</p>

  <p>每发送完一个数据，就刷新flush一次缓冲区</p>
</blockquote>

<p>&#160;</p>

<p><font size="4"><strong>使用信号处理僵尸进程</strong></font></p>

<p>&#160;</p>

<p>Python中也可以使用信号处理函数，例如最简单的中断信号：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> os
</span><span style="color: #0000ff">import</span><span style="color: #000000"> signal
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> handler(a, b):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Ctrl + C</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    signal.signal(signal.SIGINT, handler)
    </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
        </span><span style="color: #0000ff">pass</span></pre>
</div>

<p>每按一次Ctrl+C，就触发一次这个函数。</p>

<p>&#160;</p>

<p>代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> os
</span><span style="color: #0000ff">import</span><span style="color: #000000"> signal
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> handler(a, b):
    (pid, status) </span>=<span style="color: #000000"> os.wait()
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Child %d Finish, status = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (pid, status)

</span><span style="color: #0000ff">def</span><span style="color: #000000"> my_fork():
    pid </span>=<span style="color: #000000"> os.fork()
    </span><span style="color: #0000ff">if</span> pid ==<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">this is child, pid = %d, parent id = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (os.getpid(), os.getppid())
    </span><span style="color: #0000ff">elif</span> pid &gt;<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">this is parent, pid = %d, child id = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> (os.getpid(), pid)
        
        </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
            </span><span style="color: #0000ff">pass</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    signal.signal(signal.SIGCHLD, handler)
    my_fork()</span></pre>
</div>


每当有子进程消亡，就触发SIGCHLD信号，然后在处理函数中调用wait函数。这里比Linux下简单，<font color="#ff0000">不必使用while循环回收</font>。

<p>&#160;</p>

<p>下节使用python，编写一个多进程的并发服务器。</p>

<p>完。</p>]]></description></item><item><title>Python学习笔记（三）多线程的使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/12/4092757.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 12 Nov 2014 09:11:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/12/4092757.html</guid><description><![CDATA[<p>这节记录学习多线程的心得。</p>  <p>&#160;</p>  <p>Python提供了thread模块，不过该模块的缺点很多，例如无法方便的等待线程结束，所以我们使用更加高级的threading模块。</p>  <p>&#160;</p>  <p>threading模块的使用一共三种模式：</p>  <blockquote>   <p>1.利用函数生成一个Thread实例</p>    <p>2.利用函数生成一个可以调用的类对象，生成一个Thread实例</p>    <p>3.从Thread派生一个子类，创建这个子类的实例</p> </blockquote>  <p>&#160;</p>  <p><font size="4"><strong>利用函数生成Thread实例</strong></font></p>  <p>&#160;</p>  <p>第一种使用方式最为简单，代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> threadFunc():
    i </span>= 10<span style="color: #000000">;
    </span><span style="color: #0000ff">while</span> i &gt;<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i
        i </span>-= 1

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    t </span>= threading.Thread(target =<span style="color: #000000"> threadFunc)
    t.start()
    t.join()</span></pre>
</div>



<p>这段代码的逻辑很简单，就是在线程中执行threadFunc这个函数。</p>

<p>如果该函数需要参数的话，在
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre>t = threading.Thread(target = threadFunc)</pre>
  </div>
这一行添加一个参数即可，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">def</span><span style="color: #000000"> threadFunc(i):
    </span><span style="color: #0000ff">while</span> i &gt;<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i
        i </span>-= 1

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    t </span>= threading.Thread(target = threadFunc, args = [10<span style="color: #000000">])
    t.start()
    t.join()</span></pre>
</div>

<p>注意args参数必须使用元组或者列表。</p>

<p>&#160;</p>

<p><font size="4"><strong>利用函数生成一个可以调用的类对象，生成一个Thread实例</strong></font></p>

<p>&#160;</p>

<p>我们先补充一些知识，C++中有函数对象，就是对某一个类重载函数调用操作符，那么该类的对象就可以当做函数来使用，python中也有同样的机制：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Foo():
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__call__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">foobar</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    f </span>=<span style="color: #000000"> Foo()
    f()</span></pre>
</div>

<p>此例中f是一个对象，但可以当做函数使用。当调用f()时，解释器调用了Foo中的__call__方法，相当于C++中的operator()操作符被重载。</p>

<p>&#160;</p>

<p>还有一个关于apply的知识点：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">def</span><span style="color: #000000"> test(i):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i 

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    apply(test, [</span>1])</pre>
</div>

<p>apply可以这样调用函数。通过这种机制，<font color="#ff0000">我们可以将函数存储起来，选择合适的时机注意调用</font>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> random <span style="color: #0000ff">import</span><span style="color: #000000"> randint

</span><span style="color: #0000ff">def</span><span style="color: #000000"> foo(i):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i 
</span><span style="color: #0000ff">def</span><span style="color: #000000"> bar(i):
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i*i = %d</span><span style="color: #800000">'</span> % (i*<span style="color: #000000">i)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Foo():
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__call__</span><span style="color: #000000">(self, i):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">foobar: %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i

</span><span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    funcs </span>=<span style="color: #000000"> [foo, bar, Foo()]
    </span><span style="color: #0000ff">for</span> func <span style="color: #0000ff">in</span><span style="color: #000000"> funcs:
        i </span>= randint(1, 4<span style="color: #000000">)
        apply(func, [i])</span></pre>
</div>



<p>&#160;</p>

<p>于是我们可以将函数存储在类中，为该类提供__call__函数，此时这个类的对象也是可以执行的，所以我们利用这个对象去生成Thread。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">class</span><span style="color: #000000"> ThreadFunc(object):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, func, args):
        self.func </span>=<span style="color: #000000"> func
        self.args </span>=<span style="color: #000000"> args

    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__call__</span><span style="color: #000000">(self):
        apply(self.func, self.args)

</span><span style="color: #0000ff">def</span><span style="color: #000000"> loop(i):
    </span><span style="color: #0000ff">while</span> i &gt;<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i
        sleep(</span>0.5<span style="color: #000000">)
        i </span>-= 1

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">在主线程内执行这个函数</span><span style="color: #800000">'</span><span style="color: #000000">
    t1 </span>= ThreadFunc(loop, [5<span style="color: #000000">])
    t1()

    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">开始执行一个新的线程</span><span style="color: #800000">'</span><span style="color: #000000">
    t2 </span>= threading.Thread(target =<span style="color: #000000"> t1)
    t2.start()
    t2.join()
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">线程执行完毕</span><span style="color: #800000">'</span>

    <span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">开始执行一个新的线程</span><span style="color: #800000">'</span><span style="color: #000000">
    t3 </span>= threading.Thread(target = ThreadFunc(loop, [3<span style="color: #000000">]))
    t3.start()
    t3.join()
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">线程执行完毕</span><span style="color: #800000">'</span></pre>
</div>

<p>t1是个ThreadFunc的实例，既可以直接执行，又可以使用它去生成Thread实例。</p>

<p>&#160;</p>

<p><font size="4"><strong>从Thread派生一个子类，创建这个子类的实例</strong></font></p>

<p>&#160;</p>

<p>最简单的使用方式如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MyThread(threading.Thread):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self):
        threading.Thread.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self)
        self.count </span>= 10

    <span style="color: #0000ff">def</span><span style="color: #000000"> run(self):
        </span><span style="color: #0000ff">while</span> self.count &gt;<span style="color: #000000"> 0:
            </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> self.count
            sleep(</span>1<span style="color: #000000">)
            self.count </span>-= 1

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    t </span>=<span style="color: #000000"> MyThread();
    t.start()
    t.join()</span></pre>
</div>

<p>我们去继承Thread类，然后覆盖其中的run方法，这与Java的Thread使用相一致。</p>

<p>创建多个线程可以这样：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">class</span><span style="color: #000000"> MyThread(threading.Thread):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self):
        threading.Thread.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self)

    </span><span style="color: #0000ff">def</span><span style="color: #000000"> run(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">begin .....</span><span style="color: #800000">'</span><span style="color: #000000">
        sleep(</span>5<span style="color: #000000">)
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">end.....</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    threads </span>=<span style="color: #000000"> []
    </span><span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(10<span style="color: #000000">):
        t </span>=<span style="color: #000000"> MyThread()
        threads.append(t)
    </span><span style="color: #0000ff">for</span> t <span style="color: #0000ff">in</span><span style="color: #000000"> threads:
        t.start()
    </span><span style="color: #0000ff">for</span> t <span style="color: #0000ff">in</span><span style="color: #000000"> threads:
        t.join()</span></pre>
</div>





<p>&#160;</p>

<p>不过，目前我们的线程逻辑是固定的，可以借鉴第二种方式，从外部传入逻辑，存储起来。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000">coding: utf-8</span>
<span style="color: #0000ff">import</span><span style="color: #000000"> threading
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> sleep

</span><span style="color: #0000ff">class</span><span style="color: #000000"> CustomThread(threading.Thread):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, func, args):
        threading.Thread.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self)
        self.func </span>=<span style="color: #000000"> func
        self.args </span>=<span style="color: #000000"> args

    </span><span style="color: #0000ff">def</span><span style="color: #000000"> run(self):
        apply(self.func, self.args)

</span><span style="color: #0000ff">def</span><span style="color: #000000"> loop(i):
    </span><span style="color: #0000ff">while</span> i &gt;<span style="color: #000000"> 0:
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">i = %d</span><span style="color: #800000">'</span> %<span style="color: #000000"> i
        sleep(</span>0.5<span style="color: #000000">)
        i </span>-= 1

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    t </span>= CustomThread(loop, [10<span style="color: #000000">])
    t.start()
    t.join()</span></pre>
</div>



<p>这里跟第二种不同的是：</p>

<blockquote>
  <p>1.采用了继承，基类是Thread</p>

  <p>2.覆盖run方法，而不是提供__call__方法</p>

  <p>3.使用时直接创建该类的实例</p>
</blockquote>

<p>以上三种，我个人感觉第三种最方便，在大一些程序中，可以将该Thread单独做成一个模块。</p>

<p>另外，<font color="#ff0000">前两种的本质是一样的，都是向Thread传入一个可以执行的对象</font>（python中函数也是对象）。</p>

<p>&#160;</p>

<p>完。</p>]]></description></item><item><title>Python学习笔记（二）网络编程的简单示例</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/12/4092341.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 12 Nov 2014 07:04:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/12/4092341.html</guid><description><![CDATA[<p>Python中的网络编程比C语言中要简洁很多，毕竟封装了大量的细节。</p>  <p>所以这里不再介绍网络编程的基本知识。而且我认为，从Python学习网络编程不是一个明智的选择。</p>  <p>&#160;</p>  <p><font size="4"><strong>简单的TCP连接</strong></font></p>  <p><strong><font size="4"></font></strong></p>  <p>服务器代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">import</span><span style="color: #000000"> socket
</span><span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

sock </span>=<span style="color: #000000"> socket.socket()
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, </span>1<span style="color: #000000">)
sock.bind((</span><span style="color: #800000">'</span><span style="color: #800000">localhost</span><span style="color: #800000">'</span>, 9981<span style="color: #000000">))
sock.listen(</span>5<span style="color: #000000">)

</span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">waiting for connection ...</span><span style="color: #800000">'</span><span style="color: #000000">
    peersock, peeraddr </span>=<span style="color: #000000"> sock.accept()
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">....connected from:</span><span style="color: #800000">'</span><span style="color: #000000">, peeraddr

    </span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
        data </span>= peersock.recv(1024<span style="color: #000000">)
        </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
            </span><span style="color: #0000ff">break</span><span style="color: #000000">
        peersock.send(</span><span style="color: #800000">'</span><span style="color: #800000">[%s] %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (ctime(), data))

    peersock.close()
sock.close()</span></pre>
</div>



<p>注意这里设置了地址复用。</p>

<p>这是一个时间戳服务器，同时server还将用户的输入直接回显过去。</p>

<p>&#160;</p>

<p>客户端的代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">import</span><span style="color: #000000"> socket

sock </span>=<span style="color: #000000"> socket.socket()
sock.connect((</span><span style="color: #800000">'</span><span style="color: #800000">localhost</span><span style="color: #800000">'</span>, 9981<span style="color: #000000">))

</span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
    data </span>= raw_input(<span style="color: #800000">'</span><span style="color: #800000">&gt; </span><span style="color: #800000">'</span><span style="color: #000000">)
    </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
        </span><span style="color: #0000ff">break</span><span style="color: #000000">;
    sock.send(data)
    data </span>= sock.recv(1024<span style="color: #000000">)
    </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
        </span><span style="color: #0000ff">break</span>
    <span style="color: #0000ff">print</span><span style="color: #000000"> data

sock.close()</span></pre>
</div>



<p>运行两边的代码，这里贴出客户端的运行结果：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>22:56:08 wing@ubuntu python python 2.py                                                1<span style="color: #000000"> ↵
</span>&gt;<span style="color: #000000"> foo
[Tue Nov </span>11 22:56:10 2014<span style="color: #000000">] foo
</span>&gt;<span style="color: #000000"> bar
[Tue Nov </span>11 22:56:12 2014<span style="color: #000000">] bar
</span>&gt;</pre>
</div>

<p>&#160;</p>

<p>&#160;</p>

<p><font size="4"><strong>简单的UDP连接</strong></font></p>

<p>&#160;</p>

<p>服务器代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> socket <span style="color: #0000ff">import</span> *
<span style="color: #0000ff">from</span> time <span style="color: #0000ff">import</span><span style="color: #000000"> ctime

sock </span>=<span style="color: #000000"> socket(AF_INET, SOCK_DGRAM)
sock.bind((</span><span style="color: #800000">'</span><span style="color: #800000">localhost</span><span style="color: #800000">'</span>, 9981<span style="color: #000000">))

</span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">waiting for message ...</span><span style="color: #800000">'</span><span style="color: #000000">
    data, addr </span>= sock.recvfrom(1024<span style="color: #000000">)
    sock.sendto(</span><span style="color: #800000">'</span><span style="color: #800000">[%s] %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (ctime(), data), addr)
    </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">...received from and returned to:</span><span style="color: #800000">'</span><span style="color: #000000">, addr

sock.close()</span></pre>
</div>



<p>&#160;</p>

<p>客户端代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">from</span> socket <span style="color: #0000ff">import</span> *<span style="color: #000000">

addr </span>= (<span style="color: #800000">'</span><span style="color: #800000">localhost</span><span style="color: #800000">'</span>, 9981<span style="color: #000000">)
sock </span>=<span style="color: #000000"> socket(AF_INET, SOCK_DGRAM)

</span><span style="color: #0000ff">while</span><span style="color: #000000"> True:
    data </span>= raw_input(<span style="color: #800000">'</span><span style="color: #800000">&gt; </span><span style="color: #800000">'</span><span style="color: #000000">)
    </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
        </span><span style="color: #0000ff">break</span><span style="color: #000000">;
    sock.sendto(data, addr)
    data, addr </span>= sock.recvfrom(1024<span style="color: #000000">)
    </span><span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span><span style="color: #000000"> data:
        </span><span style="color: #0000ff">break</span>
    <span style="color: #0000ff">print</span><span style="color: #000000"> data

sock.close()</span></pre>
</div>

<p>&#160;</p>

<p>&#160;</p>

<p>Python中还提供了其他一系列的高级组件，例如TcpServer、ForkingTcpServer和ThreadingTCPServer等，后面会写一篇文章，总结各种网络编程的模型，到时候再去介绍。</p>]]></description></item><item><title>Python学习笔记（一）类和继承的使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/11/12/4092233.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 12 Nov 2014 06:38:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/11/12/4092233.html</guid><description><![CDATA[<p>一年前就打算学Python了，折腾来折腾去也一直没有用熟练，主要是类那一块不熟，昨天用Python写了几个网络编程的示例，感觉一下子迈进了很多。这几天把学习Python的笔记整理一下，内容尽量简洁。</p>  <p>&#160;</p>  <p>&#160;</p>  <p>下面这个例子演示类的基本使用：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">#</span><span style="color: #008000"> coding:utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Test():
    s </span>= <span style="color: #800000">'</span><span style="color: #800000">这是一个静态变量</span><span style="color: #800000">'</span>
    <span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">这里是构造函数</span><span style="color: #800000">'</span><span style="color: #000000">
        self.a </span>= 1<span style="color: #000000">
        self.b </span>= 12

    <span style="color: #0000ff">def</span> <span style="color: #800080">__del__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">这里是析构函数</span><span style="color: #800000">'</span>

    <span style="color: #0000ff">def</span><span style="color: #000000"> foo(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">普通成员函数</span><span style="color: #800000">'</span><span style="color: #000000">

    @staticmethod
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> bar():
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">类的静态函数</span><span style="color: #800000">'</span>


<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    t </span>=<span style="color: #000000"> Test()
    t.foo()
    Test.bar()
    </span><span style="color: #0000ff">print</span> t.<span style="color: #800080">__class__</span>
    <span style="color: #0000ff">print</span> Test.<span style="color: #800080">__bases__</span>
    <span style="color: #0000ff">print</span> Test.s</pre>
</div>

<p>很多书上很啰嗦的介绍Python的类，但是很多Python学习者本身已经具备了C++或者Java的基础，所以我直接尝试写了这个一个demo。</p>

<p>在Python中，构造函数使用了__init__，析构函数则使用了__del__。</p>

<p>在C++中，类的成员变量和函数都是编译之前就确定了，而Python可以再运行期确定。</p>

<p>上例中的s相当于静态变量，整个类共同拥有。</p>

<p>__init__函数中的self.a属于普通成员变量。如果你在某一个函数中使用了 </p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>self.c = <span style="color: #800000">'</span><span style="color: #800000">foo</span><span style="color: #800000">'</span></pre>
</div>
之类的语句，意味着你在这一行为该对象添加了一个数据成员。 

<p>但是这里注意，<font color="#ff0000">只有运行这一行之后，对象的数据成员才添加了c</font>。所以，<font color="#ff0000">Python的成员变量是可以在运行过程中增减的</font>。</p>

<p>&#160;</p>

<p>&#160;</p>

<p>&#160;</p>

<p>再看第二个示例，关于继承和组合的：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding:utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Base():
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, a, b):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Base construct.</span><span style="color: #800000">'</span><span style="color: #000000">
        self.a </span>=<span style="color: #000000"> a;
        self.b </span>=<span style="color: #000000"> b;
        self.t </span>=<span style="color: #000000"> Other()

    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__del__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Base destroy.</span><span style="color: #800000">'</span>

    <span style="color: #0000ff">def</span><span style="color: #000000"> foo(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">a = %s b = %s</span><span style="color: #800000">'</span> %<span style="color: #000000"> (self.a, self.b)

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Other():
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Other construct.</span><span style="color: #800000">'</span>

    <span style="color: #0000ff">def</span> <span style="color: #800080">__del__</span><span style="color: #000000">(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Other destroy.</span><span style="color: #800000">'</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Derived(Base):
    </span><span style="color: #0000ff">def</span> <span style="color: #800080">__init__</span><span style="color: #000000">(self, a, b):
        Base.</span><span style="color: #800080">__init__</span><span style="color: #000000">(self, a, b)
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Derived construct.</span><span style="color: #800000">'</span>

    <span style="color: #0000ff">def</span> <span style="color: #800080">__del__</span><span style="color: #000000">(self):
        Base.</span><span style="color: #800080">__del__</span><span style="color: #000000">(self)
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">Derived destroy.</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    d </span>= Derived(<span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span>, <span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span><span style="color: #000000">)
    d.foo()
    </span><span style="color: #0000ff">print</span> d.<span style="color: #800080">__class__</span>
    <span style="color: #0000ff">print</span> d.<span style="color: #800080">__class__</span>.<span style="color: #800080">__bases__</span>
    <span style="color: #0000ff">print</span> Derived.<span style="color: #800080">__bases__</span></pre>
</div>

<p>Base是基类，Derived从Base中继承，同时Other类的一个对象是Derived的一个数据成员。</p>

<p>在本例中，注意，Derived的构造函数中，必须手工调用Base的构造函数，析构函数也是相同的用法。</p>

<p>&#160;</p>

<p>最后一个例子，关于基类和派生类的函数覆盖问题：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding:utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Foo():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> test(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">test in Base.</span><span style="color: #800000">'</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Bar(Foo):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> test(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">test in Derived.</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    b </span>=<span style="color: #000000"> Bar()
    b.test()</span></pre>
</div>

<p>我们运行程序，打印的是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>test <span style="color: #0000ff">in</span> Derived.</pre>
</div>
发现调用的是派生类的版本。这说明<font color="#ff0000">派生类的test函数覆盖了基类的版本</font>。 

<p>这里需要注意，与C++不同，这里的Bar中的test函数，即使改变了参数也无所谓，总之，只要函数与基类中的函数重名，那就构成了覆盖。</p>

<p>如果在Bar的test函数中想调用基类的版本，可以使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>Foo.test(self)</pre>
</div>

<p>完整的代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">#</span><span style="color: #008000"> coding:utf-8</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Foo():
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> test(self):
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">test in Base.</span><span style="color: #800000">'</span>

<span style="color: #0000ff">class</span><span style="color: #000000"> Bar(Foo):
    </span><span style="color: #0000ff">def</span><span style="color: #000000"> test(self):
        Foo.test(self)
        </span><span style="color: #0000ff">print</span> <span style="color: #800000">'</span><span style="color: #800000">test in Derived.</span><span style="color: #800000">'</span>

<span style="color: #0000ff">if</span> <span style="color: #800080">__name__</span> == <span style="color: #800000">'</span><span style="color: #800000">__main__</span><span style="color: #800000">'</span><span style="color: #000000">:
    b </span>=<span style="color: #000000"> Bar()
    b.test()</span></pre>
</div>

<p>&#160;</p>

<p>完。</p>]]></description></item><item><title>Linux非阻塞IO（八）使用epoll重新实现非阻塞的回射服务器</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/27/4055077.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 27 Oct 2014 12:46:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/27/4055077.html</guid><description><![CDATA[<p>本文无太多内容，主要是几个前面提到过的注意点：</p>  <p>一是epoll的fd需要重新装填。我们将tcp_connection_t的指针保存在数组中，所以我们<font color="#ff0000">以这个数组为依据，重新装填fd的监听事件</font>。</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">//</span><span style="color: #008000">重新装填epoll内fd的监听事件</span>
        <span style="color: #0000ff">int</span><span style="color: #000000"> i;
        </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; EVENTS_SIZE; ++<span style="color: #000000">i)
        {
            </span><span style="color: #0000ff">if</span>(connsets[i] !=<span style="color: #000000"> NULL)
            {
                </span><span style="color: #0000ff">int</span> fd = i; <span style="color: #008000">//</span><span style="color: #008000">fd</span>
                tcp_connection_t *pt = connsets[i]; <span style="color: #008000">//</span><span style="color: #008000">tcp conn</span>
                uint32_t <span style="color: #0000ff">event</span> = <span style="color: #800080">0</span><span style="color: #000000">;
                </span><span style="color: #0000ff">if</span>(buffer_is_readable(&amp;pt-&gt;<span style="color: #000000">buffer_))
                    </span><span style="color: #0000ff">event</span> |=<span style="color: #000000"> kWriteEvent;
                </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;pt-&gt;<span style="color: #000000">buffer_))
                    </span><span style="color: #0000ff">event</span> |=<span style="color: #000000"> kReadEvent;
                </span><span style="color: #008000">//</span><span style="color: #008000">重置监听事件</span>
                epoll_mod_fd(epollfd, fd, <span style="color: #0000ff">event</span><span style="color: #000000">);
            }
        }</span></pre>
</div>



<p>二是，建立连接时，需要做的工作是：</p>

<blockquote>
  <p>1.新建tcp_connection_t结构，初始化</p>

  <p>2.将fd加入epoll，<font color="#ff0000"><strong>不监听任何事件</strong></font></p>

  <p>3.将tcp_connection_t的指针加入数组。</p>
</blockquote>

<p>代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre><span style="color: #008000">//</span><span style="color: #008000">建立连接</span>
<span style="color: #0000ff">int</span> peerfd = accept4(listenfd, NULL, NULL, SOCK_NONBLOCK |<span style="color: #000000"> SOCK_CLOEXEC);
</span><span style="color: #0000ff">if</span>(peerfd == -<span style="color: #800080">1</span><span style="color: #000000">)
      ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">accept4</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #008000">//</span><span style="color: #008000">新建tcp连接</span>
tcp_connection_t *pt = (tcp_connection_t*)malloc(<span style="color: #0000ff">sizeof</span><span style="color: #000000">(tcp_connection_t));
buffer_init(</span>&amp;pt-&gt;<span style="color: #000000">buffer_);
</span><span style="color: #008000">//</span><span style="color: #008000">将该tcp连接放入connsets</span>
connsets[peerfd] =<span style="color: #000000"> pt;
epoll_add_fd(epollfd, peerfd, </span><span style="color: #800080">0</span>);</pre>
  </div>
</div>

<p>连接关闭时需要：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">close</span>
<span style="color: #000000">epoll_del_fd(epollfd, fd);
close(fd);
free(pt);
connsets[fd] </span>= NULL;</pre>
</div>



<p>&#160;</p>

<p>还有一点：前面我们记录fd和connsets的关系，采用的是数组下标的方式，其实我们<font color="#ff0000">还可以将指针存入epoll的data</font>中，其中：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">typedef union epoll_data {
   </span><span style="color: #0000ff">void</span>        *<span style="color: #000000">ptr;
   </span><span style="color: #0000ff">int</span><span style="color: #000000">          fd;
   uint32_t     u32;
   uint64_t     u64;
} epoll_data_t;

</span><span style="color: #0000ff">struct</span><span style="color: #000000"> epoll_event {
   uint32_t     events;      </span><span style="color: #008000">/*</span><span style="color: #008000"> Epoll events </span><span style="color: #008000">*/</span><span style="color: #000000">
   epoll_data_t data;        </span><span style="color: #008000">/*</span><span style="color: #008000"> User data variable </span><span style="color: #008000">*/</span><span style="color: #000000">
};</span></pre>
</div>

<p>我们对于data这个联合体，<font color="#ff0000">不再使用fd，而是使用ptr，指向一个tcp_connection_t的指针</font>。不过我们需要将fd存储在tcp_connection_t数据结构中。</p>

<p>这里为了简便起见，仍采用以前的方法，读者可以自行尝试。</p>

<p>&#160;</p>

<p>完整的代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">#define</span> _GNU_SOURCE             /* See feature_test_macros(7) */<span style="color: #000000">
#include </span>&lt;sys/socket.h&gt;<span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">sysutil.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">buffer.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;assert.h&gt;<span style="color: #000000">
#include </span>&lt;sys/epoll.h&gt;

<span style="color: #0000ff">#define</span> EVENTS_SIZE 1024<span style="color: #000000">

typedef </span><span style="color: #0000ff">struct</span><span style="color: #000000">{
    buffer_t buffer_;
} tcp_connection_t; </span><span style="color: #008000">//</span><span style="color: #008000">表示一条TCP连接</span>
<span style="color: #000000">
tcp_connection_t </span>*connsets[EVENTS_SIZE]; <span style="color: #008000">//</span><span style="color: #008000">提供从fd到TCP连接的映射</span>

<span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #008000">//</span><span style="color: #008000">获取监听fd</span>
    <span style="color: #0000ff">int</span> listenfd = tcp_server(<span style="color: #800000">&quot;</span><span style="color: #800000">localhost</span><span style="color: #800000">&quot;</span>, <span style="color: #800080">9981</span><span style="color: #000000">);
    </span><span style="color: #008000">//</span><span style="color: #008000">将监听fd设置为非阻塞</span>
<span style="color: #000000">    activate_nonblock(listenfd);

    </span><span style="color: #008000">//</span><span style="color: #008000">初始化connsets</span>
    <span style="color: #0000ff">int</span><span style="color: #000000"> ix;
    </span><span style="color: #0000ff">for</span>(ix = <span style="color: #800080">0</span>; ix &lt; EVENTS_SIZE; ++<span style="color: #000000">ix)
    {
        connsets[ix] </span>=<span style="color: #000000"> NULL;
    }


    </span><span style="color: #008000">//</span><span style="color: #008000">初始化epoll</span>
    <span style="color: #0000ff">int</span> epollfd = epoll_create1(<span style="color: #800080">0</span><span style="color: #000000">);
    epoll_add_fd(epollfd, listenfd, kReadEvent);
    </span><span style="color: #0000ff">struct</span> epoll_event events[<span style="color: #800080">1024</span><span style="color: #000000">];


    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">重新装填epoll内fd的监听事件</span>
        <span style="color: #0000ff">int</span><span style="color: #000000"> i;
        </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; EVENTS_SIZE; ++<span style="color: #000000">i)
        {
            </span><span style="color: #0000ff">if</span>(connsets[i] !=<span style="color: #000000"> NULL)
            {
                </span><span style="color: #0000ff">int</span> fd = i; <span style="color: #008000">//</span><span style="color: #008000">fd</span>
                tcp_connection_t *pt = connsets[i]; <span style="color: #008000">//</span><span style="color: #008000">tcp conn</span>
                uint32_t <span style="color: #0000ff">event</span> = <span style="color: #800080">0</span><span style="color: #000000">;
                </span><span style="color: #0000ff">if</span>(buffer_is_readable(&amp;pt-&gt;<span style="color: #000000">buffer_))
                    </span><span style="color: #0000ff">event</span> |=<span style="color: #000000"> kWriteEvent;
                </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;pt-&gt;<span style="color: #000000">buffer_))
                    </span><span style="color: #0000ff">event</span> |=<span style="color: #000000"> kReadEvent;
                </span><span style="color: #008000">//</span><span style="color: #008000">重置监听事件</span>
                epoll_mod_fd(epollfd, fd, <span style="color: #0000ff">event</span><span style="color: #000000">);
            }
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">epoll监听fd</span>
        <span style="color: #0000ff">int</span> nready = epoll_wait(epollfd, events, <span style="color: #800080">1024</span>, <span style="color: #800080">5000</span><span style="color: #000000">);
        </span><span style="color: #0000ff">if</span>(nready == -<span style="color: #800080">1</span><span style="color: #000000">)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">epoll wait</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(nready == <span style="color: #800080">0</span><span style="color: #000000">)
        {
            printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">epoll timeout.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">处理fd</span>
        <span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; nready; ++<span style="color: #000000">i)
        {
            </span><span style="color: #0000ff">int</span> fd =<span style="color: #000000"> events[i].data.fd;
            uint32_t revents </span>=<span style="color: #000000"> events[i].events;
            </span><span style="color: #0000ff">if</span>(fd == listenfd) <span style="color: #008000">//</span><span style="color: #008000">处理listen fd</span>
<span style="color: #000000">            {
                </span><span style="color: #0000ff">if</span>(revents &amp;<span style="color: #000000"> kReadREvent)
                {
                    </span><span style="color: #008000">//</span><span style="color: #008000">建立连接</span>
                    <span style="color: #0000ff">int</span> peerfd = accept4(listenfd, NULL, NULL, SOCK_NONBLOCK |<span style="color: #000000"> SOCK_CLOEXEC);
                    </span><span style="color: #0000ff">if</span>(peerfd == -<span style="color: #800080">1</span><span style="color: #000000">)
                        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">accept4</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                    </span><span style="color: #008000">//</span><span style="color: #008000">新建tcp连接</span>
                    tcp_connection_t *pt = (tcp_connection_t*)malloc(<span style="color: #0000ff">sizeof</span><span style="color: #000000">(tcp_connection_t));
                    buffer_init(</span>&amp;pt-&gt;<span style="color: #000000">buffer_);
                    </span><span style="color: #008000">//</span><span style="color: #008000">将该tcp连接放入connsets</span>
                    connsets[peerfd] =<span style="color: #000000"> pt;
                    epoll_add_fd(epollfd, peerfd, </span><span style="color: #800080">0</span><span style="color: #000000">);
                }
            }
            </span><span style="color: #0000ff">else</span> <span style="color: #008000">//</span><span style="color: #008000">处理普通客户的fd</span>
<span style="color: #000000">            {
                </span><span style="color: #008000">//</span><span style="color: #008000">取出指针</span>
                tcp_connection_t *pt =<span style="color: #000000"> connsets[fd];
                assert(pt </span>!=<span style="color: #000000"> NULL);
                </span><span style="color: #0000ff">if</span>(revents &amp;<span style="color: #000000"> kReadREvent)
                {
                    </span><span style="color: #0000ff">if</span>(buffer_read(&amp;pt-&gt;buffer_, fd) == <span style="color: #800080">0</span><span style="color: #000000">)
                    {
                        </span><span style="color: #008000">//</span><span style="color: #008000">close</span>
<span style="color: #000000">                        epoll_del_fd(epollfd, fd);
                        close(fd);
                        free(pt);
                        connsets[fd] </span>=<span style="color: #000000"> NULL;
                        </span><span style="color: #0000ff">continue</span>; <span style="color: #008000">//</span><span style="color: #008000">继续下一次循环</span>
<span style="color: #000000">                    } 
                }

                </span><span style="color: #0000ff">if</span>(revents &amp;<span style="color: #000000"> kWriteREvent)
                {
                    buffer_write(</span>&amp;pt-&gt;<span style="color: #000000">buffer_, fd);
                }
            }
        }
    }

    close(listenfd);

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>&#160;</p>

<p>下文使用epoll的ET模式。</p>]]></description></item><item><title>Linux非阻塞IO（七）使用epoll重新实现客户端</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/27/4055057.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 27 Oct 2014 12:37:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/27/4055057.html</guid><description><![CDATA[<p>使用poll与epoll的区别主要在于：</p>  <blockquote>   <p>poll可以每次重新装填fd数组，但是epoll的fd是一开始就加入了，<font color="#ff0000">不可能每次都重新加入</font></p> </blockquote>  <p>于是采用这种策略：</p>  <blockquote>   <p>epoll除了listenfd一开始就监听read事件，其他的客户fd加入epoll时，监听的事件都为空。</p>    <p>然后<font color="#ff0000">在每次epoll_wait之前，使用epoll_ctl重新设置fd的监听事件</font>。</p> </blockquote>  <p>所以这部分的代码如下：</p>  <p>&#160;</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">//</span><span style="color: #008000">重新装填epoll事件</span>
        sockfd_event = <span style="color: #800080">0</span><span style="color: #000000">;
        stdin_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;
        stdout_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;
        </span><span style="color: #008000">//</span><span style="color: #008000">epoll无法每次都重新装填，所以给每个fd添加一个空事件</span>
        
        <span style="color: #0000ff">if</span>(buffer_is_readable(&amp;<span style="color: #000000">sendbuf))
        {
            sockfd_event </span>|=<span style="color: #000000"> kWriteEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;<span style="color: #000000">sendbuf))
        {
            stdin_event </span>|=<span style="color: #000000"> kReadEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_readable(&amp;<span style="color: #000000">recvbuf))
        {
            stdout_event </span>|=<span style="color: #000000"> kWriteEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;<span style="color: #000000">recvbuf))
        {
            sockfd_event </span>|=<span style="color: #000000"> kReadEvent;
        }

        epoll_mod_fd(epollfd, sockfd, sockfd_event);
        epoll_mod_fd(epollfd, STDIN_FILENO, stdin_event);
        epoll_mod_fd(epollfd, STDOUT_FILENO, stdout_event);</span></pre>
</div>

<p>理解了这部分代码，整理部分与poll基本一致：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">#define</span> _GNU_SOURCE<span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">sysutil.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">buffer.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;sys/epoll.h&gt;

<span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #008000">//</span><span style="color: #008000">创建client套接字</span>
    <span style="color: #0000ff">int</span> sockfd = tcp_client(<span style="color: #800080">0</span><span style="color: #000000">);
    </span><span style="color: #008000">//</span><span style="color: #008000">调用非阻塞connect函数</span>
    <span style="color: #0000ff">int</span> ret = nonblocking_connect(sockfd, <span style="color: #800000">&quot;</span><span style="color: #800000">localhost</span><span style="color: #800000">&quot;</span>, <span style="color: #800080">9981</span>, <span style="color: #800080">5000</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span>(ret == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        perror(</span><span style="color: #800000">&quot;</span><span style="color: #800000">Connect Timeout .</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        exit(EXIT_FAILURE);
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">将三个fd设置为Non-Blocking</span>
<span style="color: #000000">    activate_nonblock(sockfd);
    activate_nonblock(STDIN_FILENO);
    activate_nonblock(STDOUT_FILENO);


    buffer_t recvbuf; </span><span style="color: #008000">//</span><span style="color: #008000">sockfd -&gt; Buffer -&gt; stdout</span>
    buffer_t sendbuf; <span style="color: #008000">//</span><span style="color: #008000">stdin -&gt; Buffer -&gt; sockfd

    </span><span style="color: #008000">//</span><span style="color: #008000">初始化缓冲区</span>
    buffer_init(&amp;<span style="color: #000000">recvbuf);
    buffer_init(</span>&amp;<span style="color: #000000">sendbuf);


    </span><span style="color: #008000">//</span><span style="color: #008000">创建epoll</span>
    <span style="color: #0000ff">int</span> epollfd = epoll_create1(<span style="color: #800080">0</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span>(epollfd == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">create epoll</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    </span><span style="color: #0000ff">struct</span> epoll_event events[<span style="color: #800080">1024</span><span style="color: #000000">];

    uint32_t sockfd_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;
    uint32_t stdin_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;
    uint32_t stdout_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;

    epoll_add_fd(epollfd, sockfd, sockfd_event);
    epoll_add_fd(epollfd, STDIN_FILENO, stdin_event);
    epoll_add_fd(epollfd, STDOUT_FILENO, stdout_event);


    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">重新装填epoll事件</span>
        sockfd_event = <span style="color: #800080">0</span><span style="color: #000000">;
        stdin_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;
        stdout_event </span>= <span style="color: #800080">0</span><span style="color: #000000">;
        </span><span style="color: #008000">//</span><span style="color: #008000">epoll无法每次都重新装填，所以给每个fd添加一个空事件</span>
        
        <span style="color: #0000ff">if</span>(buffer_is_readable(&amp;<span style="color: #000000">sendbuf))
        {
            sockfd_event </span>|=<span style="color: #000000"> kWriteEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;<span style="color: #000000">sendbuf))
        {
            stdin_event </span>|=<span style="color: #000000"> kReadEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_readable(&amp;<span style="color: #000000">recvbuf))
        {
            stdout_event </span>|=<span style="color: #000000"> kWriteEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;<span style="color: #000000">recvbuf))
        {
            sockfd_event </span>|=<span style="color: #000000"> kReadEvent;
        }

        epoll_mod_fd(epollfd, sockfd, sockfd_event);
        epoll_mod_fd(epollfd, STDIN_FILENO, stdin_event);
        epoll_mod_fd(epollfd, STDOUT_FILENO, stdout_event);


        </span><span style="color: #008000">//</span><span style="color: #008000">监听fd数组</span>
        <span style="color: #0000ff">int</span> nready = epoll_wait(epollfd, events, <span style="color: #800080">1024</span>, <span style="color: #800080">5000</span><span style="color: #000000">);
        </span><span style="color: #0000ff">if</span>(nready == -<span style="color: #800080">1</span><span style="color: #000000">)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">epoll wait</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(nready == <span style="color: #800080">0</span><span style="color: #000000">)
        {
            printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">epoll timeout.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
        }
        </span><span style="color: #0000ff">else</span><span style="color: #000000">
        {
            </span><span style="color: #0000ff">int</span><span style="color: #000000"> i;
            </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; nready; ++<span style="color: #000000">i)
            {
                </span><span style="color: #0000ff">int</span> peerfd =<span style="color: #000000"> events[i].data.fd;
                </span><span style="color: #0000ff">int</span> revents =<span style="color: #000000"> events[i].events;
                </span><span style="color: #0000ff">if</span>(peerfd == sockfd &amp;&amp; revents &amp;<span style="color: #000000"> kReadREvent)
                {
                    </span><span style="color: #008000">//</span><span style="color: #008000">从sockfd接收数据到recvbuf</span>
                    <span style="color: #0000ff">if</span>(buffer_read(&amp;recvbuf, peerfd) == <span style="color: #800080">0</span><span style="color: #000000">)
                    {
                        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">server close.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                        exit(EXIT_SUCCESS);
                    } 
                }
                    
                </span><span style="color: #0000ff">if</span>(peerfd == sockfd &amp;&amp; revents &amp;<span style="color: #000000"> kWriteREvent)
                {
                    buffer_write(</span>&amp;sendbuf, peerfd); <span style="color: #008000">//</span><span style="color: #008000">将sendbuf中的数据写入sockfd</span>
<span style="color: #000000">                }

                </span><span style="color: #0000ff">if</span>(peerfd == STDIN_FILENO &amp;&amp; revents &amp;<span style="color: #000000"> kReadREvent)
                {
                    </span><span style="color: #008000">//</span><span style="color: #008000">从stdin接收数据写入sendbuf</span>
                    <span style="color: #0000ff">if</span>(buffer_read(&amp;sendbuf, peerfd) == <span style="color: #800080">0</span><span style="color: #000000">)
                    {
                        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">exit.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                        exit(EXIT_SUCCESS);
                    } 
                }

                </span><span style="color: #0000ff">if</span>(peerfd == STDOUT_FILENO &amp;&amp; revents &amp;<span style="color: #000000"> kWriteREvent)
                {
                    buffer_write(</span>&amp;recvbuf, peerfd); <span style="color: #008000">//</span><span style="color: #008000">将recvbuf中的数据输出至stdout</span>
<span style="color: #000000">                }
            }
        }

    }

}</span></pre>
</div>]]></description></item><item><title>Linux非阻塞IO（六）使用poll实现非阻塞的服务器端</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/27/4055033.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 27 Oct 2014 12:15:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/27/4055033.html</guid><description><![CDATA[<p>关于poll模型监听的事件以及返回事件，我们定义宏如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">#define</span> kReadEvent (POLLIN | POLLPRI)
<span style="color: #0000ff">#define</span> kWriteEvent (POLLOUT | POLLWRBAND)
<span style="color: #0000ff">#define</span> kReadREvent (POLLIN | POLLPRI | POLLRDHUP)
<span style="color: #0000ff">#define</span> kWriteREvent (POLLOUT)</pre>
</div>

<p>前面我们说明了，为什么非阻塞IO必须具备缓冲区。事实上，对于server而言，每条TCP连接应该具有两个缓冲区，一个用于输入，一个用于输出。</p>

<blockquote>
  <p>sockfd –&gt;&#160; <font color="#ff0000">InputBuffer</font> –&gt; 用户空间 –&gt; 处理数据 –&gt; 得到结果 –&gt; <font color="#ff0000">OutputBuffer</font> –&gt; sockfd</p>
</blockquote>

<p>但是<font color="#ff0000">本例仅仅是简单的回射服务</font>，收到数据立刻发出，所以我们只使用一个缓冲区。</p>

<p>对于每个TCP连接，我们对应这样的一个数据结构：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>typedef <span style="color: #0000ff">struct</span><span style="color: #000000">{
    buffer_t buffer_;
} tcp_connection_t; </span><span style="color: #008000">//</span><span style="color: #008000">表示一条TCP连接</span></pre>
</div>

<p>那么我们需要建立一个从fd到对应的tcp_connection_t的对应关系。我使用以下的数组：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>tcp_connection_t *connsets[EVENTS_SIZE]; <span style="color: #008000">//</span><span style="color: #008000">提供从fd到TCP连接的映射</span></pre>
</div>

<p>这个数组初始化为NULL，然后我使用fd作为下标，也就是说，当我需要处理某fd的时候，<font color="#ff0000"><strong>以该fd为下标</strong></font>就可以找到它相应的tcp_connection_t指针。<font color="#ff0000"><strong>这本质上是一种哈希表的思想</strong></font>。</p>

<p>使用tcp_connection_t的逻辑是：</p>

<blockquote>
  <p>每当accept一个新的连接，就动态创建一个新的tcp_connection_t，并且<font color="#ff0000"><strong>将其指针保存至以peerfd为下标的位置中</strong></font>。</p>
</blockquote>

<blockquote>
  <p>每当连接关闭，需要释放内存，同时重置指针为NULL。</p>
</blockquote>

<p>我将所有的代码全部写入main函数中，因为前面封装了buffer，代码的可读性已经提高，再加上我们的业务逻辑简单，进一步封装，反而降低可读性。</p>

<p>这里跟client有几处相同点：</p>

<blockquote>
  <p>仅当缓冲区有空闲空间时才监听read事件</p>
</blockquote>

<blockquote>
  <p>仅当缓冲区有数据时，才监听write事件</p>
</blockquote>

<p>所以我们每次进行poll调用前都需要将fd的监听事件重新装填。</p>

<p>server的代码整体框架如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">初始化poll</span>

<span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
{
    </span><span style="color: #008000">//</span><span style="color: #008000">重新装填fd数组

    </span><span style="color: #008000">//</span><span style="color: #008000">poll系统调用

    </span><span style="color: #008000">//</span><span style="color: #008000">依次处理每个fd的读写事件</span>
}</pre>
</div>

<p>所以完整的代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">#define</span> _GNU_SOURCE             /* See feature_test_macros(7) */<span style="color: #000000">
#include </span>&lt;sys/socket.h&gt;<span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">sysutil.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">buffer.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;assert.h&gt;

<span style="color: #0000ff">#define</span> EVENTS_SIZE 1024<span style="color: #000000">

typedef </span><span style="color: #0000ff">struct</span><span style="color: #000000">{
    buffer_t buffer_;
} tcp_connection_t; </span><span style="color: #008000">//</span><span style="color: #008000">表示一条TCP连接</span>
<span style="color: #000000">
tcp_connection_t </span>*connsets[EVENTS_SIZE]; <span style="color: #008000">//</span><span style="color: #008000">提供从fd到TCP连接的映射</span>

<span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #008000">//</span><span style="color: #008000">获取监听fd</span>
    <span style="color: #0000ff">int</span> listenfd = tcp_server(<span style="color: #800000">&quot;</span><span style="color: #800000">localhost</span><span style="color: #800000">&quot;</span>, <span style="color: #800080">9981</span><span style="color: #000000">);
    </span><span style="color: #008000">//</span><span style="color: #008000">将监听fd设置为非阻塞</span>
<span style="color: #000000">    activate_nonblock(listenfd);

    </span><span style="color: #008000">//</span><span style="color: #008000">初始化connsets</span>
    <span style="color: #0000ff">int</span><span style="color: #000000"> i;
    </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; EVENTS_SIZE; ++<span style="color: #000000">i)
    {
        connsets[i] </span>=<span style="color: #000000"> NULL;
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">初始化poll</span>
    <span style="color: #0000ff">struct</span><span style="color: #000000"> pollfd events[EVENTS_SIZE];
    </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; EVENTS_SIZE; ++<span style="color: #000000">i)
        events[i].fd </span>= -<span style="color: #800080">1</span><span style="color: #000000">;
    events[</span><span style="color: #800080">0</span>].fd =<span style="color: #000000"> listenfd;
    events[</span><span style="color: #800080">0</span>].events =<span style="color: #000000"> kReadEvent;
    </span><span style="color: #0000ff">int</span> maxi = <span style="color: #800080">0</span><span style="color: #000000">;

    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">重新装填events数组</span>
        <span style="color: #0000ff">int</span><span style="color: #000000"> i;
        </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">1</span>; i &lt; EVENTS_SIZE; ++<span style="color: #000000">i)
        {
            </span><span style="color: #0000ff">int</span> fd =<span style="color: #000000"> events[i].fd;
            events[i].events </span>= <span style="color: #800080">0</span>; <span style="color: #008000">//</span><span style="color: #008000">重置events</span>
            <span style="color: #0000ff">if</span>(fd == -<span style="color: #800080">1</span><span style="color: #000000">)
                </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
            assert(connsets[fd] </span>!=<span style="color: #000000"> NULL);
            
            </span><span style="color: #008000">//</span><span style="color: #008000">当Buffer中有数据可读时，才监听write事件</span>
            <span style="color: #0000ff">if</span>(buffer_is_readable(&amp;connsets[fd]-&gt;<span style="color: #000000">buffer_))
            {
                events[i].events </span>|=<span style="color: #000000"> kWriteEvent;
            }

            </span><span style="color: #008000">//</span><span style="color: #008000">当Buffer中有空闲空间时，才监听read事件</span>
            <span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;connsets[fd]-&gt;<span style="color: #000000">buffer_))
            {
                events[i].events </span>|=<span style="color: #000000"> kReadEvent;
            }

        }

        </span><span style="color: #008000">//</span><span style="color: #008000">poll调用</span>
        <span style="color: #0000ff">int</span> nready = poll(events, maxi + <span style="color: #800080">1</span>, <span style="color: #800080">5000</span><span style="color: #000000">);
        </span><span style="color: #0000ff">if</span>(nready == -<span style="color: #800080">1</span><span style="color: #000000">)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">poll</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(nready == <span style="color: #800080">0</span><span style="color: #000000">)
        {
            printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">poll timeout.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
        }

        
        </span><span style="color: #008000">//</span><span style="color: #008000">处理listenfd</span>
        <span style="color: #0000ff">if</span>(events[<span style="color: #800080">0</span>].revents &amp;<span style="color: #000000"> kReadEvent)
        {
            </span><span style="color: #008000">//</span><span style="color: #008000">接受一个新的客户fd</span>
            <span style="color: #0000ff">int</span> peerfd = accept4(listenfd, NULL, NULL, SOCK_NONBLOCK |<span style="color: #000000"> SOCK_CLOEXEC);
            </span><span style="color: #0000ff">if</span>(peerfd == -<span style="color: #800080">1</span><span style="color: #000000">)
                ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">accept4</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            </span><span style="color: #008000">//</span><span style="color: #008000">新建tcp连接</span>
            tcp_connection_t *pt = (tcp_connection_t*)malloc(<span style="color: #0000ff">sizeof</span><span style="color: #000000">(tcp_connection_t));
            buffer_init(</span>&amp;pt-&gt;<span style="color: #000000">buffer_);
            </span><span style="color: #008000">//</span><span style="color: #008000">将该tcp连接放入connsets</span>
            connsets[peerfd] =<span style="color: #000000"> pt;
            </span><span style="color: #008000">//</span><span style="color: #008000">放入events数组</span>
            <span style="color: #0000ff">int</span><span style="color: #000000"> i;
            </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; EVENTS_SIZE; ++<span style="color: #000000">i)
            {
                </span><span style="color: #0000ff">if</span>(events[i].fd == -<span style="color: #800080">1</span><span style="color: #000000">)
                {
                    events[i].fd </span>= peerfd; <span style="color: #008000">//</span><span style="color: #008000">这里不必监听fd</span>
                    <span style="color: #0000ff">if</span>(i &gt;<span style="color: #000000"> maxi)
                        maxi </span>= i; <span style="color: #008000">//</span><span style="color: #008000">更新maxi</span>
                    <span style="color: #0000ff">break</span><span style="color: #000000">;
                }
            }
            </span><span style="color: #0000ff">if</span>(i ==<span style="color: #000000"> EVENTS_SIZE)
            {
                fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">too many clients\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                exit(EXIT_FAILURE);
            }
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">处理客户fd
        </span><span style="color: #008000">//</span><span style="color: #008000">int i;</span>
        <span style="color: #0000ff">for</span>(i = <span style="color: #800080">1</span>; i &lt;= maxi; ++<span style="color: #000000">i)
        {
            </span><span style="color: #0000ff">int</span> sockfd =<span style="color: #000000"> events[i].fd;
            </span><span style="color: #0000ff">if</span>(sockfd == -<span style="color: #800080">1</span><span style="color: #000000">)
                </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
            </span><span style="color: #008000">//</span><span style="color: #008000">取出指针</span>
            tcp_connection_t *pt =<span style="color: #000000"> connsets[sockfd];
            assert(pt </span>!=<span style="color: #000000"> NULL);
            </span><span style="color: #0000ff">if</span>(events[i].revents &amp; kReadREvent) <span style="color: #008000">//</span><span style="color: #008000">读取数据</span>
<span style="color: #000000">            {
                </span><span style="color: #0000ff">if</span>(buffer_read(&amp;pt-&gt;buffer_, sockfd) == <span style="color: #800080">0</span><span style="color: #000000">)
                {
                    </span><span style="color: #008000">//</span><span style="color: #008000">close</span>
                    events[i].fd = -<span style="color: #800080">1</span><span style="color: #000000">;
                    close(sockfd);
                    free(pt);
                    connsets[sockfd] </span>=<span style="color: #000000"> NULL;
                    </span><span style="color: #0000ff">continue</span>; <span style="color: #008000">//</span><span style="color: #008000">继续下一次循环</span>
<span style="color: #000000">                } 
            }

            </span><span style="color: #0000ff">if</span>(events[i].revents &amp; kWriteREvent) <span style="color: #008000">//</span><span style="color: #008000">可以发送数据</span>
<span style="color: #000000">            {
                buffer_write(</span>&amp;pt-&gt;<span style="color: #000000">buffer_, sockfd);
            }
        }
    }

    close(listenfd);

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>需要注意的是，关于accept，我使用的是<font color="#ff0000">accpet4，这是Linux新增的系统调用</font>：</p>

<p>&#160;</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> accept4(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">struct</span> sockaddr *addr, socklen_t *addrlen, <span style="color: #0000ff">int</span> flags);</pre>
</div>

<p>与accept的区别就是accept4可以指定非阻塞标志位。</p>

<p>&#160;</p>

<p>下文使用epoll。</p>]]></description></item><item><title>Linux非阻塞IO（五）使用poll实现非阻塞的回射服务器客户端</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/24/4049211.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 24 Oct 2014 12:44:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/24/4049211.html</guid><description><![CDATA[<p>前面几节我们讨论了非阻塞IO的基本概念、Buffer的设计以及非阻塞connect的实现，现在我们使用它们来完成客户端的编写。</p>  <p>我们在<a title="http://www.cnblogs.com/inevermore/p/4049165.html" href="http://www.cnblogs.com/inevermore/p/4049165.html">http://www.cnblogs.com/inevermore/p/4049165.html</a>中提出过，客户端需要监听stdin、stdout和sockfd。</p>  <p>这里需要注意的是</p>  <blockquote>   <p>只有缓冲区可写的时候，才去监听sockfd和stdin的读事件。</p>    <p>过去在阻塞IO中，我们<font color="#ff0000">总是监听sockfd的读事件</font>，因为每当sockfd可读，我们就去调用用户的回调函数处理read事件，在回调函数中需要用户手工read缓冲区的数据。 换句话说，<font color="#ff0000">接收数据是用户的责任，poll模型只需要提醒用户去接收即可</font>。</p>    <p>而在非阻塞IO中，因为poll采用的是水平触发，如果缓冲区满了，每次read等于无效操作，那么数据始终<font color="#ff0000">堆积在内核中</font>，poll会不停的被触发。<font color="#ff0000"><strong>这在某种程度上等于轮询</strong></font>。所以我们只在缓冲区可用的情况下监听sockfd的读事件。</p> </blockquote>  <blockquote>   <p>只有缓冲区可读的时候，才去监听sockfd和stdout的写事件。因为没有数据可写，监听write事件除了不停的触发poll之外，没有实际意义。</p> </blockquote>  <p>所以每次执行poll之前，需要重新装填poll的events数组。</p>  <p>完整的代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">sysutil.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">buffer.h</span><span style="color: #800000">&quot;</span>

<span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #008000">//</span><span style="color: #008000">创建client套接字</span>
    <span style="color: #0000ff">int</span> sockfd = tcp_client(<span style="color: #800080">8934</span><span style="color: #000000">);
    </span><span style="color: #008000">//</span><span style="color: #008000">调用非阻塞connect函数</span>
    <span style="color: #0000ff">int</span> ret = nonblocking_connect(sockfd, <span style="color: #800000">&quot;</span><span style="color: #800000">192.168.44.136</span><span style="color: #800000">&quot;</span>, <span style="color: #800080">9981</span>, <span style="color: #800080">5000</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span>(ret == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">Timeout .\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        exit(EXIT_FAILURE);
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">将三个fd设置为Non-Blocking</span>
<span style="color: #000000">    activate_nonblock(sockfd);
    activate_nonblock(STDIN_FILENO);
    activate_nonblock(STDOUT_FILENO);


    buffer_t recvbuf; </span><span style="color: #008000">//</span><span style="color: #008000">sockfd -&gt; Buffer -&gt; stdout</span>
    buffer_t sendbuf; <span style="color: #008000">//</span><span style="color: #008000">stdin -&gt; Buffer -&gt; sockfd

    </span><span style="color: #008000">//</span><span style="color: #008000">初始化缓冲区</span>
    buffer_init(&amp;<span style="color: #000000">recvbuf);
    buffer_init(</span>&amp;<span style="color: #000000">sendbuf);

    </span><span style="color: #0000ff">struct</span> pollfd pfd[<span style="color: #800080">10</span><span style="color: #000000">];

    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">初始化</span>
        <span style="color: #0000ff">int</span><span style="color: #000000"> ix;
        </span><span style="color: #0000ff">for</span>(ix = <span style="color: #800080">0</span>; ix != <span style="color: #800080">3</span>; ++<span style="color: #000000">ix)
        {
            pfd[ix].fd </span>= -<span style="color: #800080">1</span><span style="color: #000000">;
            pfd[ix].events </span>= <span style="color: #800080">0</span><span style="color: #000000">;
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">重新装填events数组</span>
        <span style="color: #0000ff">if</span>(buffer_is_readable(&amp;<span style="color: #000000">sendbuf))
        {
            pfd[</span><span style="color: #800080">0</span>].fd =<span style="color: #000000"> sockfd;
            pfd[</span><span style="color: #800080">0</span>].events |=<span style="color: #000000"> kWriteEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;<span style="color: #000000">sendbuf))
        {
            pfd[</span><span style="color: #800080">1</span>].fd =<span style="color: #000000"> STDIN_FILENO;
            pfd[</span><span style="color: #800080">1</span>].events |=<span style="color: #000000"> kReadEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_readable(&amp;<span style="color: #000000">recvbuf))
        {
            pfd[</span><span style="color: #800080">2</span>].fd =<span style="color: #000000"> STDOUT_FILENO;
            pfd[</span><span style="color: #800080">2</span>].events |=<span style="color: #000000"> kWriteEvent;
        }
        </span><span style="color: #0000ff">if</span>(buffer_is_writeable(&amp;<span style="color: #000000">recvbuf))
        {
            pfd[</span><span style="color: #800080">0</span>].fd =<span style="color: #000000"> sockfd;
            pfd[</span><span style="color: #800080">0</span>].events |=<span style="color: #000000"> kReadEvent;
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">监听fd数组</span>
        <span style="color: #0000ff">int</span> nready = poll(pfd, <span style="color: #800080">3</span>, <span style="color: #800080">5000</span><span style="color: #000000">);
        </span><span style="color: #0000ff">if</span>(nready == -<span style="color: #800080">1</span><span style="color: #000000">)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">poll</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(nready == <span style="color: #800080">0</span><span style="color: #000000">)
        {
            printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">timeout\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
        }
        </span><span style="color: #0000ff">else</span><span style="color: #000000">
        {
            </span><span style="color: #0000ff">int</span><span style="color: #000000"> i;
            </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; <span style="color: #800080">3</span>; ++<span style="color: #000000">i)
            {
                </span><span style="color: #0000ff">int</span> fd =<span style="color: #000000"> pfd[i].fd;
                </span><span style="color: #0000ff">if</span>(fd == sockfd &amp;&amp; pfd[i].revents &amp;<span style="color: #000000"> kReadEvent)
                {
                    </span><span style="color: #008000">//</span><span style="color: #008000">从sockfd接收数据到recvbuf</span>
                    <span style="color: #0000ff">if</span>(buffer_read(&amp;recvbuf, fd) == <span style="color: #800080">0</span><span style="color: #000000">)
                    {
                        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">server close.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                        exit(EXIT_SUCCESS);
                    } 
                }
                    
                </span><span style="color: #0000ff">if</span>(fd == sockfd &amp;&amp; pfd[i].revents &amp;<span style="color: #000000"> kWriteEvent)
                    buffer_write(</span>&amp;sendbuf, fd); <span style="color: #008000">//</span><span style="color: #008000">将sendbuf中的数据写入sockfd</span>

                <span style="color: #0000ff">if</span>(fd == STDIN_FILENO &amp;&amp; pfd[i].revents &amp;<span style="color: #000000"> kReadEvent)
                {
                    </span><span style="color: #008000">//</span><span style="color: #008000">从stdin接收数据写入sendbuf</span>
                    <span style="color: #0000ff">if</span>(buffer_read(&amp;sendbuf, fd) == <span style="color: #800080">0</span><span style="color: #000000">)
                    {
                        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">exit.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
                        exit(EXIT_SUCCESS);
                    } 
                }

                </span><span style="color: #0000ff">if</span>(fd == STDOUT_FILENO &amp;&amp; pfd[i].revents &amp;<span style="color: #000000"> kWriteEvent)
                    buffer_write(</span>&amp;recvbuf, fd); <span style="color: #008000">//</span><span style="color: #008000">将recvbuf中的数据输出至stdout</span>
<span style="color: #000000">            }
        }
    }

}</span></pre>
</div>

<p>从以上的代码可以看出，大部分操作被封装进了buffer的实现中。</p>

<p>&#160;</p>

<p>测试服务器，我暂时使用muduo库编写一个，代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include &lt;muduo/net/TcpServer.h&gt;<span style="color: #000000">
#include </span>&lt;muduo/net/InetAddress.h&gt;<span style="color: #000000">
#include </span>&lt;muduo/net/TcpConnection.h&gt;<span style="color: #000000">
#include </span>&lt;muduo/<span style="color: #0000ff">base</span>/Timestamp.h&gt;<span style="color: #000000">
#include </span>&lt;muduo/net/EventLoop.h&gt;<span style="color: #000000">
#include </span>&lt;muduo/<span style="color: #0000ff">base</span>/Logging.h&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> muduo;
</span><span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> muduo::net;

</span><span style="color: #0000ff">void</span> onMessage(<span style="color: #0000ff">const</span> TcpConnectionPtr &amp;conn, Buffer *<span style="color: #000000">buf, Timestamp t)
{
    </span><span style="color: #0000ff">string</span> s(buf-&gt;<span style="color: #000000">retrieveAllAsString());
    LOG_INFO </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">recv msg : </span><span style="color: #800000">&quot;</span> &lt;&lt; s.size() &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000"> at: </span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> t.toFormattedString();
    conn</span>-&gt;<span style="color: #000000">send(s);
}

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    EventLoop loop;
    InetAddress addr(</span><span style="color: #800000">&quot;</span><span style="color: #800000">192.168.44.136</span><span style="color: #800000">&quot;</span>, <span style="color: #800080">9981</span><span style="color: #000000">);
    TcpServer server(</span>&amp;loop, addr, <span style="color: #800000">&quot;</span><span style="color: #800000">EchoServer</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    server.setMessageCallback(</span>&amp;<span style="color: #000000">onMessage);
    server.start();

    loop.loop();

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>读者如果使用上述的代码需要安装muduo网络库。</p>

<p>采用以下命令编译：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>g++ server.cpp  -lmuduo_net -lmuduo_base -lpthread -o server</pre>
</div>

<p>&#160;</p>

<p>下文用poll实现非阻塞的服务器端。</p>]]></description></item><item><title>Linux非阻塞IO（四）非阻塞IO中connect的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/24/4049165.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 24 Oct 2014 12:09:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/24/4049165.html</guid><description><![CDATA[<p>我们为客户端的编写再做一些工作。</p>  <p>这次我们使用非阻塞IO实现connect函数。</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">int</span> connect(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">const</span> <span style="color: #0000ff">struct</span> sockaddr *addr, socklen_t addrlen);</pre>
</div>

<p>非阻塞IO有以下用处：</p>

<blockquote>
  <p>1.将三次握手的处理过程生下来，处理其他事情。</p>

  <p>2.使用这个同时建立多个连接。</p>

  <p>3.实现超时connect功能，本节实现的connect就可以指定时间，超时后算作错误处理。</p>
</blockquote>

<p>&#160;</p>

<p>在阻塞IO中，调用connect后一般会阻塞，直到确定连接成功或者失败。</p>

<p>在Non-Blocking IO中，connect往往会立刻返回，此时connect就有两种结果。</p>

<blockquote>
  <p>一是连接成功</p>
</blockquote>

<blockquote>
  <p>二是返回-1，errno置为<font color="#ff0000">EINPROGRESS</font>，这种一般是因为网络延迟，所以连接不能马上建立，我们需要使用poll来监听sockfd。</p>
</blockquote>

<p>所以接下来我们需要<font color="#ff0000">向poll注册sockfd的写事件</font>。</p>

<p>《TCP/IP详解》第二卷指出以下的一些规则：</p>

<blockquote>
  <p>当连接建立时，sockfd可写。</p>
</blockquote>

<blockquote>
  <p><font color="#ff0000">当遇到错误时，sockfd既可读又可写</font>。</p>
</blockquote>

<p>我们设置一个超时时间，当poll返回时，如果sockfd可写，此时有两种情况：</p>

<blockquote>
  <p>一是连接确实建立成功</p>
</blockquote>

<blockquote>
  <p>二是连接发生错误</p>
</blockquote>

<p>我们<font color="#ff0000">需要某些手段辨别究竟是否发生了错误</font>。</p>

<p>这里我们采用socket选项，检测的是SO_ERROR，代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> get_sockfd_error(<span style="color: #0000ff">int</span><span style="color: #000000"> sockfd)
{
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> err;
    socklen_t socklen </span>= <span style="color: #0000ff">sizeof</span><span style="color: #000000">(err);
    </span><span style="color: #0000ff">if</span>(getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;socklen) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">getsock_error  error</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span> (err == <span style="color: #800080">0</span><span style="color: #000000">)
        </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span>; <span style="color: #008000">//</span><span style="color: #008000">无错误</span>
    <span style="color: #0000ff">else</span>
        <span style="color: #0000ff">return</span><span style="color: #000000"> err;
}</span></pre>
</div>

<p>如果sockfd无错误，则返回0，否则返回错误代码。</p>

<p>&#160;</p>

<p>在非阻塞connect的实现中，我们通常需要先把fd设置为非阻塞，最后再重新设置为阻塞。这样做，是<font color="#ff0000">为了满足阻塞与非阻塞的需求</font>。</p>

<p>因为在阻塞IO中，有时候也会使用非阻塞connect。</p>

<p>&#160;</p>

<p>实现代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> nonblocking_connect(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *des_host, uint16_t des_port, <span style="color: #0000ff">int</span><span style="color: #000000"> timeout)
{
    </span><span style="color: #0000ff">if</span>(des_host ==<span style="color: #000000"> NULL)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">des_host can not be NULL\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        exit(EXIT_FAILURE);
    }

    SAI servaddr;
    memset(</span>&amp;servaddr, <span style="color: #800080">0</span>, <span style="color: #0000ff">sizeof</span><span style="color: #000000"> servaddr);
    servaddr.sin_family </span>=<span style="color: #000000"> AF_INET;
    servaddr.sin_port </span>=<span style="color: #000000"> htons(des_port);
    </span><span style="color: #0000ff">if</span>(inet_aton(des_host, &amp;servaddr.sin_addr) == <span style="color: #800080">0</span><span style="color: #000000">)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">DNS
        </span><span style="color: #008000">//</span><span style="color: #008000">struct hostent *gethostbyname(const char *name);</span>
        <span style="color: #0000ff">struct</span> hostent *hp =<span style="color: #000000"> gethostbyname(des_host);
        </span><span style="color: #0000ff">if</span>(hp ==<span style="color: #000000"> NULL)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">gethostbyname</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        servaddr.sin_addr </span>= *(<span style="color: #0000ff">struct</span> in_addr*)hp-&gt;<span style="color: #000000">h_addr;
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">设置为非阻塞</span>
<span style="color: #000000">    activate_nonblock(sockfd); 

    </span><span style="color: #008000">//</span><span style="color: #008000">connect会立刻返回</span>
    <span style="color: #0000ff">int</span> ret = connect(sockfd, (SA*)&amp;servaddr, <span style="color: #0000ff">sizeof</span><span style="color: #000000"> servaddr);
    </span><span style="color: #0000ff">if</span>(ret == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #0000ff">if</span>(errno != EINPROGRESS) <span style="color: #008000">//</span><span style="color: #008000">连接失败</span>
            ERR_EXIT(<span style="color: #800000">&quot;</span><span style="color: #800000">connect error</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">struct</span> pollfd pfd[<span style="color: #800080">1</span><span style="color: #000000">];
        pfd[</span><span style="color: #800080">0</span>].fd =<span style="color: #000000"> sockfd;
        pfd[</span><span style="color: #800080">0</span>].events =<span style="color: #000000"> POLLOUT;

        ret </span>= poll(pfd, <span style="color: #800080">1</span><span style="color: #000000">, timeout);

        </span><span style="color: #0000ff">if</span>(ret == <span style="color: #800080">0</span><span style="color: #000000">)
        {
            errno </span>=<span style="color: #000000"> ETIMEDOUT;
            ret </span>= -<span style="color: #800080">1</span>; <span style="color: #008000">//</span><span style="color: #008000">连接超时，此时判定为失败</span>
<span style="color: #000000">        }
        </span><span style="color: #008000">//</span><span style="color: #008000">sockfd可写，此时需要检查套接字选项，查看是否发生错误</span>
        <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(ret == <span style="color: #800080">1</span> &amp;&amp; pfd[<span style="color: #800080">0</span>].revents &amp; (POLLOUT |<span style="color: #000000"> POLLWRBAND))
        {
            </span><span style="color: #0000ff">int</span><span style="color: #000000"> err;
            </span><span style="color: #008000">//</span><span style="color: #008000">检查sockfd错误</span>
            <span style="color: #0000ff">if</span>((err =<span style="color: #000000"> get_sockfd_error(sockfd)))
            {
                errno </span>=<span style="color: #000000"> err;
                </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
            }
        }
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">重新设置为阻塞</span>
<span style="color: #000000">    deactivate_nonblock(sockfd);
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> ret;
}</span></pre>
</div>

<p>&#160;</p>

<p>读者可以自行测试。</p>

<p>&#160;</p>

<p>下节使用非阻塞connect实现客户端。</p>]]></description></item><item><title>Linux非阻塞IO（三）非阻塞IO中缓冲区Buffer的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/24/4048472.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 24 Oct 2014 07:36:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/24/4048472.html</guid><description><![CDATA[<p>本文我们来实现回射服务器的Buffer。</p>  <p>&#160;</p>  <p><strong><font size="4">Buffer的实现</font></strong></p>  <p>&#160;</p>  <p>上节<font color="#ff0000">提到了非阻塞IO必须具备Buffer</font>。再次将Buffer的设计描述一下：</p>  <p><a href="http://images.cnitblog.com/blog/669654/201410/241535338248737.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="buffer1" border="0" alt="buffer1" src="http://images.cnitblog.com/blog/669654/201410/241535401216147.png" width="923" height="349" /></a></p>  <p>这里必须补充一点，<font color="#ff0000">writeIndex指向空闲空间的第一个位置。</font></p>  <p><font color="#000000">这里有<strong><font color="#ff0000">三个重要的不变式</font></strong>：</font></p>  <blockquote>   <p>1. 0 &lt;= readIndex &lt;= writeIndex &lt;= BUFFER_SIZE</p> </blockquote>  <blockquote>   <p>2. writeIndex – readIndex 为可以从buffer读取的字节数</p> </blockquote>  <blockquote>   <p>3. BUFFER_SIZE – writeIndex 为buffer还可以继续读取的字节数</p> </blockquote>  <blockquote>   <p>还有一点，数据读取完毕之后，要重置下标为0</p> </blockquote>  <p>根据我设计的这个示意图，我利用结构体封装了一个Buffer，如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef BUFFER_H_
</span><span style="color: #0000ff">#define</span> BUFFER_H_<span style="color: #000000">

#include </span>&lt;poll.h&gt;

<span style="color: #0000ff">#define</span> BUFFER_SIZE 1024<span style="color: #000000">

typedef </span><span style="color: #0000ff">struct</span><span style="color: #000000"> {
    </span><span style="color: #0000ff">char</span><span style="color: #000000"> buf_[BUFFER_SIZE];
    </span><span style="color: #0000ff">int</span> readIndex_; <span style="color: #008000">//</span><span style="color: #008000">读取数据</span>
    <span style="color: #0000ff">int</span> writeIndex_; <span style="color: #008000">//</span><span style="color: #008000">写入数据</span>
<span style="color: #000000">} buffer_t;

</span><span style="color: #0000ff">void</span> buffer_init(buffer_t *<span style="color: #000000">bt);
</span><span style="color: #0000ff">int</span> buffer_is_readable(buffer_t *<span style="color: #000000">bt);
</span><span style="color: #0000ff">int</span> buffer_is_writeable(buffer_t *<span style="color: #000000">bt);
</span><span style="color: #0000ff">int</span> buffer_read(buffer_t *bt, <span style="color: #0000ff">int</span><span style="color: #000000"> sockfd);
</span><span style="color: #0000ff">int</span> buffer_write(buffer_t *bt, <span style="color: #0000ff">int</span><span style="color: #000000"> sockfd);

</span><span style="color: #0000ff">#define</span> kReadEvent (POLLIN | POLLPRI)
<span style="color: #0000ff">#define</span> kWriteEvent (POLLOUT | POLLWRBAND)

<span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">BUFFER_H_</span></pre>
</div>

<p>这里的buffer先采用固定长度，后期可以改为动态数组。</p>

<p>下面我们来实现Buffer的每个函数。</p>

<p>第一个是初始化，内存清零，下标都设置为0即可。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> buffer_init(buffer_t *<span style="color: #000000">bt)
{
    memset(bt</span>-&gt;buf_, <span style="color: #800080">0</span>, <span style="color: #0000ff">sizeof</span>(bt-&gt;<span style="color: #000000">buf_));
    bt</span>-&gt;readIndex_ = <span style="color: #800080">0</span><span style="color: #000000">;
    bt</span>-&gt;writeIndex_ = <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>缓冲区是否可以读出数据，需要<font color="#ff0000">判断(writeIndex – readIndex)是否大于0</font></p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> buffer_is_readable(buffer_t *<span style="color: #000000">bt)
{
    </span><span style="color: #0000ff">return</span> bt-&gt;writeIndex_ &gt; bt-&gt;<span style="color: #000000">readIndex_;
}</span></pre>
</div>



<p>缓冲区是否可写，需要判断是否有空闲空间。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> buffer_is_writeable(buffer_t *<span style="color: #000000">bt)
{
    </span><span style="color: #0000ff">return</span> BUFFER_SIZE &gt; bt-&gt;<span style="color: #000000">writeIndex_;
}</span></pre>
</div>

<p>接下来是调用read函数，buffer从fd中读取数据，read的最后一个参数为buffer的剩余空间。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> buffer_read(buffer_t *bt, <span style="color: #0000ff">int</span><span style="color: #000000"> sockfd)
{
    </span><span style="color: #0000ff">int</span> nread = read(sockfd, &amp;bt-&gt;buf_[bt-&gt;writeIndex_], BUFFER_SIZE - bt-&gt;<span style="color: #000000">writeIndex_);
    </span><span style="color: #0000ff">if</span>(nread == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #0000ff">if</span>(errno !=<span style="color: #000000"> EWOULDBLOCK)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">read fd error</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
    }
    </span><span style="color: #0000ff">else</span><span style="color: #000000">
    {
        bt</span>-&gt;writeIndex_ +=<span style="color: #000000"> nread;
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> nread;
    }
}</span></pre>
</div>



<p>最后是输出操作，将buffer中的数据写入sockfd，write的最后一个参数为buffer现存的字节数。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> buffer_write(buffer_t *bt, <span style="color: #0000ff">int</span><span style="color: #000000"> sockfd)
{
    </span><span style="color: #0000ff">int</span> nwriten = write(sockfd, &amp;bt-&gt;buf_[bt-&gt;readIndex_], bt-&gt;writeIndex_ - bt-&gt;<span style="color: #000000">readIndex_);
    </span><span style="color: #0000ff">if</span>(nwriten == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        </span><span style="color: #0000ff">if</span>(errno !=<span style="color: #000000"> EWOULDBLOCK)
            ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">write fd error</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
    }
    </span><span style="color: #0000ff">else</span><span style="color: #000000">
    {
        bt</span>-&gt;readIndex_ +=<span style="color: #000000"> nwriten;
        </span><span style="color: #0000ff">if</span>(bt-&gt;readIndex_ == bt-&gt;<span style="color: #000000">writeIndex_)
        {
            bt</span>-&gt;readIndex_ = bt-&gt;writeIndex_ = <span style="color: #800080">0</span><span style="color: #000000">;
        }
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> nwriten;
    }
}</span></pre>
</div>

<p>&#160;</p>

<p>Buffer的实现完毕。</p>

<p>&#160;</p>

<p>下文开始编写回射服务器的客户端。</p>]]></description></item><item><title>Linux非阻塞IO（二）网络编程中非阻塞IO与IO复用模型结合</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/23/4046283.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 23 Oct 2014 09:05:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/23/4046283.html</guid><description><![CDATA[<p>上文描述了最简易的非阻塞IO，采用的是轮询的方式，这节我们使用IO复用模型。</p>  <p>&#160;</p>  <p><strong><font size="4">阻塞IO</font></strong></p>  <p>&#160;</p>  <p>过去我们使用IO复用与阻塞IO结合的时候，<font color="#ff0000">IO复用模型起到的作用是并发监听多个fd</font>。</p>  <p>以简单的回射服务器为例，我们只监听了某fd是否可读，一旦fd有数据，我们立刻read，然后将其write给对方。</p>  <p><font color="#ff0000">在阻塞IO里面，我们总是认为fd是可写的</font>。因为即使底层的IO缓冲区已满，稍微等待片刻即可。这与read卡在一个无数据的fd上是两种情况。<font color="#ff0000">所以从这个角度出发，是不需要监听fd的写事件的</font>。</p>  <p>总之，在阻塞IO中，收到数据然后write，这二者是同时使用的。</p>  <p>&#160;</p>  <p><strong><font size="4">非阻塞IO</font></strong></p>  <p>&#160;</p>  <p>到了非阻塞IO里面，事情就远远不是这么简单了。此时，IO绝不仅仅是并发监听fd。</p>  <p>因为在这种情况下，如果某fd的write缓冲区满了，write会立刻返回-1，并且返回EWOULDBLOCK。所以数据的收和发未必可以同时进行，所以对于write操作，我们需要一个buffer来暂存数据。当fd可写时，才可以写入数据。</p>  <p>对于read一端，同样需要一个buffer，原因是因为，在阻塞IO中，假设双方协定好处理分包问题，对方发过来一个len为4000，然后我们需要调用readn函数确保收到足够的4000字节，这其中由于网络的拥塞，readn内部可能需要调用多次read系统调用。所以这中间需要短暂的等待。</p>  <p>到了非阻塞IO中，无法再使用readn反复调用read，否则就变成了轮询操作。如果数据收不满咋办？需要暂存起来，放到一个buffer中，由用户手工处理信息。</p>  <p>综上，<font color="#ff0000"><strong>非阻塞IO的read和write端都需要buffer</strong></font>。</p>  <p>详细的叙述请参考muduo库作者陈硕的<a href="http://www.cnblogs.com/solstice/archive/2011/04/17/2018801.html" target="_blank">Muduo 设计与实现之一：Buffer 类的设计</a></p>  <p>&#160;</p>  <p><strong><font size="4">Buffer的设计</font></strong></p>  <p>&#160;</p>  <p>Buffer肯定要有输入和输出，所以我设计buffer的格式如下：</p>  <p><a href="http://images.cnitblog.com/blog/669654/201410/231704139022211.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="buffer1" border="0" alt="buffer1" src="http://images.cnitblog.com/blog/669654/201410/231704169499679.png" width="537" height="204" /></a></p>  <p>readindex表示要从Buffer中读取数据的起始位置。writeIndex则表示向Buffer中存放数据的起点。<font color="#ff0000">所以writeIndex – readIndex 是Buffer中数据的大小，而end – writeIndex 则表示Buffer中剩余的空间</font>。</p>  <p>注意，<font color="#ff0000">每当buffer中的数据读完时，我们便重置指针，readIndex = writeIndex = begin</font>。</p>  <p>&#160;</p>  <p><font size="4"><strong>使用非阻塞IO编写回射服务器的客户端</strong></font></p>  <p>&#160;</p>  <p>这里的逻辑是：用户从stdin输入数据，然后发给sockfd，随后从sockfd接收数据，输出给stdout。</p>  <p>所以这里我们要监听四次，stdin的读事件，sockfd的读和写事件，stdout的写事件。</p>  <p>注意这里需要两个buffer，<font color="#ff0000">因为存在两个数据流</font>：</p>  <blockquote>   <p>stdin&#160; -&gt; Buffer –&gt; sockfd</p> </blockquote>  <blockquote>   <p>sockfd –&gt; Buffer –&gt; stdout</p> </blockquote>  <p>所以我们用到两个缓冲区：</p>  <p>一个用于向sockfd发送数据。</p>  <p><a href="http://images.cnitblog.com/blog/669654/201410/231704192306549.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="buffer2" border="0" alt="buffer2" src="http://images.cnitblog.com/blog/669654/201410/231704220432791.png" width="659" height="247" /></a></p>  <p>一个用于从sockfd接收数据。</p>  <p><a href="http://images.cnitblog.com/blog/669654/201410/231704241995931.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="buffer3" border="0" alt="buffer3" src="http://images.cnitblog.com/blog/669654/201410/231704273553900.png" width="645" height="196" /></a></p>  <p>&#160;</p>  <p>后续将持续讲解Non-Blocking IO，直到完成完整的客户端和服务端。</p>  <p>未完待续。</p>]]></description></item><item><title>Linux下的非阻塞IO（一）</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/23/4045344.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 23 Oct 2014 03:27:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/23/4045344.html</guid><description><![CDATA[<p>非阻塞IO是相对于传统的阻塞IO而言的。</p>  <p>我们首先需要搞清楚，什么是阻塞IO。APUE指出，系统调用分为两类，低速系统调用和其他，<font color="#ff0000">其中低速系统调用是可能会使进程永远阻塞的一类系统调用</font>。但是与磁盘IO有关的系统调用是个例外。</p>  <p>我们以read和write为例，read函数读取stdin，如果是阻塞IO，那么：</p>  <blockquote>   <p>如果我们不输入数据，那么read函数会一直阻塞，一直到我们输入数据为止。</p> </blockquote>  <p>如果是非阻塞IO，那么：</p>  <blockquote>   <p>如果存在数据，读取然后返回，如果没有输入，那么直接返回-1，errno置为EAGAIN</p> </blockquote>  <p>我们用write做一个实验：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;stdio.h&gt;<span style="color: #000000">
#include </span>&lt;stdlib.h&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>.h&gt;<span style="color: #000000">
#include </span>&lt;unistd.h&gt;<span style="color: #000000">
#include </span>&lt;sys/types.h&gt;<span style="color: #000000">
#include </span>&lt;sys/stat.h&gt;<span style="color: #000000">
#include </span>&lt;fcntl.h&gt;<span style="color: #000000">
#include </span>&lt;sys/wait.h&gt;<span style="color: #000000">
#include </span>&lt;errno.h&gt;<span style="color: #000000">
#include </span>&lt;signal.h&gt;

<span style="color: #0000ff">char</span> buf[<span style="color: #800080">500000</span><span style="color: #000000">];

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> ntowrite, nwrite;

    ntowrite </span>= read(STDIN_FILENO, buf, <span style="color: #0000ff">sizeof</span><span style="color: #000000"> buf);
    fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">read %d bytes\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ntowrite);

    activate_nonblock(STDOUT_FILENO, O_NONBLOCK);

    </span><span style="color: #0000ff">char</span> *ptr =<span style="color: #000000"> buf;
    </span><span style="color: #0000ff">int</span> nleft = ntowrite; <span style="color: #008000">//</span><span style="color: #008000">剩余的字节数</span>
    <span style="color: #0000ff">while</span>(nleft &gt; <span style="color: #800080">0</span><span style="color: #000000">)
    {
        errno </span>= <span style="color: #800080">0</span><span style="color: #000000">;
        nwrite </span>=<span style="color: #000000"> write(STDOUT_FILENO, ptr, nleft);
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">nwrite = %d, errno = %d\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, nwrite, errno);

        </span><span style="color: #0000ff">if</span>(nwrite &gt; <span style="color: #800080">0</span><span style="color: #000000">)
        {
            ptr </span>+=<span style="color: #000000"> nwrite;
            nleft </span>-=<span style="color: #000000"> nwrite;
        }
    }

    deactivate_nonblock(STDOUT_FILENO);

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>该程序向标准输出写入500000个字节。</p>

<p>如果使用：
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre>./test &lt; test.mkv &gt; temp.file</pre>
  </div>
</p>

<p>那么输出结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>read 500000<span style="color: #000000"> bytes
nwrite </span>= 500000, errno = 0</pre>
</div>

<p>因为磁盘IO的速度较快，所以一次就可以写入，下面我们使用终端：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>./test &lt; test.mkv  2&gt; stderr.txt</pre>
</div>

<p>这行命令将500000的内容打印到屏幕上，同时将fprintf记录的信息通过标准错误流写入stderr.txt。</p>

<p>我们查看stderr.txt文件：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>read 500000<span style="color: #000000"> bytes
nwrite </span>= 12708, errno =<span style="color: #000000"> 0
nwrite </span>= -1, errno = 11<span style="color: #000000">
nwrite </span>= -1, errno = 11<span style="color: #000000">
nwrite </span>= -1, errno = 11<span style="color: #000000">
nwrite </span>= -1, errno = 11<span style="color: #000000">
nwrite </span>= -1, errno = 11<span style="color: #000000">
nwrite </span>= -1, errno = 11<span style="color: #000000">
nwrite </span>= 11687, errno =<span style="color: #000000"> 0
nwrite </span>= -1, errno = 11</pre>

  <pre>…………………………………………..</pre>

  <p>nwrite = -1, errno = 11
    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = -1, errno = 11

    <br />nwrite = 1786, errno = 0</p>
</div>

<p>采用命令统计了一下，总计read次数为15247次，其中返回-1次数为15203次，说明成功读取次数为44次。</p>

<p>上面例子中，这种采用非阻塞IO的方式称为“轮询”，显然这是一种低效的方式，非阻塞IO通常与IO复用模型结合使用。</p>

<p>&#160;</p>

<p>另外，将fd设置为阻塞和非阻塞的函数代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> activate_nonblock(<span style="color: #0000ff">int</span><span style="color: #000000"> fd)
{
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> ret;
    </span><span style="color: #0000ff">int</span> flags =<span style="color: #000000"> fcntl(fd, F_GETFL);
    </span><span style="color: #0000ff">if</span> (flags == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">fcntl</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    flags </span>|=<span style="color: #000000"> O_NONBLOCK;
    ret </span>=<span style="color: #000000"> fcntl(fd, F_SETFL, flags);
    </span><span style="color: #0000ff">if</span> (ret == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">fcntl</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
}


</span><span style="color: #0000ff">void</span> deactivate_nonblock(<span style="color: #0000ff">int</span><span style="color: #000000"> fd)
{
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> ret;
    </span><span style="color: #0000ff">int</span> flags =<span style="color: #000000"> fcntl(fd, F_GETFL);
    </span><span style="color: #0000ff">if</span> (flags == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">fcntl</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    flags </span>&amp;= ~<span style="color: #000000">O_NONBLOCK;
    ret </span>=<span style="color: #000000"> fcntl(fd, F_SETFL, flags);
    </span><span style="color: #0000ff">if</span> (ret == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">fcntl</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
}</span></pre>
</div>

<p>&#160;</p>

<p>未完待续。</p>]]></description></item><item><title>网络编程readn、writen和readline函数的编写</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/22/4044452.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 22 Oct 2014 14:11:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/22/4044452.html</guid><description><![CDATA[<p><strong><font size="4">readn</font></strong></p>  <p>&#160;</p>  <p>在Linux中，read的声明为：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>ssize_t read(<span style="color: #0000ff">int</span> fd, <span style="color: #0000ff">void</span> *buf, size_t count);</pre>
</div>

<p>它的返回值有以下情形：</p>

<blockquote>
  <p>1.大于0，代表成功读取的字节数</p>

  <p>2.等于0，代表读取到了EOF，一般是对方关闭了socket的写端或者直接close</p>

  <p>3.小于0，出现错误。</p>
</blockquote>



<p>我们编写一个readn函数，声明与read一致，但是，<font color="#ff0000"><strong>readn在未出错或者fd没有关闭的情况下，会读满count个字节</strong></font>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t readn(<span style="color: #0000ff">int</span> fd, <span style="color: #0000ff">void</span> *<span style="color: #000000">buf, size_t count)
{
    size_t nleft </span>= count;  <span style="color: #008000">//</span><span style="color: #008000">剩余的字节数</span>
    ssize_t nread; <span style="color: #008000">//</span><span style="color: #008000">用作返回值</span>
    <span style="color: #0000ff">char</span> *bufp = (<span style="color: #0000ff">char</span>*)buf; <span style="color: #008000">//</span><span style="color: #008000">缓冲区的偏移量</span>

    <span style="color: #0000ff">while</span>(nleft &gt; <span style="color: #800080">0</span><span style="color: #000000">)
    {
        nread </span>=<span style="color: #000000"> read(fd, bufp, nleft);
        </span><span style="color: #0000ff">if</span>(nread == -<span style="color: #800080">1</span><span style="color: #000000">)
        {
            </span><span style="color: #0000ff">if</span>(errno ==<span style="color: #000000"> EINTR)
                </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
            </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span>; <span style="color: #008000">//</span><span style="color: #008000"> ERROR</span>
<span style="color: #000000">        }
        </span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(nread == <span style="color: #800080">0</span>) <span style="color: #008000">//</span><span style="color: #008000">EOF</span>
            <span style="color: #0000ff">break</span><span style="color: #000000">;

        nleft </span>-=<span style="color: #000000"> nread;
        bufp </span>+=<span style="color: #000000"> nread;
    }

    </span><span style="color: #0000ff">return</span> (count -<span style="color: #000000"> nleft);
}</span></pre>
</div>

<p>readn的返回值含义如下：</p>

<blockquote>
  <p>1.小于0，出错</p>

  <p>2.等于0，对方关闭</p>

  <p>3.大于0，但是小于count，对方关闭</p>

  <p>4.count，代表读满count个字节</p>
</blockquote>

<p>&#160;</p>

<p><strong><font size="4">writen</font></strong></p>

<p>&#160;</p>

<p>write函数的声明如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t write(<span style="color: #0000ff">int</span> fd, <span style="color: #0000ff">const</span> <span style="color: #0000ff">void</span> *buf, size_t count);</pre>
</div>



<p>man手册中对write的返回值描述如下：</p>

<p>&#160;&#160;&#160;&#160;&#160;&#160; On success, the number of bytes written is returned (zero indicates nothing was&#160; writ‐
  <br />&#160;&#160;&#160;&#160;&#160;&#160; ten).&#160; On error, -1 is returned, and errno is set appropriately.</p>

<p>&#160;&#160;&#160;&#160;&#160;&#160; If&#160; count&#160; is&#160; zero and fd refers to a regular file, then write() may return a failure
  <br />&#160;&#160;&#160;&#160;&#160;&#160; status if one of the errors below is detected.&#160; If no errors are detected, 0&#160; will&#160; be

  <br />&#160;&#160;&#160;&#160;&#160;&#160; returned&#160; without&#160; causing any other effect.&#160; If count is zero and fd refers to a file

  <br />&#160;&#160;&#160;&#160;&#160;&#160; other than a regular file, the results are not specified.</p>

<p>解释如下：</p>

<blockquote>
  <p>成功时，返回成功写入的字节数，否则返回-1，并设置相应的errno。</p>

  <p>如果count为0，并且fd指向一个普通文件，那么当探测到错误时返回-1.如果没有错误发生，返回0，不会产生任何影响。</p>

  <p>如果count为0，并且fd指向的不是普通文件，那么结果未定义。</p>
</blockquote>

<p>我们不去追究write为0的情形。编写write如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t writen(<span style="color: #0000ff">int</span> fd, <span style="color: #0000ff">const</span> <span style="color: #0000ff">void</span> *<span style="color: #000000">buf, size_t count)
{
    size_t nleft </span>=<span style="color: #000000"> count;
    ssize_t nwrite;
    </span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *bufp = (<span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>*<span style="color: #000000">)buf;
    
    </span><span style="color: #0000ff">while</span>(nleft &gt; <span style="color: #800080">0</span><span style="color: #000000">)
    {
        nwrite </span>=<span style="color: #000000"> write(fd, bufp, nleft);
        </span><span style="color: #0000ff">if</span>(nwrite &lt;= <span style="color: #800080">0</span>) <span style="color: #008000">//</span><span style="color: #008000"> ERROR</span>
<span style="color: #000000">        {
            </span><span style="color: #0000ff">if</span>(nwrite == -<span style="color: #800080">1</span> &amp;&amp; errno ==<span style="color: #000000"> EINTR)
                </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
            </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
        }

        nleft </span>-=<span style="color: #000000"> nwrite;
        bufp </span>+=<span style="color: #000000"> nwrite;
    }
    
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> count;
}</span></pre>
</div>

<p>从代码中可以看出，<font color="#ff0000">writen要么写满count字节，要么失败</font>。</p>

<p>&#160;</p>

<p><strong><font size="4">readline</font></strong></p>

<p>&#160;</p>

<p>在网络编程中，很多协议是基于文本行的，例如HTTP和FTP，还有telnet，他们的消息每行都是以\r\n作为结束标志的。于是我们开发一个readline函数，声明如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t readline(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">void</span> *usrbuf, size_t maxlen)</pre>
</div>

<p>readline函数的语义是：</p>

<blockquote>
  <p>如果碰不到\n，那么读取maxlen-1个字节，最后一个位置补充\0。</p>

  <p>否则读取到\n，在后面加一个\0。如果中间遇到EOF，<font color="#ff0000">直接返回0，而不是已经读取的字节数</font>。</p>
</blockquote>

<p>我们先给出一种低效的实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t readline_slow(<span style="color: #0000ff">int</span> fd, <span style="color: #0000ff">void</span> *<span style="color: #000000">usrbuf, size_t maxlen)
{
    </span><span style="color: #0000ff">char</span> *bufp = usrbuf;  <span style="color: #008000">//</span><span style="color: #008000">记录缓冲区当前位置</span>
<span style="color: #000000">    ssize_t nread;
    size_t nleft </span>= maxlen - <span style="color: #800080">1</span>;  <span style="color: #008000">//</span><span style="color: #008000">留一个位置给 '\0'</span>
    <span style="color: #0000ff">char</span><span style="color: #000000"> c;
    </span><span style="color: #0000ff">while</span>(nleft &gt; <span style="color: #800080">0</span><span style="color: #000000">)
    {
        </span><span style="color: #0000ff">if</span>((nread = read(fd, &amp;c, <span style="color: #800080">1</span>)) &lt; <span style="color: #800080">0</span><span style="color: #000000">)
        {
            </span><span style="color: #0000ff">if</span>(errno ==<span style="color: #000000"> EINTR)
                </span><span style="color: #0000ff">continue</span><span style="color: #000000">;
            </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
        }</span><span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(nread == <span style="color: #800080">0</span>) <span style="color: #008000">//</span><span style="color: #008000"> EOF</span>
<span style="color: #000000">        {
            </span><span style="color: #0000ff">break</span><span style="color: #000000">;
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">普通字符</span>
        *bufp++ =<span style="color: #000000"> c;
        nleft</span>--<span style="color: #000000">;

        </span><span style="color: #0000ff">if</span>(c == <span style="color: #800000">'</span><span style="color: #800000">\n</span><span style="color: #800000">'</span><span style="color: #000000">)
            </span><span style="color: #0000ff">break</span><span style="color: #000000">;
    }
    </span>*bufp = <span style="color: #800000">'</span><span style="color: #800000">\0</span><span style="color: #800000">'</span><span style="color: #000000">;
    </span><span style="color: #0000ff">return</span> (maxlen - nleft - <span style="color: #800080">1</span><span style="color: #000000">);
}</span></pre>
</div>



<p>这个的思路很简单，每次读取一个字节，直到遇到换行符为止。</p>

<p>这种实现是低效的，因为每次读取一个字节，都要进行一次系统调用。</p>

<p>在网络编程中，还有一个函数叫做recv，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t recv(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">void</span> *buf, size_t len, <span style="color: #0000ff">int</span> flags);</pre>
</div>



<p>它相对于read，多了一个flags选项。</p>

<p>有一个选项为MSG_PEEK，描述如下：</p>

<p>This flag causes the receive operation to return data from the beginning of the
  <br />receive queue without removing that data from the queue.&#160;&#160; Thus,&#160; a&#160; subsequent

  <br />receive call will return the same data.</p>

<p>大致意思是它从内核中读取数据，但并不会将数据移除，所以<font color="#ff0000">这个flag起到了一个预览内核数据的作用</font>。这样我们就可以先从内核中读取一大块数据，检查其中是否存在\n，如果不存在，这么将这些数据全部读取，如果存在，则读取到\n为止。</p>

<p>我们先实现recv_peek函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t recv_peek(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">void</span> *<span style="color: #000000">buf, size_t len)
{
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> nread;
    </span><span style="color: #0000ff">do</span><span style="color: #000000">
    {
        nread </span>=<span style="color: #000000"> recv(sockfd, buf, len, MSG_PEEK);
    }
    </span><span style="color: #0000ff">while</span>(nread == -<span style="color: #800080">1</span> &amp;&amp; errno ==<span style="color: #000000"> EINTR);

    </span><span style="color: #0000ff">return</span><span style="color: #000000"> nread;
}</span></pre>
</div>



<p>readline函数的实现如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ssize_t readline(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">void</span> *<span style="color: #000000">usrbuf, size_t maxlen)
{
    </span><span style="color: #008000">//
</span>    size_t nleft = maxlen - <span style="color: #800080">1</span><span style="color: #000000">;
    </span><span style="color: #0000ff">char</span> *bufp = usrbuf; <span style="color: #008000">//</span><span style="color: #008000">缓冲区位置</span>
    size_t total = <span style="color: #800080">0</span>; <span style="color: #008000">//</span><span style="color: #008000">读取的字节数</span>
<span style="color: #000000">
    ssize_t nread;
    </span><span style="color: #0000ff">while</span>(nleft &gt; <span style="color: #800080">0</span><span style="color: #000000">)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">预读取</span>
        nread =<span style="color: #000000"> recv_peek(sockfd, bufp, nleft);
        </span><span style="color: #0000ff">if</span>(nread &lt;= <span style="color: #800080">0</span><span style="color: #000000">)
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> nread;

        </span><span style="color: #008000">//</span><span style="color: #008000">检查\n</span>
        <span style="color: #0000ff">int</span><span style="color: #000000"> i;
        </span><span style="color: #0000ff">for</span>(i = <span style="color: #800080">0</span>; i &lt; nread; ++<span style="color: #000000">i)
        {
            </span><span style="color: #0000ff">if</span>(bufp[i] == <span style="color: #800000">'</span><span style="color: #800000">\n</span><span style="color: #800000">'</span><span style="color: #000000">)
            {
                </span><span style="color: #008000">//</span><span style="color: #008000">找到\n</span>
                size_t nsize = i+<span style="color: #800080">1</span><span style="color: #000000">;
                </span><span style="color: #0000ff">if</span>(readn(sockfd, bufp, nsize) !=<span style="color: #000000"> nsize)
                    </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
                bufp </span>+=<span style="color: #000000"> nsize;
                total </span>+=<span style="color: #000000"> nsize;
                </span>*bufp = <span style="color: #800080">0</span><span style="color: #000000">;
                </span><span style="color: #0000ff">return</span><span style="color: #000000"> total;
            }
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">没找到\n</span>
        <span style="color: #0000ff">if</span>(readn(sockfd, bufp, nread) !=<span style="color: #000000"> nread)
            </span><span style="color: #0000ff">return</span> -<span style="color: #800080">1</span><span style="color: #000000">;
        bufp </span>+=<span style="color: #000000"> nread;
        total </span>+=<span style="color: #000000"> nread;
        nleft </span>-=<span style="color: #000000"> nread;
    }
    </span>*bufp = <span style="color: #800080">0</span><span style="color: #000000">;
    </span><span style="color: #0000ff">return</span> maxlen - <span style="color: #800080">1</span><span style="color: #000000">;
}</span></pre>
</div>

<p>&#160;</p>

<p>我们编写的这三个函数后面可以用于处理TCP分包问题，后面写文章叙述。</p>]]></description></item><item><title>Linux网络编程中tcp_server和tcp_client函数的封装</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/22/4044389.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 22 Oct 2014 13:31:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/22/4044389.html</guid><description><![CDATA[<p>本文的主要目的是将server套接字和client套接字的获取，做一个简易的封装，使用C语言完成。</p>  <p>&#160;</p>  <p><font size="4"><strong>tcp_server</strong></font></p>  <p>&#160;</p>  <p>服务器端fd的获取主要分为以下几步：</p>  <blockquote>   <p>1.创建socket，这一步仅仅创建一个socket，没有任何特性的属性。</p> </blockquote>  <blockquote>   <p>2.绑定网卡和port，一块主机可能有多块网卡，如果我们使用INADDR_ANY，<font color="#ff0000">意味着后面接受的TCP连接可以绑定在任意一块网卡上</font>。</p>    <p>例如某台主机的ip地址有两个：192.168.44.136、10.1.1.4，假设绑定的ip采用INADDR_ANY，端口采用9981，那么当接收一个TCP连接时，可能存在192.168.44.136:9981/10.1.1.4:9981/127.0.0.1:9981三种可能性。</p>    <p>如果我们绑定192.168.44.136，那么这个fd接收的连接都是在这个ip上。</p>    <p>有一处特殊的地方，如果主机绑定的是127.0.0.1，那么客户端也必须是本机上的进程。（为什么？）</p> </blockquote>  <blockquote>   <p>3.监听端口listen，实际上从这一步开始接收TCP连接。<font color="#ff0000">listen函数的第二个参数表示TCP待接受队列的大小</font>，这个队列存储了已经完成三次握手，但还未被accept的连接。如果你设置为3，然后开启4个client，但是server端不进行accept，通过netstat –an | grep 9981，可以查看到只有三条server端的连接处于ESTABLISHED状态，其余的一个处于SYN_RCVD状态。</p>    <p>所以，很多人误以为accept完成三次握手，这是一种错误的想法，三次握手是由底层的协议栈完成的。</p> </blockquote>  <p>然后我们需要使用几个套接字选项，后面会专门写一篇文章总结套接字选项：</p>  <p>1.地址复用SO_REUSEADDR，代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">//</span><span style="color: #008000">地址复用</span>
<span style="color: #0000ff">void</span> set_reuseaddr(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">int</span><span style="color: #000000"> optval)
{
    </span><span style="color: #0000ff">int</span> on = (optval != <span style="color: #800080">0</span>) ? <span style="color: #800080">1</span> : <span style="color: #800080">0</span><span style="color: #000000">;
    </span><span style="color: #0000ff">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span style="color: #0000ff">sizeof</span>(on)) &lt; <span style="color: #800080">0</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">setsockopt SO_REUSEADDR</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
}</span></pre>
</div>

<p>2.端口复用SO_REUSEPORT，有的机器不支持，所以需要判断</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> set_reuseport(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">int</span><span style="color: #000000"> optval)
{
#ifdef SO_REUSEPORT
    </span><span style="color: #0000ff">int</span> on = (optval != <span style="color: #800080">0</span>) ? <span style="color: #800080">1</span> : <span style="color: #800080">0</span><span style="color: #000000">;
    </span><span style="color: #0000ff">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;on, <span style="color: #0000ff">sizeof</span>(on)) &lt; <span style="color: #800080">0</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">setsockopt SO_REUSEPORT</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #0000ff">#else</span><span style="color: #000000">
    fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">SO_REUSEPORT is not supported.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">SO_REUSEPORT</span><span style="color: #000000">
}</span></pre>
</div>

<p>3.禁用Nagle算法，降低局域网的延迟</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">设置nagle算法是否可用</span>
<span style="color: #0000ff">void</span> set_tcpnodelay(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">int</span><span style="color: #000000"> optval)
{
    </span><span style="color: #0000ff">int</span> on = (optval != <span style="color: #800080">0</span>) ? <span style="color: #800080">1</span> : <span style="color: #800080">0</span><span style="color: #000000">;
    </span><span style="color: #0000ff">if</span>(setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;on, <span style="color: #0000ff">sizeof</span>(on)) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">setsockopt TCP_NODELAY</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
}</span></pre>
</div>

<p>4.禁用keepAlive机制</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> set_keepalive(<span style="color: #0000ff">int</span> sockfd, <span style="color: #0000ff">int</span><span style="color: #000000"> optval)
{
    </span><span style="color: #0000ff">int</span> on = (optval != <span style="color: #800080">0</span>) ? <span style="color: #800080">1</span> : <span style="color: #800080">0</span><span style="color: #000000">;
    </span><span style="color: #0000ff">if</span>(setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;on, <span style="color: #0000ff">sizeof</span>(on)) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">setsockopt SO_KEEPALIVE</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
}</span></pre>
</div>

<p>&#160;</p>

<p>我们还需要为我们的tcp_server增加域名解析功能，我们可以绑定”localhost”之类的主机名，而不仅仅是ip地址，所以我们可能使用gethostbyname。</p>

<p>所以tcp_server代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> tcp_server(<span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">host, uint16_t port)
{

    </span><span style="color: #008000">//</span><span style="color: #008000">处理SIGPIPE信号</span>
<span style="color: #000000">    handle_sigpipe();

    </span><span style="color: #0000ff">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span style="color: #800080">0</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span>(listenfd == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">socket</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    set_reuseaddr(listenfd, </span><span style="color: #800080">1</span><span style="color: #000000">);
    set_reuseport(listenfd, </span><span style="color: #800080">1</span><span style="color: #000000">);
    set_tcpnodelay(listenfd, </span><span style="color: #800080">0</span><span style="color: #000000">);
    set_keepalive(listenfd, </span><span style="color: #800080">0</span><span style="color: #000000">);

    SAI addr;
    memset(</span>&amp;addr, <span style="color: #800080">0</span>, <span style="color: #0000ff">sizeof</span><span style="color: #000000"> addr);
    addr.sin_family </span>=<span style="color: #000000"> AF_INET;
    </span><span style="color: #008000">//</span><span style="color: #008000">addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span>
    addr.sin_port =<span style="color: #000000"> htons(port);
    </span><span style="color: #0000ff">if</span>(host ==<span style="color: #000000"> NULL)
    {
        addr.sin_addr.s_addr </span>=<span style="color: #000000"> INADDR_ANY;
    }
    </span><span style="color: #0000ff">else</span><span style="color: #000000">
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">int inet_aton(const char *cp, struct in_addr *inp);</span>
        <span style="color: #0000ff">if</span>(inet_aton(host, &amp;addr.sin_addr) == <span style="color: #800080">0</span><span style="color: #000000">)
        {
            </span><span style="color: #008000">//</span><span style="color: #008000">DNS
            </span><span style="color: #008000">//</span><span style="color: #008000">struct hostent *gethostbyname(const char *name);</span>
            <span style="color: #0000ff">struct</span> hostent *hp =<span style="color: #000000"> gethostbyname(host);
            </span><span style="color: #0000ff">if</span>(hp ==<span style="color: #000000"> NULL)
                ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">gethostbyname</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            addr.sin_addr </span>= *(<span style="color: #0000ff">struct</span> in_addr*)hp-&gt;<span style="color: #000000">h_addr;
        }
    }

    </span><span style="color: #0000ff">if</span>(bind(listenfd, (SA*)&amp;addr, <span style="color: #0000ff">sizeof</span> addr) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bind</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #0000ff">if</span>(listen(listenfd, SOMAXCONN) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">listen</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #0000ff">return</span><span style="color: #000000"> listenfd;
}</span></pre>
</div>

<p>&#160;</p>

<p><font size="4"><strong>tcp_client</strong></font></p>

<p>&#160;</p>

<p><font color="#ff0000">客户端也可以绑定port</font>，只不过它不是必须的。代码较简单，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span><span style="color: #000000"> tcp_client(uint16_t port)
{
    </span><span style="color: #0000ff">int</span> peerfd = socket(PF_INET, SOCK_STREAM, <span style="color: #800080">0</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span>(peerfd == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">socket</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    set_reuseaddr(peerfd, </span><span style="color: #800080">1</span><span style="color: #000000">);
    set_reuseport(peerfd, </span><span style="color: #800080">1</span><span style="color: #000000">);
    set_keepalive(peerfd, </span><span style="color: #800080">0</span><span style="color: #000000">);
    set_tcpnodelay(peerfd, </span><span style="color: #800080">0</span><span style="color: #000000">);

    </span><span style="color: #008000">//</span><span style="color: #008000">如果port为0，则不去绑定</span>
    <span style="color: #0000ff">if</span>(port == <span style="color: #800080">0</span><span style="color: #000000">)
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> peerfd;

    SAI addr;
    memset(</span>&amp;addr, <span style="color: #800080">0</span>, <span style="color: #0000ff">sizeof</span><span style="color: #000000"> addr);
    addr.sin_family </span>=<span style="color: #000000"> AF_INET;
    addr.sin_port </span>=<span style="color: #000000"> htons(port);
    addr.sin_addr.s_addr </span>=<span style="color: #000000"> inet_addr(get_local_ip());
    </span><span style="color: #0000ff">if</span>(bind(peerfd, (SA*)&amp;addr, <span style="color: #0000ff">sizeof</span>(addr)) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bind client</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #0000ff">return</span><span style="color: #000000"> peerfd;
}</span></pre>
</div>

<p>上面需要获取本机的ip地址，代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">get_local_ip()
{
    </span><span style="color: #0000ff">static</span> <span style="color: #0000ff">char</span> ip[<span style="color: #800080">16</span><span style="color: #000000">];

    </span><span style="color: #0000ff">int</span><span style="color: #000000"> sockfd;
    </span><span style="color: #0000ff">if</span>((sockfd = socket(PF_INET, SOCK_STREAM, <span style="color: #800080">0</span>)) == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">socket</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    }

    </span><span style="color: #0000ff">struct</span><span style="color: #000000"> ifreq req;
    bzero(</span>&amp;req, <span style="color: #0000ff">sizeof</span>(<span style="color: #0000ff">struct</span><span style="color: #000000"> ifreq));
    strcpy(req.ifr_name, </span><span style="color: #800000">&quot;</span><span style="color: #800000">eth0</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    </span><span style="color: #0000ff">if</span>(ioctl(sockfd, SIOCGIFADDR, &amp;req) == -<span style="color: #800080">1</span><span style="color: #000000">)
        ERR_EXIT(</span><span style="color: #800000">&quot;</span><span style="color: #800000">ioctl</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #0000ff">struct</span> sockaddr_in *host = (<span style="color: #0000ff">struct</span> sockaddr_in*)&amp;<span style="color: #000000">req.ifr_addr;
    strcpy(ip, inet_ntoa(host</span>-&gt;<span style="color: #000000">sin_addr));
    close(sockfd);
    
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> ip;
}</span></pre>
</div>

<p>&#160;</p>

<p>完毕。</p>]]></description></item><item><title>使用C++11封装线程池ThreadPool</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/20/4038698.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 20 Oct 2014 12:56:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/20/4038698.html</guid><description><![CDATA[<p>读本文之前，请务必阅读：</p>  <p><a href="http://www.cnblogs.com/inevermore/p/4038498.html" target="_blank">使用C++11的function/bind组件封装Thread以及回调函数的使用</a></p>  <p><a href="http://www.cnblogs.com/inevermore/p/4009719.html" target="_blank">Linux组件封装（五）一个生产者消费者问题示例</a></p>  <p>&#160;</p>  <p>线程池本质上是一个生产者消费者模型，所以请熟悉这篇文章：<a href="http://www.cnblogs.com/inevermore/p/4009719.html" target="_blank">Linux组件封装（五）一个生产者消费者问题示例</a>。</p>  <p>在ThreadPool中，物品为计算任务，消费者为pool内的线程，而生产者则是调用线程池的每个函数。</p>  <p>搞清了这一点，我们很容易就需要得出，<strong><font color="#ff0000">ThreadPool需要一把互斥锁和两个同步变量，实现同步与互斥</font></strong>。</p>  <p>存储任务，当然需要一个任务队列。</p>  <p>除此之外，我们还需要一系列的Thread，因为Thread无法复制，所以<font color="#ff0000">我们使用unique_ptr作为一个中间层</font>。</p>  <p>所以Thread的数据变量如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">class</span><span style="color: #000000"> ThreadPool : boost::noncopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef std::function</span>&lt;<span style="color: #0000ff">void</span> ()&gt;<span style="color: #000000"> Task;

    ThreadPool(size_t queueSize, size_t threadsNum);
    </span>~<span style="color: #000000">ThreadPool();

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> start();
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> stop();

    </span><span style="color: #0000ff">void</span> addTask(Task task); <span style="color: #008000">//</span><span style="color: #008000">C++11</span>
<span style="color: #000000">    Task getTask();

    </span><span style="color: #0000ff">bool</span> isStarted() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> isStarted_; }

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> runInThread();

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    mutable MutexLock mutex_;
    Condition empty_;
    Condition full_;

    size_t queueSize_;
    std::queue</span>&lt;Task&gt;<span style="color: #000000"> queue_;

    </span><span style="color: #0000ff">const</span><span style="color: #000000"> size_t threadsNum_;
    std::vector</span>&lt;std::unique_ptr&lt;Thread&gt; &gt;<span style="color: #000000"> threads_;
    </span><span style="color: #0000ff">bool</span><span style="color: #000000"> isStarted_;
};</span></pre>
</div>

<p>显然，我们使用了function，作为任务队列的任务元素。</p>

<p>&#160;</p>

<p>构造函数的实现较简单，不过，之前务必注意元素的声明顺序与初始化列表的顺序相一致。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">ThreadPool::ThreadPool(size_t queueSize, size_t threadsNum)
: empty_(mutex_),
  full_(mutex_),
  queueSize_(queueSize),
  threadsNum_(threadsNum),
  isStarted_(</span><span style="color: #0000ff">false</span><span style="color: #000000">)
{

}</span></pre>
</div>

<p>添加和取走任务是生产者消费者模型最核心的部分，但是套路较为固定，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> ThreadPool::addTask(Task task)
{
    MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
    </span><span style="color: #0000ff">while</span>(queue_.size() &gt;=<span style="color: #000000"> queueSize_)
        empty_.wait();
    queue_.push(std::move(task));
    full_.notify();
}


ThreadPool::Task ThreadPool::getTask()
{
    MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
    </span><span style="color: #0000ff">while</span><span style="color: #000000">(queue_.empty())
        full_.wait();
    Task task </span>=<span style="color: #000000"> queue_.front();
    queue_.pop();
    empty_.notify();
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> task;
}</span></pre>
</div>

<p>注意我们的addTask使用了C++11的move语义，在传入右值时，可以提高性能。</p>

<p>还有一些老生常谈的问题，例如：</p>

<blockquote>
  <p>wait前加锁</p>

  <p>使用while循环判断wait条件（为什么？）</p>
</blockquote>

<p>要想启动线程，需要给Thread提供一个回调函数，编写如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> ThreadPool::runInThread()
{
    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        Task task(getTask());
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(task)
            task();
    }
}</span></pre>
</div>

<p>就是不停的取走任务，然后执行。</p>

<p>OK，有了线程的回调函数，那么我们可以编写start函数。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> ThreadPool::start()
{
    isStarted_ </span>= <span style="color: #0000ff">true</span><span style="color: #000000">;
    </span><span style="color: #008000">//</span><span style="color: #008000">std::vector&lt;std::unique&lt;Thread&gt; &gt;</span>
    <span style="color: #0000ff">for</span>(size_t ix = <span style="color: #800080">0</span>; ix != threadsNum_; ++<span style="color: #000000">ix)
    {
        threads_.push_back(
            std::unique_ptr</span>&lt;Thread&gt;<span style="color: #000000">(
                </span><span style="color: #0000ff">new</span><span style="color: #000000"> Thread(
                    std::bind(</span>&amp;ThreadPool::runInThread, <span style="color: #0000ff">this</span><span style="color: #000000">))));
    }
    </span><span style="color: #0000ff">for</span>(size_t ix = <span style="color: #800080">0</span>; ix != threadsNum_; ++<span style="color: #000000">ix)
    {
        threads_[ix]</span>-&gt;<span style="color: #000000">start();
    }

}</span></pre>
</div>

<p>这里较难理解的是线程的创建，Thread内存放的是std::unique_ptr&lt;Thread&gt;，而ptr的创建需要使用new动态创建Thread，Thread则需要在创建时，传入回调函数，我们采用bind适配runInThread的参数值。</p>

<p><font color="#ff0000"><strong>这里我们采用C++11的unique_ptr，成功实现vector无法存储Thread（为什么？）的问题</strong></font>。</p>

<p>&#160;</p>

<p>我们的第一个版本已经编写完毕了。</p>

<p>&#160;</p>

<p><strong><font size="3">添加stop功能</font></strong></p>

<p>&#160;</p>

<p>刚才的ThreadPool只能启动，无法stop，我们从几个方面着手，利用bool变量isStarted_，实现正确退出。</p>

<p>改动的有以下几点：</p>

<p>首先是Thread的回调函数不再是一个死循环，而是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> ThreadPool::runInThread()
{
    </span><span style="color: #0000ff">while</span><span style="color: #000000">(isStarted_)
    {
        Task task(getTask());
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(task)
            task();
    }
}</span></pre>
</div>



<p>然后addTask和getTask，在while循环判断时，加入了bool变量：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> ThreadPool::addTask(Task task)
{</span><span style="color: #000000">
    MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
    </span><span style="color: #0000ff">while</span>(queue_.size() &gt;= queueSize_ &amp;&amp;<span style="color: #000000"> isStarted_)
        empty_.wait();

    </span><span style="color: #0000ff">if</span>(!<span style="color: #000000">isStarted_)
        </span><span style="color: #0000ff">return</span><span style="color: #000000">;

    queue_.push(std::move(task));
    full_.notify();
}


ThreadPool::Task ThreadPool::getTask()
{
    MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
    </span><span style="color: #0000ff">while</span>(queue_.empty() &amp;&amp;<span style="color: #000000"> isStarted_)
        full_.wait();

    </span><span style="color: #0000ff">if</span>(!isStarted_) <span style="color: #008000">//</span><span style="color: #008000">线程池关闭</span>
        <span style="color: #0000ff">return</span> Task(); <span style="color: #008000">//</span><span style="color: #008000">空任务</span>
<span style="color: #000000">
    assert(</span>!<span style="color: #000000">queue_.empty());
    Task task </span>=<span style="color: #000000"> queue_.front();
    queue_.pop();
    empty_.notify();
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> task;
}</span></pre>
</div>

<p>这里注意，退出while循环后，需要再判断一次bool变量，因为未必是条件满足了，可能是线程池需要退出，调整了isStarted变量。</p>

<p>最后一个关键是我们的stop函数：</p>

<p>&#160;</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> ThreadPool::stop()
{
    </span><span style="color: #0000ff">if</span>(isStarted_ == <span style="color: #0000ff">false</span><span style="color: #000000">)
        </span><span style="color: #0000ff">return</span><span style="color: #000000">;

    {
        MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
        isStarted_ </span>= <span style="color: #0000ff">false</span><span style="color: #000000">;
        </span><span style="color: #008000">//</span><span style="color: #008000">清空任务</span>
        <span style="color: #0000ff">while</span>(!<span style="color: #000000">queue_.empty()) 
            queue_.pop();
    }
    full_.notifyAll(); </span><span style="color: #008000">//</span><span style="color: #008000">激活所有的线程</span>
<span style="color: #000000">    empty_.notifyAll();
    
    </span><span style="color: #0000ff">for</span>(size_t ix = <span style="color: #800080">0</span>; ix != threadsNum_; ++<span style="color: #000000">ix)
    {
        threads_[ix]</span>-&gt;<span style="color: #000000">join();
    }
    threads_.clear();
}</span></pre>
</div>



<p>这里有几个关键：</p>

<p>先将bool设置为false，然后调用notifyAll，<strong><font color="#ff0000">激活所有等待的线程</font></strong>（为什么）。</p>

<p>&#160;</p>

<p>最后我们<strong><font color="#ff0000">总结下ThreadPool关闭的流程</font></strong>：</p>

<blockquote>
  <p>1.isStarted设置为false</p>
</blockquote>

<blockquote>
  <p>2.加锁，清空队列</p>
</blockquote>

<blockquote>
  <p>3.发信号激活所有线程</p>
</blockquote>

<blockquote>
  <p>4.正在运行的Thread，执行到下一次循环，退出</p>
</blockquote>

<blockquote>
  <p>5.正在等待的线程被激活，然后while判断为false，执行到下一句，检查bool值，然后退出。</p>
</blockquote>

<blockquote>
  <p>6.主线程依次join每个线程。</p>
</blockquote>

<blockquote>
  <p>7.退出。</p>
</blockquote>

<p>&#160;</p>

<p>最后补充下析构函数的实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>ThreadPool::~<span style="color: #000000">ThreadPool()
{
    </span><span style="color: #0000ff">if</span><span style="color: #000000">(isStarted_)
        stop();
}</span></pre>
</div>

<p>&#160;</p>

<p>完毕。</p>]]></description></item><item><title>使用C++11的function/bind组件封装Thread以及回调函数的使用</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/20/4038498.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 20 Oct 2014 12:00:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/20/4038498.html</guid><description><![CDATA[<p>之前在<a href="http://www.cnblogs.com/inevermore/p/4008572.html" target="_blank">http://www.cnblogs.com/inevermore/p/4008572.html</a>中采用面向对象的方式，封装了Posix的线程，那里采用的是虚函数+继承的方式，用户通过重写Thread基类的run方法，传入自己的用户逻辑。</p>  <p>&#160;</p>  <p>现在我们采用C++11的function，将函数作为Thread类的成员，用户只需要将function对象传入线程即可，所以Thread的声明中，应该含有一个function成员变量。</p>  <p>类的声明如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef THREAD_H_
</span><span style="color: #0000ff">#define</span> THREAD_H_<span style="color: #000000">

#include </span>&lt;boost/noncopyable.hpp&gt;<span style="color: #000000">
#include </span>&lt;functional&gt;<span style="color: #000000">
#include </span>&lt;pthread.h&gt;

<span style="color: #0000ff">class</span><span style="color: #000000"> Thread : boost::noncopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef std::function</span>&lt;<span style="color: #0000ff">void</span> ()&gt;<span style="color: #000000"> ThreadCallback;

    Thread(ThreadCallback callback);
    </span>~<span style="color: #000000">Thread();

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> start();
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> join();

    </span><span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> *runInThread(<span style="color: #0000ff">void</span> *<span style="color: #000000">);

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    pthread_t threadId_;
    </span><span style="color: #0000ff">bool</span><span style="color: #000000"> isRunning_;
    ThreadCallback callback_; </span><span style="color: #008000">//</span><span style="color: #008000">回调函数</span>
<span style="color: #000000">};



</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">THREAD_H_</span></pre>
</div>

<p>那么如何开启线程？思路与之前一致，写一个static函数，用户pthread_create的第三个参数，this作为最后一个参数即可。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> Thread::start()
{
    pthread_create(</span>&amp;threadId_, NULL, runInThread, <span style="color: #0000ff">this</span><span style="color: #000000">);
    isRunning_ </span>= <span style="color: #0000ff">true</span><span style="color: #000000">;
}</span></pre>
</div>

<p>&#160;</p>

<p><strong><font size="3">回调函数</font></strong></p>

<p>&#160;</p>

<p>注意在这种封装方式中，我们采用了回调函数。回调函数与普通函数的区别就是，普通函数写完由我们自己直接调用，函数调用是一种不断往上堆积的方式，而回调函数通常是我们把某一个函数传入一个“盒子”，由该盒子内的机制来调用它。</p>

<p>在这个例子里面，我们将function传入Thread，当Thread启动的时候，由Thread去执行function对象。</p>

<p><font color="#ff0000">在win32编程中大量用到这种机制</font>，我们为鼠标单击、双击等事件编写相应的函数，然后将其注册给windows系统，然后系统在我们触发各种事件的时候，根据事件的类型，调用相应的构造函数。</p>

<p>关于回调函数，可以参考：<a title="http://www.zhihu.com/question/19801131" href="http://www.zhihu.com/question/19801131">http://www.zhihu.com/question/19801131</a></p>

<p>以后有时间，再专门总结下回调函数。</p>

<p>&#160;</p>

<p>完整的cpp如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Thread.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">

Thread::Thread(ThreadCallback callback)
: threadId_(</span><span style="color: #800080">0</span><span style="color: #000000">),
  isRunning_(</span><span style="color: #0000ff">false</span><span style="color: #000000">),
  callback_(std::move(callback))
{

}
    
Thread::</span>~<span style="color: #000000">Thread()
{
    </span><span style="color: #0000ff">if</span><span style="color: #000000">(isRunning_)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">detach</span>
<span style="color: #000000">        pthread_detach(threadId_);
    }
}

</span><span style="color: #0000ff">void</span><span style="color: #000000"> Thread::start()
{
    pthread_create(</span>&amp;threadId_, NULL, runInThread, <span style="color: #0000ff">this</span><span style="color: #000000">);
    isRunning_ </span>= <span style="color: #0000ff">true</span><span style="color: #000000">;
}
</span><span style="color: #0000ff">void</span><span style="color: #000000"> Thread::join()
{
    pthread_join(threadId_, NULL);
    isRunning_ </span>= <span style="color: #0000ff">false</span><span style="color: #000000">;
}

</span><span style="color: #0000ff">void</span> *Thread::runInThread(<span style="color: #0000ff">void</span> *<span style="color: #000000">arg)
{
    Thread </span>*pt = static_cast&lt;Thread*&gt;<span style="color: #000000">(arg);
    pt</span>-&gt;callback_(); <span style="color: #008000">//</span><span style="color: #008000">调用回调函数</span>

    <span style="color: #0000ff">return</span><span style="color: #000000"> NULL;
}</span></pre>
</div>

<p>&#160;</p>

<p>这个线程的使用方式有三种：</p>

<p>一是将普通函数作为回调函数</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span><span style="color: #000000"> foo()
{
    </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
    {
        printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);
    }
}

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    Thread t(</span>&amp;<span style="color: #000000">foo);

    t.start();
    t.join();

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>&#160;</p>

<p>二是采用类的成员函数作为回调函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Foo
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span> foo(<span style="color: #0000ff">int</span><span style="color: #000000"> i)
    {
        </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
        {
            printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo %d\n</span><span style="color: #800000">&quot;</span>, i++<span style="color: #000000">);
            sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);
        }
    }
};


</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    Foo f;
    </span><span style="color: #0000ff">int</span> i = <span style="color: #800080">34</span><span style="color: #000000">;
    Thread t(bind(</span>&amp;Foo::foo, &amp;<span style="color: #000000">f, i));

    t.start();
    t.join();

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>最后一种是组合一个新的线程类，注意这里采用的是<font color="#ff0000">类的组合</font>：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Foo
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:

    Foo()
    : thread_(bind(</span>&amp;Foo::foo, <span style="color: #0000ff">this</span><span style="color: #000000">))
    {
    }

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> start()
    {
        thread_.start();
        thread_.join();
    }

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> foo()
    {
        </span><span style="color: #0000ff">while</span>(<span style="color: #800080">1</span><span style="color: #000000">)
        {
            printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
            sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);
        }
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Thread thread_;
};

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    Foo f;
    f.start();

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>有些复杂的类，还需要将三种方式加以整合，例如后面要谈到的TimerThread，里面含有一个Thread和Timer，用户将逻辑注册给Timer，然后Timer的start函数注册给Thread。</p>

<p>这种方式的Thread，使用灵活性相对于面向对象的风格，提高了很多。</p>

<p>&#160;</p>



<p><strong><font size="3">基于对象和面向对象</font></strong></p>

<p>&#160;</p>

<p>这里总结几点：</p>

<blockquote>
  <p>面向对象依靠的是<font color="#ff0000"><strong>虚函数+继承</strong></font>，用户通过重写基类的虚函数，实现自己的逻辑。</p>
</blockquote>

<blockquote>
  <p>基于对象，<strong><font color="#ff0000">依赖类的组合，使用function和bind实现委托机制，更加依赖于回调函数</font></strong>传入逻辑。</p></blockquote>]]></description></item><item><title>测试-使用MarsEdit作为Mac OS X的博客园客户端</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/19/4034155.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 18 Oct 2014 17:41:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/19/4034155.html</guid><description><![CDATA[<p>测试</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;"> </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #c91b13;"><span style="color: #822e0e;">#include </span>&lt;iostream&gt;</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #c91b13;"><span style="color: #822e0e;">#include </span>&lt;functional&gt;</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #822e0e;">#include <span style="color: #c91b13;">&lt;memory&gt;</span></p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #c32275;">using namespace <span style="color: #703daa;">std</span><span style="color: #000000;">;</span></p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;"> </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;"><span style="color: #c32275;">class</span> Test</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">{</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #c32275;">public<span style="color: #000000;">:</span></p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    Test()</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    {</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">        <span style="color: #703daa;">cout</span> &lt;&lt; <span style="color: #c91b13;">"Test "</span> &lt;&lt; <span style="color: #3d1d81;">endl</span>;</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    }</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;">    </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    ~Test()</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    {</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">        <span style="color: #703daa;">cout</span> &lt;&lt; <span style="color: #c91b13;">"~Test"</span> &lt;&lt; <span style="color: #3d1d81;">endl</span>;</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    }</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #c32275;">private<span style="color: #000000;">:</span></p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    <span style="color: #c32275;">int</span> value_;</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">};</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;"> </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;"> </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;"><span style="color: #c32275;">int</span> main(<span style="color: #c32275;">int</span> argc, <span style="color: #c32275;">const</span> <span style="color: #c32275;">char</span> * argv[])</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">{</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;"> </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #1d9421;"><span style="color: #000000;">    </span>// insert code here...</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; color: #c91b13;"><span style="color: #000000;">    </span><span style="color: #703daa;">std</span><span style="color: #000000;">::</span><span style="color: #703daa;">cout</span><span style="color: #000000;"> &lt;&lt; </span>"Hello, World!\n"<span style="color: #000000;">;</span></p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    <span style="color: #703daa;">std</span>::<span style="color: #6122ae;">shared_ptr</span>&lt;<span style="color: #3c828c;">Test</span>&gt; ptr(<span style="color: #c32275;">new</span> <span style="color: #3c828c;">Test</span>);</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;">    </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo; min-height: 21px;">    </p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">    <span style="color: #c32275;">return</span> <span style="color: #0435ff;">0</span>;</p>
<p style="margin: 0px; font-size: 18px; font-family: Menlo;">}</p>]]></description></item><item><title>C++11之function模板和bind函数适配器</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/17/4032176.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 17 Oct 2014 14:12:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/17/4032176.html</guid><description><![CDATA[<p>在C++98中，可以使用函数指针，调用函数，可以参考之前的一篇文章：<a href="http://www.cnblogs.com/inevermore/p/4014429.html" target="_blank">类的成员函数指针和mem_fun适配器的用法</a>。</p>  <p>&#160;</p>  <p><strong><font size="3">简单的函数调用</font></strong></p>  <p>&#160;</p>  <p>对于函数：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">void</span> foo(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>可以使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> (*pFunc) (<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;) = &amp;<span style="color: #000000">foo;
pFunc(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span>);</pre>
</div>

<p>现在，我们使用C++的fumction，这个函数的返回值为void，参数为const string &amp;，所以function的模板参数为void (const string&amp;)，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span>&amp;)&gt; f = &amp;<span style="color: #000000">foo;
 f(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span>);</pre>
</div>

<p>再看另外一个例子：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> foo(<span style="color: #0000ff">int</span> i, <span style="color: #0000ff">double</span><span style="color: #000000"> d)
{
    cout </span>&lt;&lt; i &lt;&lt; d &lt;&lt;<span style="color: #000000"> endl;
}


</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">argv[])
{
    function</span>&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">int</span>, <span style="color: #0000ff">double</span>)&gt; f = &amp;<span style="color: #000000">foo;
    f(</span><span style="color: #800080">12</span>, <span style="color: #800080">4.5</span><span style="color: #000000">);
    

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>







<p>&#160;</p>

<p>&#160;</p>

<p><strong><font size="3">类的成员函数</font></strong></p>

<p>&#160;</p>

<p>下列代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Foo
{
    </span><span style="color: #0000ff">public</span><span style="color: #000000">:
        </span><span style="color: #0000ff">void</span> foo(<span style="color: #0000ff">int</span> i) { cout &lt;&lt; i &lt;&lt;<span style="color: #000000"> endl; }        

        </span><span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> bar(<span style="color: #0000ff">double</span> d) { cout &lt;&lt; d &lt;&lt;<span style="color: #000000"> endl; }

};</span></pre>
</div>

<p>我们知道class的普通成员函数，含有一个隐式参数，而static则不然。</p>

<p>对于foo函数，可以使用C++98使用的mem_fun：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">Foo f;
(mem_fun(</span>&amp;Foo::foo))(&amp;f, <span style="color: #800080">123</span>);</pre>
</div>



<p>现在我们使用function，但是隐式参数如何解决？我们使用bind，这是一种非常强大的函数适配器。使用方法如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">int</span>)&gt; pf = bind(&amp;<span style="color: #000000">Foo::foo, 
                               </span>&amp;<span style="color: #000000">f, 
                               std::placeholders::_1);
pf(</span><span style="color: #800080">345</span><span style="color: #000000">);</span></pre>
</div>

<p>std::placeholders::_1叫做占位符，<font color="#ff0000">如果使用bind绑定某个值，那么该函数等于该参数消失了。如果需要保留，需要使用占位符占住位置</font>。</p>

<p>在这个例子中，foo原本有两个参数，我们把隐式参数绑定某个对象地址，所以只剩下一个地址。function的模板参数为void ()。</p>

<p>我们也可以将两个全部占住，这样bind<font color="#ff0000">和mem_fun的效果是一样的</font>：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (Foo*, <span style="color: #0000ff">int</span>)&gt; pf2 = bind(&amp;<span style="color: #000000">Foo::foo,
                                          std::placeholders::_1,
                                          std::placeholders::_2);

pf2(</span>&amp;f, <span style="color: #800080">456</span>);</pre>
</div>

<p>这里注意<font color="#ff0000">，_1和_2指的是实际调用的实参位置</font>，所以我们可以通过调换_1和_2的位置实现将int和Foo*两个参数调换。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">int</span>, Foo*)&gt; pf3 = bind(&amp;<span style="color: #000000">Foo::foo,
                    std::placeholders::_2,
                    std::placeholders::_1);

pf3(</span><span style="color: #800080">567</span>, &amp;f);</pre>
</div>



<p>&#160;</p>

<p><strong><font size="3">bind的灵活使用</font></strong></p>

<p>&#160;</p>

<p>下面通过一个更具体的例子，演示bind的用法。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">int</span> i, <span style="color: #0000ff">double</span> d, <span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">i = </span><span style="color: #800000">&quot;</span> &lt;&lt; i &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000"> d = </span><span style="color: #800000">&quot;</span> &lt;&lt; d &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000"> s = </span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>基本使用很简单：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">int</span>, <span style="color: #0000ff">double</span>, <span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span>&amp;)&gt; f1 = &amp;<span style="color: #000000">test;
 f1(</span><span style="color: #800080">12</span>, <span style="color: #800080">3.14</span>, <span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span>);</pre>
</div>

<p>1.现在将其转化为function&lt;void (int, double)&gt;类型。</p>

<p>我们分析一下：</p>

<blockquote>
  <p>string类型的参数消失了，所以我们需要bind一个值</p>

  <p>其他int和double位置不变，使用_1和_2占住即可。</p>
</blockquote>

<p>我们先使用
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre><span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span> std::placeholders;</pre>
  </div>
方便占位符的使用。代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">int</span>, <span style="color: #0000ff">double</span>)&gt; f2 =<span style="color: #000000"> 
            std::bind(</span>&amp;<span style="color: #000000">test,
                      _1,
                      _2,
                      </span><span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span>);</pre>
</div>

<p>2.转化为function&lt;void (double, int, const string &amp;)&gt;</p>

<p>分析：</p>

<blockquote>
  <p>参数仍为3个，不需要绑定任何值。</p>

  <p>int和double的顺序变了，所以_1为double，_2为int，<font color="#ff0000">注意占位符指的是实参位置</font>。</p>
</blockquote>

<p>代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">double</span>, <span style="color: #0000ff">int</span>, <span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;)&gt; f3 =<span style="color: #000000"> 
        std::bind(</span>&amp;<span style="color: #000000">test,
                  _2,
                  _1,
                  _3);</span></pre>
</div>

<p>其他例子如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">3.void (*)(const string &amp;, int)</span>
    function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;, <span style="color: #0000ff">int</span>)&gt; f4 =<span style="color: #000000"> 
        std::bind(</span>&amp;<span style="color: #000000">test,
                  _2,
                  </span><span style="color: #800080">3.4</span><span style="color: #000000">,
                  _1);


    </span><span style="color: #008000">//</span><span style="color: #008000">4. void (*) (const string &amp;, int, double)</span>
    function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span>&amp;, <span style="color: #0000ff">int</span>, <span style="color: #0000ff">double</span>)&gt;<span style="color: #000000"> f5
        </span>= std::bind(&amp;<span style="color: #000000">test,
                    _2,
                    _3,
                    _1);
    
    </span><span style="color: #008000">//</span><span style="color: #008000">5. void (*)(int)</span>
    function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">int</span>)&gt; f6 =<span style="color: #000000"> 
        bind(</span>&amp;<span style="color: #000000">test,
             _1,
             </span><span style="color: #800080">3.4</span><span style="color: #000000">,
             </span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #008000">//</span><span style="color: #008000">6 void(*)(const string &amp;)</span>
    function&lt;<span style="color: #0000ff">void</span> (<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;)&gt; f7 =<span style="color: #000000">
        bind(</span>&amp;<span style="color: #000000">test,
             </span><span style="color: #800080">12</span><span style="color: #000000">,
             </span><span style="color: #800080">4.5</span><span style="color: #000000">,
             _1);

    </span><span style="color: #008000">//</span><span style="color: #008000">7. void (*)()</span>
    function&lt;<span style="color: #0000ff">void</span>()&gt; f8 =<span style="color: #000000"> 
        bind(</span>&amp;<span style="color: #000000">test,
             </span><span style="color: #800080">12</span><span style="color: #000000">,
             </span><span style="color: #800080">4.5</span><span style="color: #000000">,
             </span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span>);</pre>
</div>



<p>&#160;</p>

<p>完毕。</p>]]></description></item><item><title>C++11之右值引用（三）：使用C++11编写string类以及“异常安全”的=运算符</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/17/4032008.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 17 Oct 2014 12:36:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/17/4032008.html</guid><description><![CDATA[<p>前面两节，说明了右值引用和它的作用。下面通过一个string类的编写，来说明右值引用的使用。</p>  <p>相对于C++98，<strong><font color="#ff0000">主要是多了移动构造函数和移动赋值运算符</font></strong>。</p>  <p>先给出一个简要的声明：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">class</span><span style="color: #000000"> String
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    String();
    String(</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *s); <span style="color: #008000">//</span><span style="color: #008000">转化语义</span>
    String(<span style="color: #0000ff">const</span> String &amp;<span style="color: #000000">s);
    String(String </span>&amp;&amp;<span style="color: #000000">s);
    </span>~<span style="color: #000000">String();

    String </span>&amp;<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> String &amp;<span style="color: #000000">s);
    String </span>&amp;<span style="color: #0000ff">operator</span>=(String &amp;&amp;<span style="color: #000000">s);

    friend ostream </span>&amp;<span style="color: #0000ff">operator</span>&lt;&lt;(ostream &amp;os, <span style="color: #0000ff">const</span> String &amp;<span style="color: #000000">s)
    {
        </span><span style="color: #0000ff">return</span> os &lt;&lt;<span style="color: #000000"> s.data_;
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">char</span> *<span style="color: #000000">data_;
};</span></pre>
</div>



<p>下面依次实现每个函数。</p>

<p>第一个是默认构造函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">String::String()
:data_(</span><span style="color: #0000ff">new</span> <span style="color: #0000ff">char</span>[<span style="color: #800080">1</span><span style="color: #000000">])
{
    </span>*data_ = <span style="color: #800080">0</span><span style="color: #000000">;
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">default</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>&#160;</p>

<p>然后是char*版本的构造函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String::String(<span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span> *<span style="color: #000000">s)
:data_(</span><span style="color: #0000ff">new</span> <span style="color: #0000ff">char</span>[strlen(s) + <span style="color: #800080">1</span><span style="color: #000000">])
{
    ::strcpy(data_, s);
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">char *</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>重点来了，我们提供移动构造函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String::String(String &amp;&amp;<span style="color: #000000">s)
:data_(s.data_)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">move construct</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    s.data_ </span>= NULL; <span style="color: #008000">//</span><span style="color: #008000">防止释放data</span>
}</pre>
</div>



<p>这里最重要的一点就是要把s的data置为NULL，因为s是个右值，马上就要析构。这样就<strong><font color="#ff0000">成功实现了偷取s的内容</font></strong>。</p>

<p>析构函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String::~<span style="color: #000000">String()
{
    delete[] data_;
}</span></pre>
</div>

<p>下面我们提供赋值运算符，这里注意一点：</p>

<p>一是处理自我赋值，二是要返回自身引用。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String &amp;String::<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> String &amp;<span style="color: #000000">s)
{
    </span><span style="color: #0000ff">if</span>(<span style="color: #0000ff">this</span> != &amp;<span style="color: #000000">s)
    {
        delete[] data_;
        data_ </span>= <span style="color: #0000ff">new</span> <span style="color: #0000ff">char</span>[strlen(s.data_) + <span style="color: #800080">1</span><span style="color: #000000">];
        ::strcpy(data_, s.data_);
    }
    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}

String </span>&amp;String::<span style="color: #0000ff">operator</span>=(String &amp;&amp;<span style="color: #000000">s)
{
    </span><span style="color: #0000ff">if</span>(<span style="color: #0000ff">this</span> != &amp;<span style="color: #000000">s)
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">move assignment</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
        delete[] data_;
        data_ </span>=<span style="color: #000000"> s.data_;
        s.data_ </span>=<span style="color: #000000"> NULL;
    }
    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}</span></pre>
</div>



<p>后面的移动构造函数，依然要把s的data置为NULL。</p>

<p>上面两个函数看似正确，但是没有处理发生异常的情况，<font color="#ff0000">如果new时发生异常，但是此时原本的data已经被delete，造成错误</font>。</p>

<p>如何解决？</p>

<p>我们提供一个swap函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> String::swap(String &amp;<span style="color: #000000">s)
{
    std::swap(data_, s.data_);
}</span></pre>
</div>



<p>一种好的处理方案是：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String &amp;String::<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> String &amp;<span style="color: #000000">s)
{
    String temp(s);
    swap(temp);

    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}

String </span>&amp;String::<span style="color: #0000ff">operator</span>=(String &amp;&amp;<span style="color: #000000">s)
{
    String temp(s);
    swap(temp);

    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}</span></pre>
</div>



<p>这样，即使生成temp时发生异常，也对自身没有影响。</p>

<p>注意这里没有处理自我赋值，因为自我赋值发生的情况实际比较少，而之前的代码第一行是delete，则必须处理自我赋值。</p>

<p>上面两个赋值运算符可以直接合为一个：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String &amp;String::<span style="color: #0000ff">operator</span>=<span style="color: #000000">(String s)
{
    swap(s);

    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}</span></pre>
</div>



<p>事实上，我们在前面也提到过，除了构造函数之外，<font color="#ff0000">X &amp;x和X &amp;&amp;类型的函数，可以合二为一为X x，采用传值</font>。</p>

<p>这样，我们的最后一个实现，保证了异常安全。</p>

<p>&#160;</p>

<p>测试代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    String s(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    String s2(s);
    </span><span style="color: #008000">//</span><span style="color: #008000">String s3(std::move(String(&quot;bar&quot;)));</span>
    String s3(String(<span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span>)); <span style="color: #008000">//</span><span style="color: #008000">编译器优化 直接使用char*</span>
    cout &lt;&lt; s3 &lt;&lt;<span style="color: #000000"> endl;

    s3 </span>=<span style="color: #000000"> s;
    s3 </span>= String(<span style="color: #800000">&quot;</span><span style="color: #800000">hello</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    cout </span>&lt;&lt; s3 &lt;&lt;<span style="color: #000000"> endl;
    s3 </span>=<span style="color: #000000"> std::move(s2);
    cout </span>&lt;&lt; s3 &lt;&lt;<span style="color: #000000"> endl;

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>注意：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String s3(String(<span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span>));</pre>
</div>



<p>会被编译器优化为</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String s3(“bar”)</pre>
</div>

<p>可以显式使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>String s3(std::move(String(<span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span>)));</pre>
</div>



<p>&#160;</p>

<p>完毕。</p>]]></description></item><item><title>C++11之右值引用（二）：右值引用与移动语义</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/16/4029914.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 16 Oct 2014 14:51:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/16/4029914.html</guid><description><![CDATA[<p>上节我们提出了右值引用，可以用来区分右值，那么这有什么用处？</p>  <p>&#160;</p>  <p><strong><font size="4">问题来源</font></strong></p>  <p>&#160;</p>  <p>我们先看一个C++中被人诟病已久的问题：</p>  <p>我把某文件的内容读取到vector中，用函数如何封装？</p>  <p>大部分人的做法是：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">void</span> readFile(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;filename, vector&lt;<span style="color: #0000ff">string</span>&gt; &amp;<span style="color: #000000">words)
{
    words.clear();
    </span><span style="color: #008000">//</span><span style="color: #008000">read XXXXX</span>
}</pre>
</div>



<p>这种做法完全可行，但是代码风格谈不上美观，我们尝试着这样编写：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>vector&lt;<span style="color: #0000ff">string</span>&gt; readFile(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">filename)
{
    vector</span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000"> ret;
    ret.push(</span><span style="color: #800000">&quot;</span><span style="color: #800000">cesfwfgw</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #008000">//</span><span style="color: #008000">....
    </span><span style="color: #008000">//
</span>
    <span style="color: #0000ff">return</span><span style="color: #000000"> ret;
}</span></pre>
</div>



<p>这样我们就可以在main中这样调用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>vector&lt;<span style="color: #0000ff">string</span>&gt; coll = readFile(<span style="color: #800000">&quot;</span><span style="color: #800000">fef.text</span><span style="color: #800000">&quot;</span>);</pre>
</div>



<p>但是，稍微熟悉C++的都知道，这样在语法上会造成大量的开销：</p>

<blockquote>
  <p>ret复制给临时变量，该临时变量开辟在heap上</p>
</blockquote>

<blockquote>
  <p>临时变量复制给coll</p>
</blockquote>

<p>这中间产生两次复制和销毁的开销。</p>

<p>如果说这个例子，可以采用开头的代码解决开销，那么如果是一个查询返回结果的函数，那么我们必须这样写：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>vector&lt;<span style="color: #0000ff">string</span>&gt; queryWord(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">word)
{
    vector</span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000"> result;
    </span><span style="color: #008000">//</span><span style="color: #008000">XXXXX</span>

    <span style="color: #0000ff">return</span><span style="color: #000000"> result;
}</span></pre>
</div>



<p>这里的开销就无法避免了。</p>

<p>&#160;</p>

<p><strong><font size="4">移动语义的引入</font></strong></p>

<p>&#160;</p>

<p>我们考虑一个生活中常见的问题（这里参考了<a href="http://www.zhihu.com/question/22111546">如何评价 C++11 的右值引用（Rvalue reference）特性？</a>），如果把一个很重的货物从箱子A移动到箱子B，那么</p>

<blockquote>
  <p>正常的做法是：打开箱子A，把物品搬出来，移动到B，然后关上A。</p>
</blockquote>

<blockquote>
  <p>另一种比较奇葩的做法是：在B中复制一个物品A，然后将A中的销毁。</p>
</blockquote>

<blockquote>
  <p>更奇葩的做法是：由于复制工具的局限性，我们无法直接在B中复制，所以我们只好先在地上复制一个物品temp，销毁A中的物品，然后根据temp在B中再复制一份，再销毁地上的temp。</p>
</blockquote>

<p>事实上，C++98采用的就是最后一种效率极其低下的做法，这里的<strong><font color="#ff0000">关键在于，C++98没有很好的区分“copy”和“move”语义</font></strong>。</p>

<p>上述问题中，我们明确提出移动A到B中，但是C++98由于移动语义的缺失，只好采用copy的方式完成。</p>

<p>&#160;</p>

<p>我们再回到开头的问题中：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>vector&lt;<span style="color: #0000ff">string</span>&gt; readFile(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">filename)
{
    vector</span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000"> ret;
    ret.push(</span><span style="color: #800000">&quot;</span><span style="color: #800000">cesfwfgw</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #008000">//</span><span style="color: #008000">....
    </span><span style="color: #008000">//
</span>
    <span style="color: #0000ff">return</span><span style="color: #000000"> ret;
}</span></pre>
</div>

<p>这里我们必须看到一点，在完成函数调用后，ret就要被销毁，所以我们想到一个主意，不是把ret中的内容复制给main中的coll，而是<font color="#ff0000"><strong>将ret中的内容偷到coll中</strong></font>，然后将ret悄悄的销毁。</p>

<p>这样是可行的，因为ret的生命周期很短。</p>

<p>&#160;</p>

<p><strong><font size="4">哪些可以偷？</font></strong></p>

<p>&#160;</p>

<p>现在问题来了，C++中哪些可以偷，哪些不能？</p>

<p>我们回顾上一节提到的四个表达式：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">string</span> one(<span style="color: #800000">&quot;</span><span style="color: #800000">one</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> two(<span style="color: #800000">&quot;</span><span style="color: #800000">two</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #0000ff">string</span> three() { <span style="color: #0000ff">return</span> <span style="color: #800000">&quot;</span><span style="color: #800000">three</span><span style="color: #800000">&quot;</span><span style="color: #000000">; }
</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> four() { <span style="color: #0000ff">return</span> <span style="color: #800000">&quot;</span><span style="color: #800000">four</span><span style="color: #800000">&quot;</span>; }</pre>
</div>



<p>显然，one和two生命周期较长，不能偷。four具有const属性，拒绝被偷。</p>

<p>那么three是可以被偷取的，因为它是临时变量，又没有const属性。</p>

<p>所以，<strong><font color="#ff0000">C++中的非const右值，和移动语义完全匹配</font></strong>。</p>

<p><strong><font color="#ff0000">上节我们提出用右值引用区分右值，正是为了解决哪些可以偷的问题！</font></strong></p>

<p>&#160;</p>

<p>OK，我们的思路已经很清晰了：</p>

<blockquote>
  <p>1.为了解决返回对象开销问题，我们提出“偷取”，而不是复制对象</p>
</blockquote>

<blockquote>
  <p>2.我们面临哪些能偷，哪些不能偷的问题。</p>
</blockquote>

<blockquote>
  <p>3.右值可以偷取，所以我们如何区分右值？</p>
</blockquote>

<blockquote>
  <p>4.我们引入右值引用X &amp;&amp;来区分右值。</p>
</blockquote>

<p>这就是右值引用的来源。</p>

<p>&#160;</p>

<p>如果一个变量不是右值，但是我们又需要偷取，那么我们可以<strong><font color="#ff0000">采用std::move函数，将其强制转化为右值引用</font></strong>。</p>

<p>例如：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">string</span><span style="color: #000000"> name)
{
    </span><span style="color: #0000ff">string</span><span style="color: #000000"> temp(std::move(name));
    </span><span style="color: #008000">//</span><span style="color: #008000"> XXXXXX</span>
}</pre>
</div>

<p>注意，被偷取之后的name无法继续使用，所以move函数不可以随意使用。</p>

<p>&#160;</p>

<p><strong><font size="4">带来的影响</font></strong></p>

<p>&#160;</p>

<p>那么，右值引用带来哪些该变呢？</p>

<p>首先是类的成员函数赋值，看下面代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> People
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    People() 
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People()</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }
    People(</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">name)
    : name_(name)
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People(const string &amp;name)</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }
    People(</span><span style="color: #0000ff">string</span> &amp;&amp;<span style="color: #000000">name)
    : name_(name)
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People(string &amp;&amp;name)</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">string</span><span style="color: #000000"> name_;
};</span></pre>
</div>



<p>这里name赋值，我们相对于C++98，提供了一个右值函数，将name的值移动给name_。</p>

<p>事实上，上面的两个函数可以合成一个：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> People
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    People() 
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People()</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }

    People(</span><span style="color: #0000ff">string</span><span style="color: #000000"> name)
    : name_(std::move(name))
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People(string name)</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">string</span><span style="color: #000000"> name_;
};</span></pre>
</div>



<p>这里注意，上面的name采用传值，并没有带来开销，因为：</p>

<blockquote>
  <p>如果name传入的是一个右值，那么name本身采用移动构造，开销比复制小很多，相当于People(string &amp;&amp;name)</p>

  <pre><font size="2" face="Verdana">如果name传入的其他值，那么name是复制构造，然后移动给name_，也没有增加额外的开销。</font></pre>
</blockquote>

<pre><font color="#333333" size="2" face="Verdana">对于构造函数，除了提供复制构造函数，还需要<strong><font color="#ff0000">移动构造函数</font></strong>。如下：</font></pre>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> People
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    People() 
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People()</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }

    People(</span><span style="color: #0000ff">string</span><span style="color: #000000"> name)
    : name_(std::move(name))
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People(string name)</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }

    People(</span><span style="color: #0000ff">const</span> People &amp;<span style="color: #000000">p)
    : name_(p.name_)
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People(const People &amp;p)</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }
    People(People </span>&amp;&amp;<span style="color: #000000">p)
    : name_(std::move(p.name_))
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">People(People &amp;&amp;p)</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">string</span><span style="color: #000000"> name_;
};</span></pre>
</div>



<p><font color="#333333" size="2">注意在最后一个</font>People(People &amp;&amp;p)中，<strong><font color="#ff0000">移动p内的name时，必须显式使用move</font></strong>，来强制移动name成员。</p>

<p>同样，还有<strong><font color="#ff0000">移动赋值运算符</font></strong>。</p>

<p><font color="#333333" size="2"></font></p>

<p><font color="#333333" size="2">另外，在C++98中，容器内的元素必须具备值语义，现在则不同，元素具备移动能力即可，后文我们在智能指针系列会提到unique_ptr，它可以放入vector中，但是不具有复制和赋值能力。</font></p>

<p><font color="#333333" size="2"></font></p>

<p><font color="#333333" size="2">其他的影响请参考：<a href="http://www.zhihu.com/question/22111546">如何评价 C++11 的右值引用（Rvalue reference）特性？</a></font></p>

<p><font color="#333333" size="2"></font></p>

<p><font color="#333333" size="2">下文通过一个string的模拟实现，演示右值引用的使用。</font></p>]]></description></item><item><title>C++11之右值引用（一）：从左值右值到右值引用</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/16/4029753.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 16 Oct 2014 13:31:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/16/4029753.html</guid><description><![CDATA[<p>C++98中规定了左值和右值的概念，但是一般程序员不需要理解的过于深入，因为对于C++98，左值和右值的划分一般用处不大，但是到了C++11，它的重要性开始显现出来。</p>  <p>C++98标准明确规定：</p>  <blockquote>   <p>左值是可以取得内存地址的变量。</p> </blockquote>  <blockquote>   <p>非左值即为右值。</p> </blockquote>  <p>从这里可以看出，<font color="#ff0000">可以执行&amp;取地址的就是左值，其他的就是右值</font>。</p>  <p>这里需要明确一点，<font color="#ff0000">能否被赋值不是区分C++左值和右值的区别</font>。</p>  <p>我们给出四个表达式：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">string</span> one(<span style="color: #800000">&quot;</span><span style="color: #800000">one</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> two(<span style="color: #800000">&quot;</span><span style="color: #800000">two</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
</span><span style="color: #0000ff">string</span> three() { <span style="color: #0000ff">return</span> <span style="color: #800000">&quot;</span><span style="color: #800000">three</span><span style="color: #800000">&quot;</span><span style="color: #000000">; }
</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> four() { <span style="color: #0000ff">return</span> <span style="color: #800000">&quot;</span><span style="color: #800000">four</span><span style="color: #800000">&quot;</span>; }</pre>
</div>

<p>这里四个变量表达式，后面两个是临时变量，不可以取地址，所以属于右值，前面两个就是左值。</p>

<p>这里写出一个函数：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">test(const string &amp;s):</span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>然后进行测试：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">test(one);
test(two);
test(three());
test(four());</span></pre>
</div>

<p>编译我们发现，这个test可以接受所有的变量。</p>

<p>我们使用另一个函数做测试：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">string</span> &amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">test(string &amp;s):</span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>然后测试发现，<font color="#ff0000">只有one可以通过调用</font>。</p>

<p>然后我们同时提供两个test函数，然后我们编译运行发现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>test(string &amp;<span style="color: #000000">s):one
test(const string </span>&amp;<span style="color: #000000">s):two
test(const string </span>&amp;<span style="color: #000000">s):three
test(const string </span>&amp;s):four</pre>
</div>

<p>&#160;</p>

<p>所以我们可以得出结论：</p>

<blockquote>
  <p>在C++中，const X&amp;可以接受所有的变量</p>

  <p>X &amp;只可以接受普通变量</p>
</blockquote>

<p>同时我们可以看出C++重载决议的一个特点：</p>

<blockquote>
  <p>当一个参数可以匹配多个函数时，总是匹配最精准的一个。</p>
</blockquote>

<p>例如上面的one，它也可以接受const X&amp;，但是当X&amp;形式的参数存在时，立刻选择后者。显然后者是专门为其准备的，二者的语义最为符合。<font color="#ff0000">X&amp;包含有一种修改语义，这与one是一致的</font>。</p>

<p>&#160;</p>

<p><strong><font size="4">引入const属性</font></strong></p>

<p>&#160;</p>

<p>上面的四个表达式，我们只讨论了左值和右值，我们再加上const进行讨论。</p>

<p>所以：</p>

<blockquote>
  <pre>string one(&quot;one&quot;); 属于非const左值
<a name="cl-7"></a>const string two(&quot;two&quot;);   const左值
<a name="cl-8"></a>string three() { return &quot;three&quot;; } 非const右值
const string four() { return &quot;four&quot;; } const右值</pre>
</blockquote>

<pre><font color="#333333">左值右值的属性与const是正交的。</font></pre>

<pre><font color="#333333">现在引入一个问题，<font color="#ff0000">如果有时候需要区分四种变量</font>，那么该使用什么方法？</font></pre>

<pre><font color="#333333">前面的讨论，我们知道X&amp;可以用来区分one，但是剩下的三个都可以被const X&amp;吞掉，显然我们需要为一些变量提供一些定制版本的参数，来让不同的变量优先选择不同的参数。</font></pre>

<pre><font color="#333333">C++11提供了右值引用来专门区分右值，我们同时提供四个函数：</font></pre>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">test(const string &amp;s):</span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}

</span><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">string</span> &amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">test(string &amp;s):</span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}

</span><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">string</span> &amp;&amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">test(string &amp;&amp;s):</span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}

</span><span style="color: #0000ff">void</span> test(<span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;&amp;<span style="color: #000000">s)
{
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">test(const string &amp;&amp;s):</span><span style="color: #800000">&quot;</span> &lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>

<p>我们使用C++11进行编译，发现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>test(string &amp;<span style="color: #000000">s):one
test(const string </span>&amp;<span style="color: #000000">s):two
test(string </span>&amp;&amp;<span style="color: #000000">s):three
test(const string </span>&amp;&amp;s):four</pre>
</div>

<p>我们得出<font color="#ff0000">最佳匹配</font>：</p>

<p>&#160;</p>

<blockquote>
  <p>X &amp; 匹配 非const左值</p>

  <p>const X&amp; 匹配 const左值</p>

  <p>X &amp;&amp; 匹配 非const右值</p>

  <p>const X &amp;&amp; 匹配 const右值</p>
</blockquote>

<p>然后，我们可以采用逐个函数进行测试，发现：</p>

<blockquote>
  <p>X&amp; 仅仅匹配 非const左值，这与之前的结论一致</p>

  <p>const X&amp; 可以匹配所有的表达式</p>

  <p>X &amp;&amp; 只可以匹配 非const右值</p>

  <p>const X &amp;&amp;可以匹配const和非const 右值</p>
</blockquote>

<p>OK，我们的问题解决，当我们需要区分右值的时候，就可以使用右值引用。</p>

<p>事实上，我们一般不需要const X &amp;&amp;，所以我们使用下列三种参数：</p>

<blockquote>
  <p>&#160;</p>

  <p>void test(string &amp;s); <strong><font color="#ff0000">修改语义</font></strong></p>
</blockquote>

<blockquote>
  <p>void test(string &amp;&amp;s); <strong><font color="#ff0000">移动语义</font></strong>，后文介绍</p>
</blockquote>

<blockquote>
  <p>void test(const string &amp;s); <strong><font color="#ff0000">常量语义</font></strong></p>
</blockquote>

<p>这三种语义已经足够，在C++98中我们只使用修改和常量语义，<strong><font color="#ff0000">在C++11中，正是为了实现移动语义，我们才需要区分右值，才需要引入右值引用</font></strong>。</p>

<p>&#160;</p>

<p>下文讲C++11右值引用实现移动语义。</p>]]></description></item><item><title>C++Singleton的DCLP（双重锁）实现以及性能测评</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/09/4014577.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 09 Oct 2014 14:05:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/09/4014577.html</guid><description><![CDATA[<p>&#160;</p>  <p><font size="3">本文系原创，转载请注明：</font><a title="http://www.cnblogs.com/inevermore/p/4014577.html" href="http://www.cnblogs.com/inevermore/p/4014577.html"><font size="3">http://www.cnblogs.com/inevermore/p/4014577.html</font></a></p>  <p>&#160;</p>  <p>根据维基百科，对单例模式的描述是：</p>  <blockquote>   <p>确保一个类只有一个实例，并提供对该实例的全局访问。</p> </blockquote>  <p>从这段话，我们可以得出单例模式的最重要特点：</p>  <blockquote>   <p>一个类最多只有一个对象</p> </blockquote>  <p>&#160;</p>  <p><font size="3"><strong>单线程环境</strong></font></p>  <p>&#160;</p>  <p>对于一个普通的类，我们可以任意的生成对象，所以我们为了避免生成太多的类，需要将类的构造函数设置为私有。</p>  <p>所以我们写出第一步：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Singleton
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Singleton() { }
};</span></pre>
</div>



<p>此时在main中就无法直接生成对象：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>Singleton s; <span style="color: #008000">//</span><span style="color: #008000">ERROR</span></pre>
</div>



<p>那么我们想要获取实例，只能借助于类内部的函数，于是我们添加一个内部的函数，<strong><font color="#ff0000">而且必须是static函数（思考为什么）：</font></strong></p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Singleton
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">getInstance()
    {
        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span><span style="color: #000000"> Singleton;
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Singleton() { }
};</span></pre>
</div>
OK，我们可以用这个函数生成对象了，但是每次都去new，无法保证唯一性，于是我们将对象保存在一个static指针内，然后每次获取对象时，先检查该指针是否为空：

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Singleton
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">getInstance()
    {
        </span><span style="color: #0000ff">if</span>(pInstance_ == NULL) <span style="color: #008000">//</span><span style="color: #008000">线程的切换</span>
<span style="color: #000000">        {
            ::sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);
            pInstance_ </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> Singleton;
        }
            
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> pInstance_;
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Singleton() { }

    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">pInstance_;
};

Singleton </span>*Singleton::pInstance_ = NULL;</pre>
</div>



<p>我们在main中测试：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>cout &lt;&lt; Singleton::getInstance() &lt;&lt;<span style="color: #000000"> endl;
cout </span>&lt;&lt; Singleton::getInstance() &lt;&lt; endl;</pre>
</div>

<p>可以看到生成了相同的对象，单例模式编写初步成功。</p>

<p>&#160;</p>

<p><font size="4"><strong>多线程环境下的考虑</strong></font></p>

<p>&#160;</p>

<p>但是目前的代码就真的没问题了吗？</p>

<p>我写出了以下的测试：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span> TestThread : <span style="color: #0000ff">public</span><span style="color: #000000"> Thread
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> run()
    {
        cout </span>&lt;&lt; Singleton::getInstance() &lt;&lt;<span style="color: #000000"> endl;
        cout </span>&lt;&lt; Singleton::getInstance() &lt;&lt;<span style="color: #000000"> endl;
    }
};

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #008000">//</span><span style="color: #008000">测试证明了多线程下本代码存在竞争问题</span>
<span style="color: #000000">
    TestThread threads[</span><span style="color: #800080">12</span><span style="color: #000000">];
    </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != <span style="color: #800080">12</span>; ++<span style="color: #000000">ix)
    {
        threads[ix].start();
    }

    </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != <span style="color: #800080">12</span>; ++<span style="color: #000000">ix)
    {
        threads[ix].join();
    }
    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>



<p>&#160;</p>

<p>这里注意，为了达到效果，我特意做了如下改动：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">if</span>(pInstance_ == NULL) <span style="color: #008000">//</span><span style="color: #008000">线程的切换</span>
<span style="color: #000000">{
     ::sleep(</span><span style="color: #800080">1</span><span style="color: #000000">);
     pInstance_ </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> Singleton;
}</span></pre>
</div>

<p>这样<strong><font color="#ff0000">故意造成线程的切换</font></strong>。</p>

<p>打印结果如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #800080">0xb1300468</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0x9f88728</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1300478</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1100488</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1300488</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0x9f88738</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0x9f88748</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1100478</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1100498</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb1100468</span>
<span style="color: #800080">0xb1300498</span>
<span style="color: #800080">0xb11004a8</span>
<span style="color: #800080">0xb11004a8</span></pre>
</div>



<p>&#160;</p>

<p>很显然，我们的代码在多线程下经不起推敲。</p>

<p>怎么办？加锁！ 于是我们再度改进：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Singleton
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">getInstance()
    {
        mutex_.</span><span style="color: #0000ff">lock</span><span style="color: #000000">();
        </span><span style="color: #0000ff">if</span>(pInstance_ == NULL) <span style="color: #008000">//</span><span style="color: #008000">线程的切换</span>
            pInstance_ = <span style="color: #0000ff">new</span><span style="color: #000000"> Singleton;
        mutex_.unlock();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> pInstance_;
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Singleton() { }

    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">pInstance_;
    </span><span style="color: #0000ff">static</span><span style="color: #000000"> MutexLock mutex_;
};

Singleton </span>*Singleton::pInstance_ =<span style="color: #000000"> NULL;
MutexLock Singleton::mutex_;</span></pre>
</div>

<p>此时测试，无问题。</p>

<p>但是，<strong><font color="#ff0000">互斥锁会极大的降低系统的并发能力，因为每次调用都要加锁，等于一群人过独木桥</font></strong>。</p>

<p>我写了一份测试如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span> TestThread : <span style="color: #0000ff">public</span><span style="color: #000000"> Thread
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> run()
    {
        </span><span style="color: #0000ff">const</span> <span style="color: #0000ff">int</span> kCount = <span style="color: #800080">1000</span> * <span style="color: #800080">1000</span><span style="color: #000000">;
        </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != kCount; ++<span style="color: #000000">ix)
        {
            Singleton::getInstance();
        }
    }
};

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #008000">//</span><span style="color: #008000">Singleton s; ERROR</span>
<span style="color: #000000">
    int64_t startTime </span>=<span style="color: #000000"> getUTime();

    </span><span style="color: #0000ff">const</span> <span style="color: #0000ff">int</span> KSize = <span style="color: #800080">100</span><span style="color: #000000">;
    TestThread threads[KSize];
    </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != KSize; ++<span style="color: #000000">ix)
    {
        threads[ix].start();
    }

    </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != KSize; ++<span style="color: #000000">ix)
    {
        threads[ix].join();
    }

    int64_t endTime </span>=<span style="color: #000000"> getUTime();

    int64_t diffTime </span>= endTime -<span style="color: #000000"> startTime;
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">cost : </span><span style="color: #800000">&quot;</span> &lt;&lt; diffTime / <span style="color: #800080">1000</span> &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000"> ms</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>



<p>开了100个线程，每个调用1M次getInstance，其中getUtime的定义如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">int64_t getUTime()
{
    </span><span style="color: #0000ff">struct</span><span style="color: #000000"> timeval tv;
    ::memset(</span>&amp;tv, <span style="color: #800080">0</span>, <span style="color: #0000ff">sizeof</span><span style="color: #000000"> tv);
    </span><span style="color: #0000ff">if</span>(gettimeofday(&amp;tv, NULL) == -<span style="color: #800080">1</span><span style="color: #000000">)
    {
        perror(</span><span style="color: #800000">&quot;</span><span style="color: #800000">gettimeofday</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        exit(EXIT_FAILURE);
    }
    int64_t current </span>=<span style="color: #000000"> tv.tv_usec;
    current </span>+= tv.tv_sec * <span style="color: #800080">1000</span> * <span style="color: #800080">1000</span><span style="color: #000000">;
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> current;
}</span></pre>
</div>

<p>运行结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>cost : <span style="color: #800080">6914</span> ms</pre>
</div>



<p>&#160;</p>

<p>&#160;</p>

<p><strong><font color="#ff0000" size="3">采用双重锁模式</font></strong></p>

<p>&#160;</p>

<p>上面的测试，我们还无法看出性能问题，我再次改进代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Singleton
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">getInstance()
    {
        </span><span style="color: #0000ff">if</span>(pInstance_ ==<span style="color: #000000"> NULL)
        {
            mutex_.</span><span style="color: #0000ff">lock</span><span style="color: #000000">();
            </span><span style="color: #0000ff">if</span>(pInstance_ == NULL) <span style="color: #008000">//</span><span style="color: #008000">线程的切换</span>
                pInstance_ = <span style="color: #0000ff">new</span><span style="color: #000000"> Singleton;
            mutex_.unlock();
        }
        
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> pInstance_;
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Singleton() { }

    </span><span style="color: #0000ff">static</span> Singleton *<span style="color: #000000">pInstance_;
    </span><span style="color: #0000ff">static</span><span style="color: #000000"> MutexLock mutex_;
};

Singleton </span>*Singleton::pInstance_ =<span style="color: #000000"> NULL;
MutexLock Singleton::mutex_;</span></pre>
</div>



<p>可以看到，我在getInstance中采用了两重检查模式，这段代码的优点体现在哪里？</p>

<blockquote>
  <p>内部采用互斥锁，代码无论如何是可靠的</p>
</blockquote>

<blockquote>
  <p>new出第一个实例后，<strong><font color="#ff0000">后面每个线程访问到最外面的if判断就直接返回了</font></strong>，没有加锁的开销</p>
</blockquote>

<p>我再次运行测试，（测试代码不变），结果如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>cost : <span style="color: #800080">438</span> ms</pre>
</div>



<p>啊哈，十几倍的性能差距，可见我们的改进是有效的，<strong><font color="#ff0000">仅仅三行代码，却带来了十几倍的效率提升！</font></strong></p>

<p>&#160;</p>

<p><strong><font size="3">尾声</font></strong></p>

<p>&#160;</p>

<p>上面这种编写方式成为DCLP（Double-Check-Locking-Pattern）模式，这种方式一度被认为是绝对正确的，但是后来有人指出这种方式在某些情况下也会乱序执行，可以参考Scott的<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf" target="_blank">C++ and the Perils of Double-Checked Locking - Scott Meyer</a></p>]]></description></item><item><title>类的成员函数指针和mem_fun适配器的用法</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/09/4014429.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 09 Oct 2014 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/09/4014429.html</guid><description><![CDATA[<p>先来看一个最简单的函数：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">void</span> foo(<span style="color: #0000ff">int</span><span style="color: #000000"> a)
{
    cout </span>&lt;&lt; a &lt;&lt;<span style="color: #000000"> endl;
}</span></pre>
</div>



<p>它的函数指针类型为</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> (*)(<span style="color: #0000ff">int</span>);</pre>
</div>



<p>我们可以这样使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> (*pFunc)(<span style="color: #0000ff">int</span>) = &amp;<span style="color: #000000">foo;
pFunc(</span><span style="color: #800080">123</span>);</pre>
</div>



<p>这就是函数指针的基本使用。</p>

<p>&#160;</p>

<p>类的成员函数</p>

<p>&#160;</p>

<p>那么，对于类的成员函数，函数指针有什么不同呢？</p>

<p>我们观察下面的类：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Foo
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:

    </span><span style="color: #008000">//</span><span style="color: #008000">void (Foo::*)(int)</span>
    <span style="color: #0000ff">void</span> foo(<span style="color: #0000ff">int</span><span style="color: #000000"> a)
    {
        cout </span>&lt;&lt; a &lt;&lt;<span style="color: #000000"> endl;
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">void (*)(int)</span>
    <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> bar(<span style="color: #0000ff">int</span><span style="color: #000000"> a)
    {
        cout </span>&lt;&lt; a &lt;&lt;<span style="color: #000000"> endl;
    }
};</span></pre>
</div>



<p>我们尝试使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> (*pFunc)(<span style="color: #0000ff">int</span>) = &amp;Foo::foo;</pre>
</div>



<p>得到编译错误：</p>

<blockquote>
  <p>error: cannot convert ‘void (Foo::*)(int)’ to ‘void (*)(int)’ in initialization</p>
</blockquote>

<p>从上面的编译错误，我们可以得知，foo的函数指针类型绝对不是我们期望的void (*)(int)，而是void (Foo::*)(int)。</p>

<p>原因很简单，类的成员函数，含有一个隐式的参数this，所以foo实际是存在两个参数，Foo*和int。</p>

<p>那么我们尝试使用void (Foo::*)(int)类型，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> (Foo::*pFunc2)(<span style="color: #0000ff">int</span>) = &amp;Foo::foo;</pre>
</div>



<p>那么如何调用呢，我们采用下列两种方式：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">Foo f;
(f.</span>*pFunc2)(<span style="color: #800080">45678</span>);</pre>
</div>

<p>以及</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>Foo *pf = &amp;<span style="color: #000000">f;
(pf</span>-&gt;*pFunc2)(<span style="color: #800080">7865</span>);</pre>
</div>

<p>此时的使用方式是正确的。</p>

<p>&#160;</p>

<p>那么bar函数是static函数，它具有什么特点呢？</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> (*pFunc)(<span style="color: #0000ff">int</span>) = &amp;<span style="color: #000000">Foo::bar;
 pFunc(</span><span style="color: #800080">123</span>);</pre>
</div>

<p>我们发现，static函数和自由函数的指针类型一致。</p>

<p>&#160;</p>

<p>既然foo含有一个隐式参数，那么能否将其转化出来呢？我们使用STL中的mem_fun，这是一种函数适配器。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">Foo f;
</span><span style="color: #008000">//</span><span style="color: #008000">void (Foo::*)(int) -&gt; void (*)(Foo*, int)</span>
(mem_fun(&amp;Foo::foo))(&amp;f, <span style="color: #800080">123</span>);</pre>
</div>

<p>我们可以看到，mem_func起到一种转化作用，将void (Foo::*)(int)类型的成员函数指针转化为void (*)(Foo*, int)，后者是一个自由函数类型的指针，可以自由调用。</p>

<p>&#160;</p>

<p>完毕。</p>]]></description></item><item><title>使用RTTI为继承体系编写”==”运算符</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/08/4012079.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 08 Oct 2014 13:22:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/08/4012079.html</guid><description><![CDATA[<p><font size="3">转载请注明出处：</font><a title="http://www.cnblogs.com/inevermore/p/4012079.html" href="http://www.cnblogs.com/inevermore/p/4012079.html"><font size="3">http://www.cnblogs.com/inevermore/p/4012079.html</font></a></p>  <p>&#160;</p>  <p>RTTI，指的是运行时类型识别技术。</p>  <p>&#160;</p>  <p>先看一个貌似无关的问题：</p>  <p>&#160;</p>  <p><font size="5"><strong>为继承体系重载&lt;&lt;操作符</strong></font></p>  <p><strong><font size="5"></font></strong></p>  <p>有下面的一个继承体系，我们需要为其添加输出操作符，应该怎么办：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Animal
{

};

</span><span style="color: #0000ff">class</span> Cat : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{

};

</span><span style="color: #0000ff">class</span> Dog : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{

};</span></pre>
</div>



<p>我们的第一个办法就是为每个类添加operator&lt;&lt;函数，但是我们也可以尝试这样：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Animal
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">virtual</span> <span style="color: #0000ff">string</span> toString() <span style="color: #0000ff">const</span> = <span style="color: #800080">0</span><span style="color: #000000">;
};

</span><span style="color: #0000ff">class</span> Cat : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">string</span> toString() <span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">return</span> <span style="color: #800000">&quot;</span><span style="color: #800000">Cat</span><span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
};

</span><span style="color: #0000ff">class</span> Dog : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{
    </span><span style="color: #0000ff">string</span> toString() <span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">return</span> <span style="color: #800000">&quot;</span><span style="color: #800000">Dog</span><span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
};

ostream </span>&amp;<span style="color: #0000ff">operator</span>&lt;&lt;(ostream &amp;os, <span style="color: #0000ff">const</span> Animal &amp;<span style="color: #000000">a)
{
    </span><span style="color: #0000ff">return</span> os &lt;&lt;<span style="color: #000000"> a.toString();
}</span></pre>
</div>



<p>显然我们只提供了一个基类的输出运算符，但是因为const Animal &amp;a的缘故，所有子类都可以放入。那么如果根据不同的类型打印不同的内容呢，我们使用了多态。</p>

<p>这样做的好处是什么？如果采用每个类都提供输出运算符的方案，那么我们必须牢记，每编写一个类就要为其添加一个操作符，这一点是很容易遗忘的，但是如果采用我们上面的代码，我们将toString写为虚函数，这样，<strong><font color="#ff0000">我们每次去重新实现toString就可以了</font></strong>。虚函数被遗忘的可能性比&lt;&lt;操作符低很多。</p>

<p>&#160;</p>

<p><font size="5"><strong>为继承体系重载==操作符</strong></font></p>

<p>&#160;</p>

<p>还是之前的类：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> Animal
{

};

</span><span style="color: #0000ff">class</span> Cat : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{

};

</span><span style="color: #0000ff">class</span> Dog : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{

};</span></pre>
</div>

<p>这次我们需要为其提供==操作符，那么我们应该提供几个？为每个类提供一个显然是不够的，因为继承体系中，派生类对象可以被基类对象引用，所以<strong><font color="#ff0000">我们有时候需要将Animal &amp;与Cat &amp;进行比较</font></strong>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Animal &amp;, <span style="color: #0000ff">const</span> Animal &amp;<span style="color: #000000">);
</span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Cat &amp;, <span style="color: #0000ff">const</span> Cat &amp;<span style="color: #000000">);
</span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Dog &amp;, <span style="color: #0000ff">const</span> Dog &amp;<span style="color: #000000">);
</span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Animal &amp;, <span style="color: #0000ff">const</span> Cat &amp;<span style="color: #000000">);
</span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Cat &amp;, <span style="color: #0000ff">const</span> Dog &amp;<span style="color: #000000">);
</span><span style="color: #008000">//</span><span style="color: #008000">.............</span></pre>
</div>

<p>看起来，五个还不够。就算只有五个，我们需要逐个实现也是非常恐怖。那么有没有好一些的解决方案呢？我们采用本文第一节的技巧。</p>

<blockquote>
  <p>只重载一个Animal基类的==操作符</p>
</blockquote>

<blockquote>
  <p>每个类实现equal，这是一个虚函数</p>
</blockquote>

<p>&#160;</p>



<p>在继续编写代码之前，我们先搞清楚，两个相同的前提是，<strong><font color="#ff0000">他们的类型相同</font></strong>，然后再去比较成员变量。</p>

<p>于是我们给出的解决方案如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include &lt;iostream&gt;<span style="color: #000000">
#include </span>&lt;typeinfo&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Animal
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">virtual</span> <span style="color: #0000ff">bool</span> equal(<span style="color: #0000ff">const</span> Animal &amp;other) <span style="color: #0000ff">const</span> = <span style="color: #800080">0</span><span style="color: #000000">;
};

</span><span style="color: #0000ff">class</span> Cat : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">bool</span> equal(<span style="color: #0000ff">const</span> Animal &amp;other) <span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">Cat Animal</span>
        <span style="color: #0000ff">if</span>(<span style="color: #0000ff">const</span> Cat *pc =  dynamic_cast&lt;<span style="color: #0000ff">const</span> Cat*&gt;(&amp;<span style="color: #000000">other)) 
        {
            </span><span style="color: #0000ff">return</span> name_ == pc-&gt;<span style="color: #000000">name_;
        }
        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">;
    }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">string</span><span style="color: #000000"> name_;
};

</span><span style="color: #0000ff">class</span> Dog : <span style="color: #0000ff">public</span><span style="color: #000000"> Animal
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">bool</span> equal(<span style="color: #0000ff">const</span> Animal &amp;other) <span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">Dog Animal</span>
        <span style="color: #0000ff">if</span>(<span style="color: #0000ff">const</span> Dog *pd = dynamic_cast&lt;<span style="color: #0000ff">const</span> Dog*&gt;(&amp;<span style="color: #000000">other))
        {
            </span><span style="color: #0000ff">return</span> name_ == pd-&gt;<span style="color: #000000">name_;
        }
        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">;
    }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">string</span><span style="color: #000000"> name_;
};

</span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Animal &amp;a, <span style="color: #0000ff">const</span> Animal &amp;<span style="color: #000000">b)
{
    </span><span style="color: #0000ff">return</span> typeid(a) == typeid(b) &amp;&amp;<span style="color: #000000"> a.equal(b);
}

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{

    Cat c;
    Dog d;

    Animal </span>*pa = &amp;<span style="color: #000000">c;
    cout </span>&lt;&lt; (*pa == c) &lt;&lt;<span style="color: #000000"> endl;
    pa </span>= &amp;<span style="color: #000000">d;
    cout </span>&lt;&lt; (*pa == d) &lt;&lt;<span style="color: #000000"> endl;
    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>我们先来看&lt;&lt;的重载：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Animal &amp;a, <span style="color: #0000ff">const</span> Animal &amp;<span style="color: #000000">b)
{
    </span><span style="color: #0000ff">return</span> typeid(a) == typeid(b) &amp;&amp;<span style="color: #000000"> a.equal(b);
}</span></pre>
</div>



<p>这里利用了&amp;&amp;的短路特性，一旦两个对象的类型不同，那么后面就没有必要比较。</p>

<blockquote>
  <p>typeid是一个类型识别运算符，如果要识别的类型不是class或者不含有virtual函数，那么typeid指出静态类型。<font color="#ff0000">如果class含有虚函数，那么typeid在运行期间识别类型。</font></p>
</blockquote>

<p>对equal的调用，显然使用了动态绑定，<strong><font color="#ff0000">总是根据对象的实际类型调用对应的equal版本</font></strong>。</p>

<p>然后我们看一下Dog中equal的实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">bool</span> equal(<span style="color: #0000ff">const</span> Animal &amp;other) <span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">Cat Animal</span>
        <span style="color: #0000ff">if</span>(<span style="color: #0000ff">const</span> Cat *pc =  dynamic_cast&lt;<span style="color: #0000ff">const</span> Cat*&gt;(&amp;<span style="color: #000000">other)) 
        {
            </span><span style="color: #0000ff">return</span> name_ == pc-&gt;<span style="color: #000000">name_;
        }
        </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">;
    }</span></pre>
</div>

<p>&#160;</p>

<p>这里利用了dynamic_cast进行了“向下塑形”，dynamic_cast与static_cast有一些不同：</p>

<blockquote>
  <p>static_cast发生在<strong><font color="#ff0000">编译期间</font></strong>，如果转化不通过，那么编译错误，如果编译无问题，那么转化一定成功。<strong><font color="#ff0000">static_cast仍具有一定风险</font></strong>，尤其是向下塑形时，将Base*转化为Derived*时，指针可以转化，但是指针未必指向Derived对象。</p>
</blockquote>

<blockquote>
  <p>dynamic_cast发生在<strong><font color="#ff0000">运行期间</font></strong>，用于将Base的指针或者引用转化为派生类的指针或者引用，如果成功，返回正常的指针或引用，<strong><font color="#ff0000">如果失败，返回NULL（指针），或者抛出异常（bad_cast)</font></strong>。</p>
</blockquote>

<p>在&lt;&lt;的重载中，我们保证了equal两个参数的类型相同，那么我们为何还需要在equal中“向下塑形”呢？</p>

<blockquote>
  <p>equal有可能被单独使用，所以other的类型未必和自己相同。</p>
</blockquote>

<blockquote>
  <p>如果不进行转换，other是无法访问name属性的，因为Animal中没有name。</p>
</blockquote>

<p>记住下面的代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">pb是Base类型指针</span>
    <span style="color: #0000ff">if</span>(Derived *pd =  dynamic_cast&lt;Derived*&gt;<span style="color: #000000">(pb)) 
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">转化成功</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">else</span><span style="color: #000000">
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">失败</span>
    }</pre>
</div>



<p>这是一种使用dynamic_cast的<strong><font color="#ff0000">标准实践</font></strong>。</p>

<p>这段代码的逻辑是非常严密的：</p>

<blockquote>
  <p><strong><font color="#ff0000">pd的生存期只存在于转化成功的情况</font></strong></p>
</blockquote>

<blockquote>
  <p>无法在dynamic_cast和测试代码之间插入代码</p>
</blockquote>

<p>如果使用的是引用，可以这样：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">try</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">const</span> Derived &amp;d = dynamic_cast&lt;<span style="color: #0000ff">const</span> Derived&amp;&gt;<span style="color: #000000">(b);
        </span><span style="color: #008000">//</span><span style="color: #008000">成功</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">catch</span><span style="color: #000000">(bad_cast)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">失败处理</span>
    }</pre>
</div>



<p>也可以将引用取地址，然后去转化指针。</p>

<p>&#160;</p>

<p>typeid和dynamic_cast是实现RTTI的主要手段。</p>

<p>&#160;</p>

<p>完毕。</p>]]></description></item><item><title>Linux组件封装（五）一个生产者消费者问题示例</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/07/4009719.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Tue, 07 Oct 2014 11:45:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/07/4009719.html</guid><description><![CDATA[<p>生产者消费者问题是计算机中一类重要的模型，主要描述的是：生产者往缓冲区中放入产品、消费者取走产品。生产者和消费者指的可以是线程也可以是进程。</p>  <p>生产者消费者问题的难点在于：</p>  <blockquote>   <p>为了缓冲区数据的安全性，一次只允许一个线程进入缓冲区，它就是所谓的临界资源。</p> </blockquote>  <blockquote>   <p>生产者往缓冲区放物品时，如果缓冲区已满，那么需要等待，一直到消费者取走产品为止。</p> </blockquote>  <blockquote>   <p>消费者取走产品时，如果没有物品，需要等待，一直到有生产者放入为止。</p> </blockquote>  <p>第一个问题属于互斥问题，我们需要使用一把<strong><font color="#ff0000">互斥锁</font></strong>，来实现对缓冲区的安全访问。</p>  <p>后两个属于<strong><font color="#ff0000">同步问题，两类线程相互协作</font></strong>，需要两个<font color="#ff0000"><strong>条件变量</strong></font>，一个用于通知生产者放入产品，一个用来通知消费者取走物品。</p>  <p>生产者线程的大概流程是：</p>  <blockquote>   <p>1.加锁</p>    <p>2.如果缓冲区已满，则等待。</p>    <p>3.放入物品</p>    <p>4.解锁</p>    <p>5.通知消费者，可以取走产品</p> </blockquote>  <p>消费者的逻辑恰好相反：</p>  <blockquote>   <p>1.加锁</p>    <p>2.缓冲区为空，等待</p>    <p>3.取走物品</p>    <p>4.解锁</p>    <p>5.通知生产者，可以放入物品</p> </blockquote>  <p>我们设计出一个缓冲区：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef BUFFER_H_
</span><span style="color: #0000ff">#define</span> BUFFER_H_<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">NonCopyable.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">MutexLock.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">Condition.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;queue&gt;

<span style="color: #0000ff">class</span><span style="color: #000000"> Buffer : NonCopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    Buffer(size_t size);
    </span><span style="color: #0000ff">void</span> push(<span style="color: #0000ff">int</span><span style="color: #000000"> val);
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> pop();

    </span><span style="color: #0000ff">bool</span> empty() <span style="color: #0000ff">const</span><span style="color: #000000">;
    size_t size() </span><span style="color: #0000ff">const</span><span style="color: #000000">;

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    mutable MutexLock mutex_;
    Condition full_;
    Condition empty_;

    size_t size_; </span><span style="color: #008000">//</span><span style="color: #008000">缓冲区的大小</span>
    std::queue&lt;<span style="color: #0000ff">int</span>&gt;<span style="color: #000000"> queue_;
};

</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">BUFFER_H_</span></pre>
</div>



<p>这里注意，我们把同步与互斥的操作都放入Buffer中，使得生产者和消费者线程不必考虑其中细节，这符号软件设计的<strong><font color="#ff0000">“高内聚、低耦合”</font></strong>原则。</p>

<p>还有一点，mutex被声明为mutable类型，意味着mutex在const函数中仍然可以被改变，这是符合程序的逻辑的。<strong><font color="#ff0000">把mutex声明为mutable，是一种标准实践。</font></strong></p>

<p>重点是push和pop的实现：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">void</span> Buffer::push(<span style="color: #0000ff">int</span><span style="color: #000000"> val)
{
    </span><span style="color: #008000">//</span><span style="color: #008000">lock
    </span><span style="color: #008000">//</span><span style="color: #008000">wait
    </span><span style="color: #008000">//</span><span style="color: #008000">push
    </span><span style="color: #008000">//</span><span style="color: #008000">notify
    </span><span style="color: #008000">//</span><span style="color: #008000">lock</span>
<span style="color: #000000">    {
        MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
        </span><span style="color: #0000ff">while</span>(queue_.size() &gt;=<span style="color: #000000"> size_)
            empty_.wait();
        queue_.push(val);
    }
    full_.notify();
}

</span><span style="color: #0000ff">int</span><span style="color: #000000"> Buffer::pop()
{
    </span><span style="color: #0000ff">int</span> temp = <span style="color: #800080">0</span><span style="color: #000000">;
    {
        MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
        </span><span style="color: #0000ff">while</span><span style="color: #000000">(queue_.empty())
            full_.wait();
        temp </span>=<span style="color: #000000"> queue_.front();
        queue_.pop();
    }
    empty_.notify();

    </span><span style="color: #0000ff">return</span><span style="color: #000000"> temp;
}</span></pre>
</div>

<p>这里注意：</p>

<blockquote>
  <p>1.<font color="#ff0000"><strong>条件变量的等待必须使用while</strong></font>，这是一种最佳实践，原因可见Condition的封装<a href="http://www.cnblogs.com/inevermore/p/4008397.html" target="_blank">Linux组件封装（二）中条件变量Condition的封装</a>。</p>

  <p>2.可以先notify再解锁，也可以先解锁。<font color="#ff0000"><strong>不过推荐先解锁</strong></font>，原因是如果先notify，唤醒一个线程B，但是还未解锁，此时如果线程切换至刚唤醒的线程B，B马上尝试lock，但是肯定失败，然后阻塞，<strong><font color="#ff0000">这增加了一次线程切换的开销</font></strong>。</p>
</blockquote>

<p>我们还可以继续封装，将缓冲区与多个生产者、消费者封装成一个车间类，如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef WORKSHOP_H_
</span><span style="color: #0000ff">#define</span> WORKSHOP_H_<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">NonCopyable.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">Buffer.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;vector&gt;

<span style="color: #0000ff">class</span><span style="color: #000000"> ProducerThread;
</span><span style="color: #0000ff">class</span><span style="color: #000000"> ConsumerThread;

</span><span style="color: #0000ff">class</span><span style="color: #000000"> WorkShop : NonCopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    WorkShop(size_t bufferSize, 
             size_t producerSize, 
             size_t consumerSize);
    </span>~<span style="color: #000000">WorkShop();

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> startWorking();
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    size_t bufferSize_;
    Buffer buffer_;

    size_t producerSize_;
    size_t consumerSize_;
    std::vector</span>&lt;ProducerThread*&gt;<span style="color: #000000"> producers_;
    std::vector</span>&lt;ConsumerThread*&gt;<span style="color: #000000"> consumers_;
};


</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">WORKSHOP_H_</span></pre>
</div>

<p>这样就可以方便的指定线程的数目。</p>

<p>&#160;</p>

<p>完整的项目代码请参见这里：<a href="https://bitbucket.org/gchunyang/producerandconsumer/src" target="_blank"><strong>生产者消费者完整代码</strong></a><font color="#0000ff"></font></p>]]></description></item><item><title>Linux组件封装（四）使用RAII技术实现MutexLock自动化解锁</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/07/4009694.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Tue, 07 Oct 2014 11:19:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/07/4009694.html</guid><description><![CDATA[<p>我们不止一次写过这种代码：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">{
    mutex_.</span><span style="color: #0000ff">lock</span><span style="color: #000000">();
    </span><span style="color: #008000">//</span><span style="color: #008000">XXX</span>
    <span style="color: #0000ff">if</span><span style="color: #000000">(....)
        </span><span style="color: #0000ff">return</span><span style="color: #000000">;

    </span><span style="color: #008000">//</span><span style="color: #008000">XXX</span>
<span style="color: #000000">    mutex_.unlock();
}</span></pre>
</div>



<p>显然，这段代码中我们忘记了解锁。那么如何防止这种情况，我们采用和智能指针相同的策略，把加锁和解锁的过程封装在一个对象中。</p>

<p>实现<strong><font color="#ff0000">“对象生命期”等于“加锁周期”。</font></strong></p>

<p>代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">class</span><span style="color: #000000"> MutexLockGuard : NonCopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    MutexLockGuard(MutexLock </span>&amp;<span style="color: #000000">mutex) :mutex_(mutex)
    { mutex_.</span><span style="color: #0000ff">lock</span><span style="color: #000000">(); }
    </span>~<span style="color: #000000">MutexLockGuard()
    { mutex_.unlock(); }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    MutexLock </span>&amp;<span style="color: #000000">mutex_;
};</span></pre>
</div>



<p>这种把资源获取放在构造函数、资源释放放入析构函数中的做法，就是C++中的RAII技术，“<strong><font color="#ff0000">资源获取即初始化</font></strong>”。它巧妙在C++中的栈对象是一定会析构的，所以资源一定会被释放。</p>

<p>这个类对于我们编写优雅的代码，好处是显而易见的，例如：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>size_t Buffer::size() <span style="color: #0000ff">const</span><span style="color: #000000">
{
    mutex_.</span><span style="color: #0000ff">lock</span><span style="color: #000000">();
    </span><span style="color: #0000ff">int</span> ret =<span style="color: #000000"> queue_.size();
    mutex_.unlock();
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> queue_.size();
}</span></pre>
</div>
这段代码实在称不上美观，但是有了MutexLockGuard，我们可以写出：

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>size_t Buffer::size() <span style="color: #0000ff">const</span><span style="color: #000000">
{
    MutexLockGuard </span><span style="color: #0000ff">lock</span><span style="color: #000000">(mutex_);
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> queue_.size();
}</span></pre>
</div>

<p>代码的美观性提高了许多。</p>

<p>当然，有一种使用方式是错误的，例如：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>size_t Buffer::size() <span style="color: #0000ff">const</span><span style="color: #000000">
{
    MutexLockGuard(mutex_);
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> queue_.size();
}</span></pre>
</div>

<p>这段代码的加锁周期仅限于那一行，为了防止错误使用，我们增加一个宏：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">#define</span> MutexLockGuard(m) &quot;Error MutexLockGuard&quot;</pre>
</div>
这样当错误使用的时候，会导致编译错误，使得我们早些发现问题。]]></description></item><item><title>模板系列（一）模板的模板参数</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008672.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 06 Oct 2014 12:46:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008672.html</guid><description><![CDATA[<p>在之前，我们写过类似的stack</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;typename T, typename Alloc = std::vector&lt;T&gt; &gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Stack
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">);
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> pop();
    T top() </span><span style="color: #0000ff;">const</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">bool</span> empty() <span style="color: #0000ff;">const</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    Alloc cont_;
};</span></pre>
</div>
<p>那么我们使用的时候，需要这样写</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>Stack&lt;<span style="color: #0000ff;">string</span>, list&lt;<span style="color: #0000ff;">string</span>&gt; &gt; st;</pre>
</div>
<p>我们看到，string这个类型参数出现了两次，那么可不可以消除呢？</p>
<p>显然我们的目的是只指定容器的类型，而不包括元素的类型，这就需要借助<strong><span style="color: #ff0000;">模板的模板参数</span></strong>，来帮助我们写出一下代码：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>Stack&lt;<span style="color: #0000ff;">string</span>, list&gt; st;</pre>
</div>
<p>那么如何使用模板的模板参数呢？</p>
<p>我们需要这样定义模板参数的第二项修改为模板</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;<span style="color: #000000;">typename T, 
          template </span>&lt;typename ELEM&gt; <span style="color: #0000ff;">class</span> Alloc = std::vector&gt;
<span style="color: #0000ff;">class</span> Stack</pre>
</div>
<p>我们回忆一下，我们没接触泛型时，写的是普通的stack</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">class</span> Stack;</pre>
</div>
<p>当我们开始使用泛型时，就把这个类名加上模板参数。</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;typename T, typename Alloc = std::vector&lt;T&gt; &gt;
<span style="color: #0000ff;">class</span> Stack;</pre>
</div>
<p>上面两项叫做类的模板参数。现在我们需要把第二个模板参数改为泛型的，于是，我们给它加上模板参数：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;<span style="color: #000000;">typename T, 
          template </span>&lt;typename ELEM&gt; </pre>
<pre>          typename Alloc = std::vector&gt;
<span style="color: #0000ff;">class</span> Stack;</pre>
</div>
<p>但是上面的写法有一处错误，上面的Alloc必须是一个类，所以我们只能用class作为关键字，于是改为：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;<span style="color: #000000;">typename T, 
          template </span>&lt;typename ELEM&gt; </pre>
<pre>          <span style="color: #0000ff;">class</span> Alloc = std::vector&gt;
<span style="color: #0000ff;">class</span> Stack;</pre>
</div>
<p>我们写出完整的一份实现：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;<span style="color: #000000;">typename T, 
          template </span>&lt;typename ELEM&gt; </pre>
<pre>          <span style="color: #0000ff;">class</span> Alloc = std::vector&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Stack
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">);
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> pop();
    T top() </span><span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cont_.back();
    }
    </span><span style="color: #0000ff;">bool</span> empty() <span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cont_.empty();
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    Alloc</span>&lt;T&gt;<span style="color: #000000;"> cont_;
};

template </span>&lt;typename T, template &lt;typename&gt; <span style="color: #0000ff;">class</span> Alloc&gt;
<span style="color: #0000ff;">void</span> Stack&lt;T, Alloc&gt;::push(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">val)
{
    cont_.push_back(val);
}

template </span>&lt;typename T, template &lt;typename&gt; <span style="color: #0000ff;">class</span> Alloc&gt;
<span style="color: #0000ff;">void</span> Stack&lt;T, Alloc&gt;<span style="color: #000000;">::pop()
{
    cont_.pop_back();
}</span></pre>
</div>
<p>当我们使用：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>Stack&lt;<span style="color: #0000ff;">string</span>, list&gt; st;</pre>
</div>
<p>却不幸发现存在编译错误，有一条是：</p>
<blockquote>
<p>expected a template of type &lsquo;template&lt;class ELEM&gt; class Alloc&rsquo;, got &lsquo;template&lt;class _Tp, class _Alloc&gt; class std::list</p>
</blockquote>
<p>这是因为，无论是vector还是list都有两个模板参数，于是无法与Alloc这个模板参数匹配。</p>
<p>我们修正为：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;<span style="color: #000000;">typename T, 
          template </span>&lt;typename ELEM, typename Alloc = std::allocator&lt;ELEM&gt; &gt; 
          <span style="color: #0000ff;">class</span> Container = std::vector&gt;
<span style="color: #0000ff;">class</span> Stack;</pre>
</div>
<p>然后给出完整实现：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>template &lt;<span style="color: #000000;">typename T, 
          template </span>&lt;typename ELEM, typename Alloc = std::allocator&lt;ELEM&gt; &gt; 
          <span style="color: #0000ff;">class</span> Container = std::vector&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Stack
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">);
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> pop();
    T top() </span><span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cont_.back();
    }
    </span><span style="color: #0000ff;">bool</span> empty() <span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cont_.empty();
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    Container</span>&lt;T&gt;<span style="color: #000000;"> cont_;
};

template </span>&lt;typename T, template &lt;typename, typename&gt; <span style="color: #0000ff;">class</span> Container&gt;
<span style="color: #0000ff;">void</span> Stack&lt;T, Container&gt;::push(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">val)
{
    cont_.push_back(val);
}

template </span>&lt;typename T, template &lt;typename, typename&gt; <span style="color: #0000ff;">class</span> Container&gt;
<span style="color: #0000ff;">void</span> Stack&lt;T, Container&gt;<span style="color: #000000;">::pop()
{
    cont_.pop_back();
}</span></pre>
</div>
<p>测试代码：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>Stack&lt;<span style="color: #0000ff;">string</span>, list&gt;<span style="color: #000000;"> st;
st.push(</span><span style="color: #800000;">"</span><span style="color: #800000;">foo</span><span style="color: #800000;">"</span><span style="color: #000000;">);
st.pop();</span></pre>
</div>
<p>完毕！</p>]]></description></item><item><title>Linux组件封装（三）使用面向对象编程封装Thread</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008572.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 06 Oct 2014 10:55:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008572.html</guid><description><![CDATA[<p>C++11提供了thread，但是过于复杂，我们还是倾向于在项目中编写自己的Thread。</p>  <p>Posix Thread的使用这里不再赘述。</p>  <p>重点是这个函数：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;pthread.h&gt;
<span style="color: #0000ff">int</span> pthread_create(pthread_t *thread, <span style="color: #0000ff">const</span> pthread_attr_t *<span style="color: #000000">attr,
                          </span><span style="color: #0000ff">void</span> *(*start_routine) (<span style="color: #0000ff">void</span> *), <span style="color: #0000ff">void</span> *arg);</pre>
</div>

<p>第三个参数是一个回调函数，该函数必须返回值为void*，而且只有一个参数，类型也是void*。</p>

<p>POSIX的thread默认是joinable，需要手工调用pthread_join函数来回收，<strong><font color="#ff0000">也可以调用pthread_detach将其变为detachable</font></strong>，此时不需要手工回收线程。</p>

<p>下面介绍Thread的封装。</p>

<p>我们把Thread的声明先放在这里：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef THREAD_H_
</span><span style="color: #0000ff">#define</span> THREAD_H_<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">NonCopyable.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;pthread.h&gt;

<span style="color: #0000ff">class</span><span style="color: #000000"> Thread : NonCopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    Thread();
    virtual </span>~<span style="color: #000000">Thread();

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> start();
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> join();

    </span><span style="color: #0000ff">virtual</span> <span style="color: #0000ff">void</span> run() = <span style="color: #800080">0</span><span style="color: #000000">;

    pthread_t getThreadId() </span><span style="color: #0000ff">const</span><span style="color: #000000">
    { </span><span style="color: #0000ff">return</span><span style="color: #000000"> threadId_; }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:</span></pre>

  <pre><span style="color: #000000">    //提供给pthread_create的第三个参数使用
    </span><span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> *runInThread(<span style="color: #0000ff">void</span> *<span style="color: #000000">arg);
    
    pthread_t threadId_;
    </span><span style="color: #008000">//</span><span style="color: #008000">pid_t tid_; </span><span style="color: #008000">//</span><span style="color: #008000">进程标示</span>
    <span style="color: #0000ff">bool</span><span style="color: #000000"> isRunning_;
};

</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">THREAD_H_</span></pre>
</div>

<p>这里需要说明的是：</p>

<blockquote>
  <p>首先，为了获得最干净的语义，<strong><font color="#ff0000">Thread应该是不可复制的</font></strong>，所以需要继承NonCopyable。</p>
</blockquote>

<blockquote>
  <p>其次，为了调用pthread_create创建线程，我们往里面注册的不能是一个成员函数，因为成员函数含有一个隐式参数，导致函数的指针类型并不是void *(*start_routine) (void *)，所以我们<font color="#ff0000"><strong>采用了static函数</strong></font>。</p>
</blockquote>

<blockquote>
  <p>static函数无法访问某一对象的成员，所以我们在调用pthread_create时，<font color="#ff0000"><strong>将this指针作为回调函数的参数</strong></font>。</p>
</blockquote>

<p>这里相关代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">static</span>
<span style="color: #0000ff">void</span> *Thread::runInThread(<span style="color: #0000ff">void</span> *<span style="color: #000000">arg)
{
    Thread </span>*pt = static_cast&lt;Thread*&gt;<span style="color: #000000">(arg);
    </span><span style="color: #008000">//</span><span style="color: #008000">pt-&gt;tid_ = syscall(SYS_gettid);</span>
    pt-&gt;<span style="color: #000000">run();
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> NULL;
}</span></pre>
</div>
用户将自己的逻辑注册在run中就可以了。 

<blockquote>
  <p>这个Thread不提供detach函数，因为我们在析构函数中做了如下的处理，<strong><font color="#ff0000">如果Thread对象析构，线程还在运行，那么需要将Thread设置为detach状态</font></strong>。</p>
</blockquote>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>Thread::~<span style="color: #000000">Thread()
{
    </span><span style="color: #0000ff">if</span><span style="color: #000000">(isRunning_)
    {
        pthread_detach(threadId_);
    }
}</span></pre>
</div>

<p>大部分逻辑都是固定的，用户只需要改变run里面的代码即可，于是我们<strong><font color="#ff0000">将run设置为纯虚函数，让用户继承Thread类</font></strong>。</p>

<p><strong><font color="#ff0000">所以析构函数为virtual</font></strong>。</p>

<p>完整的CPP实现如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Thread.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;assert.h&gt;<span style="color: #000000">
#include </span>&lt;unistd.h&gt;<span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">MutexLock.h</span><span style="color: #800000">&quot; //TINY_CHECK</span><span style="color: #000000">

Thread::Thread()
    :threadId_(</span><span style="color: #800080">0</span><span style="color: #000000">),
     isRunning_(</span><span style="color: #0000ff">false</span><span style="color: #000000">)
{

}

Thread::</span>~<span style="color: #000000">Thread()
{
    </span><span style="color: #0000ff">if</span><span style="color: #000000">(isRunning_)
    {
        TINY_CHECK(</span>!<span style="color: #000000">pthread_detach(threadId_));
    }
}

</span><span style="color: #008000">//</span><span style="color: #008000">static</span>
<span style="color: #0000ff">void</span> *Thread::runInThread(<span style="color: #0000ff">void</span> *<span style="color: #000000">arg)
{
    Thread </span>*pt = static_cast&lt;Thread*&gt;<span style="color: #000000">(arg);
    </span><span style="color: #008000">//</span><span style="color: #008000">pt-&gt;tid_ = syscall(SYS_gettid);</span>
    pt-&gt;<span style="color: #000000">run();
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> NULL;
}

</span><span style="color: #0000ff">void</span><span style="color: #000000"> Thread::start()
{
    TINY_CHECK(</span>!pthread_create(&amp;threadId_, NULL, Thread::runInThread, <span style="color: #0000ff">this</span><span style="color: #000000">));
    isRunning_ </span>= <span style="color: #0000ff">true</span><span style="color: #000000">;
}

</span><span style="color: #0000ff">void</span><span style="color: #000000"> Thread::join()
{
    assert(isRunning_);
    TINY_CHECK(</span>!<span style="color: #000000">pthread_join(threadId_, NULL));
    isRunning_ </span>= <span style="color: #0000ff">false</span><span style="color: #000000">;
}</span></pre>
</div>

<p>测试代码如下：采用继承的方式使用这个类。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Thread.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;iostream&gt;<span style="color: #000000">
#include </span>&lt;unistd.h&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">class</span> MyThread : <span style="color: #0000ff">public</span><span style="color: #000000"> Thread
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> run()
    {
        cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl;
    }
};

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    MyThread t;
    t.start();

    t.join();

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>NonCopyable类的定义如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef NONCOPYABLE_H
</span><span style="color: #0000ff">#define</span> NONCOPYABLE_H


<span style="color: #0000ff">class</span> NonCopyable <span style="color: #008000">//</span><span style="color: #008000">禁用值语义</span>
<span style="color: #000000">{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    NonCopyable() { }
    </span>~<span style="color: #000000">NonCopyable() { }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    NonCopyable(</span><span style="color: #0000ff">const</span> NonCopyable &amp;<span style="color: #000000">);
    </span><span style="color: #0000ff">void</span> <span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> NonCopyable &amp;<span style="color: #000000">);
};


</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">NONCOPYABLE_H</span></pre>
</div>]]></description></item><item><title>Linux组件封装（二）中条件变量Condition的封装</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008397.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 06 Oct 2014 08:37:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008397.html</guid><description><![CDATA[<p>条件变量主要用于实现线程之间的协作关系。</p>  <p>pthread_cond_t常用的操作有：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">int</span> pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *<span style="color: #000000">cond_attr);
</span><span style="color: #0000ff">int</span> pthread_cond_signal(pthread_cond_t *<span style="color: #000000">cond);
</span><span style="color: #0000ff">int</span> pthread_cond_broadcast(pthread_cond_t *<span style="color: #000000">cond);
</span><span style="color: #0000ff">int</span> pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *<span style="color: #000000">mutex);
</span><span style="color: #0000ff">int</span> pthread_cond_destroy(pthread_cond_t *cond);</pre>
</div>

<p>我先将Condition类的声明放在这里：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef CONDITION_H_
</span><span style="color: #0000ff">#define</span> CONDITION_H_<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">NonCopyable.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;pthread.h&gt;

<span style="color: #0000ff">class</span><span style="color: #000000"> MutexLock;

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Condition : NonCopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    Condition(MutexLock </span>&amp;<span style="color: #000000">mutex);
    </span>~<span style="color: #000000">Condition();

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> wait();
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> notify();
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> notifyAll();

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    pthread_cond_t cond_;
    MutexLock </span>&amp;<span style="color: #000000">mutex_;
};

</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">CONDITION_H_</span></pre>
</div>

<p>这里注意几点：</p>

<blockquote>
  <p>1.wait必须在加锁的条件下调用。</p>

  <p>2.notify一次唤醒一个线程，<font color="#ff0000"><strong>通常用来通知资源可用</strong></font>，</p>

  <p>3.notifyAll一次通知多个线程，<strong><font color="#ff0000">通常用来通知状态的改变</font></strong>。滥用broadcast会导致“惊群”问题。</p>
</blockquote>

<p><strong><font color="#ff0000">使用wait必须采用while判断</font></strong>，原因在于：</p>

<blockquote>
  <p>a) 如果采用if，最多判断一次。</p>
</blockquote>

<blockquote>
  <p>b) 线程A等待数据，阻塞在full上，那么当另一个线程放入产品时，通知A去拿数据，此时另一个线程B抢到锁，直接进入临界区，取走资源。A重新抢到锁，（因为采用的是if，所以不会判断第二次）进去临界区时，已经没有资源。</p>
</blockquote>

<blockquote>
  <p>c)防止broadcast的干扰，<strong><font color="#ff0000">如果获得一个资源，使用broadcast会唤醒所有等待的线程，那么多个线程被唤醒，但最终只有一个能拿到资源，这就是所谓的“惊群效应”。</font></strong></p>
</blockquote>

<p>cpp代码实现如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Condition.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">MutexLock.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;assert.h&gt;<span style="color: #000000">

Condition::Condition(MutexLock </span>&amp;<span style="color: #000000">mutex)
    :mutex_(mutex)
{
    TINY_CHECK(</span>!pthread_cond_init(&amp;<span style="color: #000000">cond_, NULL));
}

Condition::</span>~<span style="color: #000000">Condition()
{
    TINY_CHECK(</span>!pthread_cond_destroy(&amp;<span style="color: #000000">cond_));
}


</span><span style="color: #0000ff">void</span><span style="color: #000000"> Condition::wait()
{
    assert(mutex_.isLocking()); </span><span style="color: #008000">//</span><span style="color: #008000">wait前必须上锁</span>
    TINY_CHECK(!pthread_cond_wait(&amp;<span style="color: #000000">cond_, mutex_.getMutexPtr()));
    mutex_.restoreMutexStatus(); </span><span style="color: #008000">//</span><span style="color: #008000">还原状态</span>
<span style="color: #000000">}

</span><span style="color: #0000ff">void</span><span style="color: #000000"> Condition::notify()
{
    TINY_CHECK(</span>!pthread_cond_signal(&amp;<span style="color: #000000">cond_));
}

</span><span style="color: #0000ff">void</span><span style="color: #000000"> Condition::notifyAll()
{
    TINY_CHECK(</span>!pthread_cond_broadcast(&amp;<span style="color: #000000">cond_));
}</span></pre>
</div>



<p>注意wait后面调用了restoreMutexStatus将mutex的状态置为true。</p>]]></description></item><item><title>Linux组件封装（一）中互斥锁MutexLock的封装</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008382.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 06 Oct 2014 08:28:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/06/4008382.html</guid><description><![CDATA[<p>本文对Linux中的pthread_mutex_t做一个简易的封装。</p>  <p>互斥锁主要用于互斥，互斥是一种<strong>竞争关系</strong>，主要是某一个系统资源或一段代码，一次做多被一个线程访问。</p>  <p>条件变量主要用于同步，用于协调线程之间的关系，是一种<strong>合作关系</strong>。</p>  <p>Linux中互斥锁的用法很简单，最常用的是以下的几个函数：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">int</span> pthread_mutex_init(pthread_mutex_t *mutex, <span style="color: #0000ff">const</span> pthread_mutexattr_t *<span style="color: #000000">mutexattr);
</span><span style="color: #0000ff">int</span> pthread_mutex_lock(pthread_mutex_t *<span style="color: #000000">mutex);
</span><span style="color: #0000ff">int</span> pthread_mutex_unlock(pthread_mutex_t *<span style="color: #000000">mutex);
</span><span style="color: #0000ff">int</span> pthread_mutex_destroy(pthread_mutex_t *mutex);</pre>
</div>

<p>我们<strong>利用RAII技术，将mutex的初始化和销毁放在构造函数和析构函数中</strong>。</p>

<p>这里注意，pthread系列的函数都是成功时返回0，我采用一个轻量级的检查手段，来判断处理错误。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">用于pthread系列函数的返回值检查</span>
<span style="color: #0000ff">#define</span> TINY_CHECK(exp) \
    <span style="color: #0000ff">if</span>(!<span style="color: #000000">(exp)) \
    {   \
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">File:%s, Line:%d Exp:[</span><span style="color: #800000">&quot;</span> #exp <span style="color: #800000">&quot;</span><span style="color: #800000">] is true, abort.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, __FILE__, __LINE__); abort();\
    }</span></pre>
</div>

<p>代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef MUTEXLOCK_H
</span><span style="color: #0000ff">#define</span> MUTEXLOCK_H<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">NonCopyable.h</span><span style="color: #800000">&quot;</span>
<span style="color: #008000">//</span><span style="color: #008000">#include &lt;boost/noncopyable.hpp&gt;</span>
#include &lt;pthread.h&gt;<span style="color: #000000">
#include </span>&lt;stdio.h&gt;<span style="color: #000000">
#include </span>&lt;stdlib.h&gt;

<span style="color: #008000">//</span><span style="color: #008000">用于pthread系列函数的返回值检查</span>
<span style="color: #0000ff">#define</span> TINY_CHECK(exp) \
    <span style="color: #0000ff">if</span>(!<span style="color: #000000">(exp)) \
    {   \
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">File:%s, Line:%d Exp:[</span><span style="color: #800000">&quot;</span> #exp <span style="color: #800000">&quot;</span><span style="color: #800000">] is true, abort.\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, __FILE__, __LINE__); abort();\
    }


</span><span style="color: #0000ff">class</span><span style="color: #000000"> MutexLock : NonCopyable
{
    friend </span><span style="color: #0000ff">class</span><span style="color: #000000"> Condition;
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    MutexLock();
    </span>~<span style="color: #000000">MutexLock();
    </span><span style="color: #0000ff">void</span> <span style="color: #0000ff">lock</span><span style="color: #000000">();
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> unlock();

    </span><span style="color: #0000ff">bool</span> isLocking() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> isLocking_; }
    pthread_mutex_t </span>*getMutexPtr() <span style="color: #008000">//</span><span style="color: #008000">思考为什么不是const</span>
    { <span style="color: #0000ff">return</span> &amp;<span style="color: #000000">mutex_; } 

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span> restoreMutexStatus() <span style="color: #008000">//</span><span style="color: #008000">提供给Condition的wait使用</span>
    { isLocking_ = <span style="color: #0000ff">true</span><span style="color: #000000">; }


    pthread_mutex_t mutex_;
    </span><span style="color: #0000ff">bool</span> isLocking_; <span style="color: #008000">//</span><span style="color: #008000">是否上锁</span>
<span style="color: #000000">};


</span><span style="color: #0000ff">class</span><span style="color: #000000"> MutexLockGuard : NonCopyable
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    MutexLockGuard(MutexLock </span>&amp;<span style="color: #000000">mutex) :mutex_(mutex)
    { mutex_.</span><span style="color: #0000ff">lock</span><span style="color: #000000">(); }
    </span>~<span style="color: #000000">MutexLockGuard()
    { mutex_.unlock(); }
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    MutexLock </span>&amp;<span style="color: #000000">mutex_;
};


</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">MUTEXLOCK_H</span></pre>
</div>

<p>cpp文件：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">MutexLock.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;assert.h&gt;<span style="color: #000000">

MutexLock::MutexLock()
    :isLocking_(</span><span style="color: #0000ff">false</span><span style="color: #000000">)
{
    TINY_CHECK(</span>!pthread_mutex_init(&amp;<span style="color: #000000">mutex_, NULL));
}

MutexLock::</span>~<span style="color: #000000">MutexLock()
{
    assert(</span>!isLocking());<span style="color: #008000">//</span><span style="color: #008000">确保解锁</span>
    TINY_CHECK(!pthread_mutex_destroy(&amp;<span style="color: #000000">mutex_));
}


</span><span style="color: #0000ff">void</span> MutexLock::<span style="color: #0000ff">lock</span><span style="color: #000000">()
{
    
    TINY_CHECK(</span>!pthread_mutex_lock(&amp;<span style="color: #000000">mutex_));
    isLocking_ </span>= <span style="color: #0000ff">true</span><span style="color: #000000">;
}

</span><span style="color: #0000ff">void</span><span style="color: #000000"> MutexLock::unlock()
{
    isLocking_ </span>= <span style="color: #0000ff">false</span><span style="color: #000000">;
    TINY_CHECK(</span>!pthread_mutex_unlock(&amp;<span style="color: #000000">mutex_));
}</span></pre>
</div>

<p>后面我们可以继续使用RAII，将lock和unlock封装在同一个类中。</p>]]></description></item><item><title>迭代器适配器（二）general inserter的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/05/4007344.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 05 Oct 2014 11:54:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/05/4007344.html</guid><description><![CDATA[<p>上节我们实现了back_inserter和front_inserter，接下来是更为普通的插入迭代器，它允许用户指定插入位置。</p>
<p>实现代码如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #000000;">#ifndef ITERATOR_HPP
</span><span style="color: #0000ff;">#define</span> ITERATOR_HPP<span style="color: #000000;">

template </span>&lt;typename Container&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> InsertIterator
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    typedef typename Container::value_type value_type;
    typedef typename Container::iterator iterator;

    InsertIterator(Container </span>&amp;<span style="color: #000000;">cont, iterator iter) :cont_(cont), iter_(iter) { }

    InsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> value_type &amp;<span style="color: #000000;">val)
    {
        cont_.insert(iter_, val);
        </span>++<span style="color: #000000;">iter_;
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

    InsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>*<span style="color: #000000;">()
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

    InsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>++<span style="color: #000000;">()
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }
    InsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>++(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }


</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    Container </span>&amp;<span style="color: #000000;">cont_;
    iterator iter_;
};

template </span>&lt;typename Container&gt;<span style="color: #000000;">
InsertIterator</span>&lt;Container&gt; inserter(Container &amp;<span style="color: #000000;">c)
{
    </span><span style="color: #0000ff;">return</span> InsertIterator&lt;Container&gt;<span style="color: #000000;">(c);
}


</span><span style="color: #0000ff;">#endif</span> <span style="color: #008000;">//</span><span style="color: #008000;">ITERATOR_HPP</span></pre>
</div>
<p>可以看出，赋值操作使得内部存储的迭代器前移，而++操作同样什么都没有做。</p>
<p>或许我们想：可不可以在赋值操作符中不改变迭代器，而是到了++中改变？</p>
<p>答案是否定的。</p>
<p>设想，按照刚才设想的去实现，那么如果用户做了以下操作：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>iter++<span style="color: #000000;">;
iter</span>++<span style="color: #000000;">;
iter</span>++<span style="color: #000000;">;
</span>*iter = <span style="color: #800080;">2</span>;</pre>
</div>
<p>那么我们没法保证最后一行时，iter指向的位置是可以插入元素的。</p>
<p>那么上面的写法为什么可行？原因是执行insert操作时，有个特殊位置为end()，它指向最后一个元素的下一个位置，也就是第一个非法的位置。这也是<strong>唯一一个合法的非法位置</strong>。</p>
<p>按照上面源码的实现，仅仅在赋值时迭代器前移，iter++无实质操作，而赋值时前移，iter实际指向了新的end()位置，<strong>就保证了无论用户怎么执行++操作，都丝毫不会影响iter的有效性</strong>。</p>
<p>测试代码如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">Iterator.hpp</span><span style="color: #800000;">"</span><span style="color: #000000;">
#include </span>&lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> printElems(<span style="color: #0000ff;">const</span> T &amp;t, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">string</span> &amp;s = <span style="color: #800000;">""</span><span style="color: #000000;">)
{
    cout </span>&lt;&lt; s &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(typename T::const_iterator it =<span style="color: #000000;"> t.begin();
        it </span>!=<span style="color: #000000;"> t.end();
        </span>++<span style="color: #000000;">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
    cout </span>&lt;&lt;<span style="color: #000000;"> endl;
}

</span><span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">char</span> <span style="color: #0000ff;">const</span> *<span style="color: #000000;">argv[])
{
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> coll;
    coll.push_back(</span><span style="color: #800080;">12</span><span style="color: #000000;">);
    coll.push_back(</span><span style="color: #800080;">34</span><span style="color: #000000;">);
    coll.push_back(</span><span style="color: #800080;">32</span><span style="color: #000000;">);
    printElems(coll);


    inserter(coll, coll.begin()) </span>= <span style="color: #800080;">99</span><span style="color: #000000;">; 
    inserter(coll, coll.begin()) </span>= <span style="color: #800080;">88</span><span style="color: #000000;">;

    printElems(coll);

    inserter(coll, coll.end()) </span>= <span style="color: #800080;">34</span><span style="color: #000000;">; 
    inserter(coll, coll.end()) </span>= <span style="color: #800080;">21</span><span style="color: #000000;">;

    printElems(coll);

    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>]]></description></item><item><title>迭代器适配器（一）back_inserter和front_inserter的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/05/4007317.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 05 Oct 2014 11:12:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/05/4007317.html</guid><description><![CDATA[<p>本文讨论back_inserter和front_inserter的实现。</p>
<p>当我们调用copy函数的时候，要确保目标容器具有足够大的空间，例如：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>//<span style="color: #000000;">将other的所有元素拷贝到以coll.begin()为起始地址的位置
copy(other.begin(), other.end(), coll.begin());</span></pre>
</div>
<p>如果之前没有为coll分配好内存，那么会引发越界错误。</p>
<p>如果我们无法提前预分配内存，那么怎么办？我们可以使用如下的代码：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>//<span style="color: #000000;">将other的所有元素拷贝到以coll.begin()为起始地址的位置
copy(other.begin(), other.end(), back_inserter(coll.begin()));</span></pre>
</div>
<p>我们用了一个东西叫做back_inserter，它是一种插入迭代器（后面你会看到，它实际是个函数），那么插入迭代器是什么？</p>
<p>我们知道，迭代器用来实现容器操作的一种抽象，有了迭代器，那么我们遍历所有容器，采用的几乎都是同一种方式，换句话说，迭代器帮我们屏蔽了容器操作的细节。</p>
<p>对于元素的插入，不同的容器有不同的操作，例如push_back、insert等，插入迭代器就是帮我们屏蔽插入元素的细节，<strong>使得iter看起来总是指向一个&ldquo;可用的位置&rdquo;。</strong></p>
<p>back_inserter的使用如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>#include &lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> printElems(<span style="color: #0000ff;">const</span> T &amp;t, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">string</span> &amp;s = <span style="color: #800000;">""</span><span style="color: #000000;">)
{
    cout </span>&lt;&lt; s &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(typename T::const_iterator it =<span style="color: #000000;"> t.begin();
        it </span>!=<span style="color: #000000;"> t.end();
        </span>++<span style="color: #000000;">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
    cout </span>&lt;&lt;<span style="color: #000000;"> endl;
}

</span><span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">char</span> <span style="color: #0000ff;">const</span> *<span style="color: #000000;">argv[])
{
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> coll;
    back_insert_iterator</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> iter(coll);
    </span>*iter = <span style="color: #800080;">1</span><span style="color: #000000;">;
    iter</span>++<span style="color: #000000;">;
    </span>*iter = <span style="color: #800080;">2</span><span style="color: #000000;">;
    </span>++<span style="color: #000000;">iter;
    </span>*iter = <span style="color: #800080;">3</span><span style="color: #000000;">;
    printElems(coll);


    back_inserter(coll) </span>= <span style="color: #800080;">44</span><span style="color: #000000;">;
    back_inserter(coll) </span>= <span style="color: #800080;">55</span><span style="color: #000000;">;

    printElems(coll);

    copy(coll.begin(), coll.end(), back_inserter(coll));
    printElems(coll);

    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>可以看出，插入迭代器的使用很简易，而且不需要我们考虑内存的分配，因为迭代器内部帮我们处理了这些细节。正如前面所说，插入迭代器总是指向一块可用的位置，我们很快即将看到它的细节实现。</p>
<p>需要注意一下几点：</p>
<blockquote>
<p>1.插入迭代器本质上是一种适配器，但是它看起来像一个迭代器，行为像一个迭代器，那么他就符合迭代器的定义。</p>
<p>2.插入迭代器的赋值，内部采用了插入元素的做法，可能调用容器的push_back push_front或者insert等。</p>
<p>3.插入迭代器的++操作，<strong>只是个幌子，但必不可少</strong>。以上面的copy为例，内部肯定调用了iter++，因为copy函数只是把它当做普通迭代器。</p>
<p>4.解引用操作同样也是幌子。</p>
</blockquote>
<p>back_inserter和front_inserter实现代码如下</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #000000;">#ifndef ITERATOR_HPP
</span><span style="color: #0000ff;">#define</span> ITERATOR_HPP<span style="color: #000000;">

template </span>&lt;typename Container&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> BackInsertIterator
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    typedef typename Container::value_type value_type;

    </span><span style="color: #0000ff;">explicit</span> BackInsertIterator(Container &amp;<span style="color: #000000;">cont) :cont_(cont) { }

    BackInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> value_type &amp;<span style="color: #000000;">val)
    {
        cont_.insert(cont_.end(), val);
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

    BackInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>*<span style="color: #000000;">()
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

    BackInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>++<span style="color: #000000;">()
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">iter++没有实质操作，所以也是返回引用</span>
    BackInsertIterator&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>++(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }


</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    Container </span>&amp;<span style="color: #000000;">cont_;
};

template </span>&lt;typename Container&gt;<span style="color: #000000;">
BackInsertIterator</span>&lt;Container&gt; backInserter(Container &amp;<span style="color: #000000;">c)
{
    </span><span style="color: #0000ff;">return</span> BackInsertIterator&lt;Container&gt;<span style="color: #000000;">(c);
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">FrontInsertIterator</span>
template &lt;typename Container&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> FrontInsertIterator
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    typedef typename Container::value_type value_type;

    </span><span style="color: #0000ff;">explicit</span> FrontInsertIterator(Container &amp;<span style="color: #000000;">cont) :cont_(cont) { }

    FrontInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> value_type &amp;<span style="color: #000000;">val)
    {
        cont_.insert(cont_.begin(), val);
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

    FrontInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>*<span style="color: #000000;">()
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

    FrontInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>++<span style="color: #000000;">()
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }
    FrontInsertIterator</span>&lt;Container&gt; &amp;<span style="color: #0000ff;">operator</span>++(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }


</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    Container </span>&amp;<span style="color: #000000;">cont_;
};

template </span>&lt;typename Container&gt;<span style="color: #000000;">
FrontInsertIterator</span>&lt;Container&gt; frontInserter(Container &amp;<span style="color: #000000;">c)
{
    </span><span style="color: #0000ff;">return</span> FrontInsertIterator&lt;Container&gt;<span style="color: #000000;">(c);
}</span></pre>
<pre></pre>
<pre>#endif //ITERATOR_HPP</pre>
</div>
<p>&nbsp;</p>
<p>从上面的源码我们可以看到，二者插入均采用的insert操作。当然，<strong>调用push_back和push_front也是可以的</strong>。</p>]]></description></item><item><title>标准库priority_queue的一种实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/05/4007130.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 05 Oct 2014 08:37:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/05/4007130.html</guid><description><![CDATA[<p>优先级队列相对于普通队列，提供了插队功能，每次最先出队的不是最先入队的元素，而是优先级最高的元素。</p>  <p>它的实现采用了标准库提供的heap算法。该系列算法一共提供了四个函数。使用方式如下：</p>  <p>首先，建立一个容器，放入元素：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>vector&lt;<span style="color: #0000ff">int</span>&gt;<span style="color: #000000"> coll;
insertNums(coll, </span><span style="color: #800080">3</span>, <span style="color: #800080">7</span><span style="color: #000000">);
insertNums(coll, </span><span style="color: #800080">5</span>, <span style="color: #800080">9</span><span style="color: #000000">);
insertNums(coll, </span><span style="color: #800080">1</span>, <span style="color: #800080">4</span><span style="color: #000000">);

printElems(coll, </span><span style="color: #800000">&quot;</span><span style="color: #800000">all elements: </span><span style="color: #800000">&quot;</span>);</pre>
</div>

<p>打印结果为：
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre><span style="color: #000000">all elements: 
</span><span style="color: #800080">3</span> <span style="color: #800080">4</span> <span style="color: #800080">5</span> <span style="color: #800080">6</span> <span style="color: #800080">7</span> <span style="color: #800080">5</span> <span style="color: #800080">6</span> <span style="color: #800080">7</span> <span style="color: #800080">8</span> <span style="color: #800080">9</span> <span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> <span style="color: #800080">4</span></pre>
  </div>
</p>

<p>然后我们调用make_heap，<strong>这个算法把[beg, end)内的元素建立成堆</strong>。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">make_heap(coll.begin(), coll.end());

printElems(coll, </span><span style="color: #808080">&quot;</span><span style="color: #808080">after make_heap: &quot;);</span></pre>
</div>

<p>打印结果：
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre><span style="color: #000000">after make_heap: 
</span><span style="color: #800080">9</span> <span style="color: #800080">8</span> <span style="color: #800080">6</span> <span style="color: #800080">7</span> <span style="color: #800080">7</span> <span style="color: #800080">5</span> <span style="color: #800080">5</span> <span style="color: #800080">3</span> <span style="color: #800080">6</span> <span style="color: #800080">4</span> <span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> <span style="color: #800080">4</span></pre>
  </div>
</p>

<p>然后我们调用pop_heap，这个算法<strong>必须保证[beg, end)已经是一个heap</strong>，然后它将堆顶的元素（其实是begin指向的元素）放到最后，<strong>再把[begin. end-1)内的元素重新调整为heap</strong></p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">pop_heap(coll.begin(), coll.end());
coll.pop_back();
printElems(coll, </span><span style="color: #808080">&quot;</span><span style="color: #808080">after pop_heap: &quot;);</span></pre>
</div>





<p>打印结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">after pop_heap: 
</span><span style="color: #800080">8</span> <span style="color: #800080">7</span> <span style="color: #800080">6</span> <span style="color: #800080">7</span> <span style="color: #800080">4</span> <span style="color: #800080">5</span> <span style="color: #800080">5</span> <span style="color: #800080">3</span> <span style="color: #800080">6</span> <span style="color: #800080">4</span> <span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span></pre>
</div>



<p>接下来我们调用push_heap，该算法<strong>必须保证[beg, end-1)已经是一个heap</strong>，然后将整个[beg, end)调整为heap</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>coll.push_back(<span style="color: #800080">17</span><span style="color: #000000">);
push_heap(coll.begin(), coll.end());

printElems(coll, </span><span style="color: #808080">&quot;</span><span style="color: #808080">after push_heap: &quot;);</span></pre>
</div>

<p>打印结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">after push_heap: 
</span><span style="color: #800080">17</span> <span style="color: #800080">7</span> <span style="color: #800080">8</span> <span style="color: #800080">7</span> <span style="color: #800080">4</span> <span style="color: #800080">5</span> <span style="color: #800080">6</span> <span style="color: #800080">3</span> <span style="color: #800080">6</span> <span style="color: #800080">4</span> <span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> <span style="color: #800080">5</span></pre>
</div>



<p>最后我们使用sort_heap将[beg, end)由heap转化为有序序列，所以，<strong>前提是[beg, end)已经是一个heap</strong></p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">sort_heap(coll.begin(), coll.end());
printElems(coll, </span><span style="color: #808080">&quot;</span><span style="color: #808080">after sort_heap: &quot;);</span></pre>
</div>

<p>打印结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">after sort_heap: 
</span><span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> <span style="color: #800080">3</span> <span style="color: #800080">4</span> <span style="color: #800080">4</span> <span style="color: #800080">5</span> <span style="color: #800080">5</span> <span style="color: #800080">6</span> <span style="color: #800080">6</span> <span style="color: #800080">7</span> <span style="color: #800080">7</span> <span style="color: #800080">8</span> <span style="color: #800080">17</span></pre>
</div>



<p>完整的测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include &lt;iostream&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000">
#include </span>&lt;vector&gt;<span style="color: #000000">
#include </span>&lt;algorithm&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> insertNums(T &amp;t, <span style="color: #0000ff">int</span> beg, <span style="color: #0000ff">int</span><span style="color: #000000"> end)
{
    </span><span style="color: #0000ff">while</span>(beg &lt;=<span style="color: #000000"> end)
    {
        t.insert(t.end(), beg);
        </span>++<span style="color: #000000">beg;
    }    
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> printElems(<span style="color: #0000ff">const</span> T &amp;t, <span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span> &amp;s = <span style="color: #800000">&quot;&quot;</span><span style="color: #000000">)
{
    cout </span>&lt;&lt; s &lt;&lt;<span style="color: #000000"> endl;
    </span><span style="color: #0000ff">for</span>(typename T::const_iterator it =<span style="color: #000000"> t.begin();
        it </span>!=<span style="color: #000000"> t.end();
        </span>++<span style="color: #000000">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000">&quot;</span> <span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
    cout </span>&lt;&lt;<span style="color: #000000"> endl;
}


</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    vector</span>&lt;<span style="color: #0000ff">int</span>&gt;<span style="color: #000000"> coll;
    insertNums(coll, </span><span style="color: #800080">3</span>, <span style="color: #800080">7</span><span style="color: #000000">);
    insertNums(coll, </span><span style="color: #800080">5</span>, <span style="color: #800080">9</span><span style="color: #000000">);
    insertNums(coll, </span><span style="color: #800080">1</span>, <span style="color: #800080">4</span><span style="color: #000000">);

    printElems(coll, </span><span style="color: #800000">&quot;</span><span style="color: #800000">all elements: </span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #008000">//</span><span style="color: #008000">在这个范围内构造heap</span>
<span style="color: #000000">    make_heap(coll.begin(), coll.end());

    printElems(coll, </span><span style="color: #800000">&quot;</span><span style="color: #800000">after make_heap: </span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #008000">//</span><span style="color: #008000">将堆首放到最后一个位置，其余位置调整成堆</span>
<span style="color: #000000">    pop_heap(coll.begin(), coll.end());
    coll.pop_back();
    printElems(coll, </span><span style="color: #800000">&quot;</span><span style="color: #800000">after pop_heap: </span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    coll.push_back(</span><span style="color: #800080">17</span><span style="color: #000000">);
    push_heap(coll.begin(), coll.end());

    printElems(coll, </span><span style="color: #800000">&quot;</span><span style="color: #800000">after push_heap: </span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    sort_heap(coll.begin(), coll.end());
    printElems(coll, </span><span style="color: #800000">&quot;</span><span style="color: #800000">after sort_heap: </span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>&#160;</p>

<p>根据以上的算法，我们来实现标准库的优先级队列priority_queue，代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef PRIORITY_QUEUE_HPP
</span><span style="color: #0000ff">#define</span> PRIORITY_QUEUE_HPP<span style="color: #000000">

#include </span>&lt;vector&gt;<span style="color: #000000">
#include </span>&lt;algorithm&gt;<span style="color: #000000">
#include </span>&lt;functional&gt;<span style="color: #000000">

template </span>&lt;<span style="color: #000000">typename T, 
          typename Container </span>= std::vector&lt;T&gt;<span style="color: #000000">, 
          typename Compare </span>= std::less&lt;typename Container::value_type&gt; &gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> PriorityQueue
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef typename Container::value_type value_type; </span><span style="color: #008000">//</span><span style="color: #008000">不用T</span>
<span style="color: #000000">    typedef typename Container::size_type size_type;
    typedef Container container_type;
    typedef value_type </span>&amp;<span style="color: #000000">reference;
    typedef </span><span style="color: #0000ff">const</span> value_type &amp;<span style="color: #000000">const_reference;


    PriorityQueue(</span><span style="color: #0000ff">const</span> Compare&amp; comp =<span style="color: #000000"> Compare(),
                  </span><span style="color: #0000ff">const</span> Container&amp; ctnr =<span style="color: #000000"> Container());
    template </span>&lt;<span style="color: #0000ff">class</span> InputIterator&gt;<span style="color: #000000">
    PriorityQueue (InputIterator first, InputIterator last,
                   </span><span style="color: #0000ff">const</span> Compare&amp; comp =<span style="color: #000000"> Compare(),
                   </span><span style="color: #0000ff">const</span> Container&amp; ctnr =<span style="color: #000000"> Container());
    </span><span style="color: #0000ff">void</span> push(<span style="color: #0000ff">const</span> value_type &amp;<span style="color: #000000">val)
    {
        cont_.push_back(val);
        </span><span style="color: #008000">//</span><span style="color: #008000">调整最后一个元素入堆</span>
<span style="color: #000000">        std::push_heap(cont_.begin(), cont_.end(), comp_); 
    }

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> pop()
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">第一个元素移出堆，放在最后</span>
<span style="color: #000000">        std::pop_heap(cont_.begin(), cont_.end(), comp_);
        cont_.pop_back();
    }

    </span><span style="color: #0000ff">bool</span> empty() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.empty(); }
    size_type size() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.size(); }
    const_reference top() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.front(); }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Compare comp_; </span><span style="color: #008000">//</span><span style="color: #008000">比较规则</span>
    Container cont_; <span style="color: #008000">//</span><span style="color: #008000">内部容器</span>
<span style="color: #000000">};

template </span>&lt;typename T, typename Container, typename Compare&gt;<span style="color: #000000">
PriorityQueue</span>&lt;T, Container, Compare&gt;::PriorityQueue(<span style="color: #0000ff">const</span> Compare&amp;<span style="color: #000000"> comp,
                                                    </span><span style="color: #0000ff">const</span> Container&amp;<span style="color: #000000"> ctnr)
    :comp_(comp), cont_(ctnr)
{
    std::make_heap(cont_.begin(), cont_.end(), comp_); </span><span style="color: #008000">//</span><span style="color: #008000">建堆</span>
<span style="color: #000000">}

template </span>&lt;typename T, typename Container, typename Compare&gt;<span style="color: #000000">
template </span>&lt;<span style="color: #0000ff">class</span> InputIterator&gt;<span style="color: #000000">
PriorityQueue</span>&lt;T, Container, Compare&gt;<span style="color: #000000">::PriorityQueue (InputIterator first, 
                                                     InputIterator last,
                                                     </span><span style="color: #0000ff">const</span> Compare&amp;<span style="color: #000000"> comp,
                                                     </span><span style="color: #0000ff">const</span> Container&amp;<span style="color: #000000"> ctnr)
    :comp_(comp), cont_(ctnr)
{
    cont_.insert(cont_.end(), first, last);
    std::make_heap(cont_.begin(), cont_.end(), comp_);
}

</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">PRIORITY_QUEUE_HPP</span></pre>
</div>



<p>我们注意到：</p>

<blockquote>
  <p>1.优先级队列内部保存了排序规则，这与map和set是一致的。</p>

  <p>2.前面我们提到heap算法除了make_heap之外，都必须保证之前是一个建好的heap，这里我们在构造函数中调用make_heap，保证了后面的各种heap算法都是合法的。</p>

  <p>3.还有一点，如果T与容器的类型不一致，例如PriorityQueue&lt;float, vector&lt;int&gt; &gt;，<strong>那么我们的value_type优先采用int</strong>，毕竟我们操作的对象是容器。</p>
</blockquote>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">PriorityQueue.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;iostream&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    PriorityQueue</span>&lt;<span style="color: #0000ff">float</span>&gt;<span style="color: #000000"> q;
    q.push(</span><span style="color: #800080">66.6</span><span style="color: #000000">);
    q.push(</span><span style="color: #800080">22.3</span><span style="color: #000000">);
    q.push(</span><span style="color: #800080">44.4</span><span style="color: #000000">);


    cout </span>&lt;&lt; q.top() &lt;&lt;<span style="color: #000000"> endl;
    q.pop();
    cout </span>&lt;&lt; q.top() &lt;&lt;<span style="color: #000000"> endl;
    q.pop();

    q.push(</span><span style="color: #800080">11.1</span><span style="color: #000000">);
    q.push(</span><span style="color: #800080">55.5</span><span style="color: #000000">);
    q.push(</span><span style="color: #800080">33.3</span><span style="color: #000000">);
    q.pop();

    </span><span style="color: #0000ff">while</span>(!<span style="color: #000000">q.empty())
    {
        cout </span>&lt;&lt; q.top() &lt;&lt; <span style="color: #800000">&quot;</span> <span style="color: #800000">&quot;</span><span style="color: #000000">;
        q.pop();
    }
    cout </span>&lt;&lt;<span style="color: #000000"> endl;


    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>]]></description></item><item><title>标准库Queue的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/04/4006336.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 04 Oct 2014 12:29:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/04/4006336.html</guid><description><![CDATA[<p>跟上篇实现stack的思路一致，我增加了一些成员函数模板，支持不同类型的Queue之间的复制和赋值。</p>  <p>同时提供一个异常类。</p>  <p>代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef QUEUE_HPP
</span><span style="color: #0000ff">#define</span> QUEUE_HPP<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">Exception.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;deque&gt;

<span style="color: #0000ff">class</span> EmptyQueueException : <span style="color: #0000ff">public</span><span style="color: #000000"> Exception
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    EmptyQueueException() :Exception(</span><span style="color: #800000">&quot;</span><span style="color: #800000">read empty queue</span><span style="color: #800000">&quot;</span><span style="color: #000000">) { }
};

template </span>&lt;typename T, typename Container = std::deque&lt;T&gt; &gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> Queue
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef T value_type;
    typedef T</span>&amp;<span style="color: #000000"> reference;
    typedef </span><span style="color: #0000ff">const</span> T&amp;<span style="color: #000000"> const_reference;
    typedef Container container_type; </span><span style="color: #008000">//</span><span style="color: #008000">容器类型</span>
    typedef EmptyQueueException exception_type; <span style="color: #008000">//</span><span style="color: #008000">异常类型</span>
<span style="color: #000000">    typedef typename Container::size_type size_type;
    typedef Container </span>&amp;container_reference; <span style="color: #008000">//</span><span style="color: #008000">容器引用</span>
    typedef <span style="color: #0000ff">const</span> Container&amp;<span style="color: #000000"> const_container_reference;

    </span><span style="color: #0000ff">explicit</span> Queue(const_container_reference cont =<span style="color: #000000"> container_type()) :cont_(cont) { }

    template </span>&lt;typename T2, typename Container2&gt;<span style="color: #000000">
    Queue</span>&lt;T, Container&gt;(<span style="color: #0000ff">const</span> Queue&lt;T2, Container2&gt; &amp;<span style="color: #000000">other);

    template </span>&lt;typename T2, typename Container2&gt;<span style="color: #000000">
    Queue</span>&lt;T, Container&gt; &amp;<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> Queue&lt;T2, Container2&gt; &amp;<span style="color: #000000">other);

    </span><span style="color: #0000ff">void</span> push(<span style="color: #0000ff">const</span> value_type &amp;<span style="color: #000000">val)
    {
        cont_.push_back(val);
    }

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> pop()
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        cont_.pop_front();
    }

    reference front()
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_.front();
    }
    const_reference front() </span><span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_.front();
    }
    reference back()
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_.back();
    }
    const_reference back() </span><span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_.back();
    }


    </span><span style="color: #0000ff">bool</span> empty() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.empty(); }
    size_type size() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.size(); }

    </span><span style="color: #008000">//</span><span style="color: #008000">获取内部容器的引用</span>
    const_container_reference get_container() <span style="color: #0000ff">const</span><span style="color: #000000">
    { </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_; } 


    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Queue &amp;a, <span style="color: #0000ff">const</span> Queue &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ ==<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>!=(<span style="color: #0000ff">const</span> Queue &amp;a, <span style="color: #0000ff">const</span> Queue &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ !=<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&lt;(<span style="color: #0000ff">const</span> Queue &amp;a, <span style="color: #0000ff">const</span> Queue &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &lt;<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&gt;(<span style="color: #0000ff">const</span> Queue &amp;a, <span style="color: #0000ff">const</span> Queue &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &gt;<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&lt;=(<span style="color: #0000ff">const</span> Queue &amp;a, <span style="color: #0000ff">const</span> Queue &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &lt;=<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&gt;=(<span style="color: #0000ff">const</span> Queue &amp;a, <span style="color: #0000ff">const</span> Queue &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &gt;=<span style="color: #000000"> b.cont_;
    }


</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    container_type cont_;
};


template </span>&lt;typename T, typename Container&gt;<span style="color: #000000">
template </span>&lt;typename T2, typename Container2&gt;<span style="color: #000000">
Queue</span>&lt;T, Container&gt;::Queue(<span style="color: #0000ff">const</span> Queue&lt;T2, Container2&gt; &amp;<span style="color: #000000">other)
    :cont_(other.get_container().begin(), other.get_container().end())
{

}

template </span>&lt;typename T, typename Container&gt;<span style="color: #000000">
template </span>&lt;typename T2, typename Container2&gt;<span style="color: #000000">
Queue</span>&lt;T, Container&gt; &amp;Queue&lt;T, Container&gt;::<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> Queue&lt;T2, Container2&gt; &amp;<span style="color: #000000">other)
{
    cont_.assign(other.get_container().begin(), other.get_container().end());
}


</span><span style="color: #0000ff">#endif</span> <span style="color: #008000">//</span><span style="color: #008000">QUEUE_HPP</span></pre>
</div>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Stack.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">Queue.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;iostream&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000">
#include </span>&lt;vector&gt;<span style="color: #000000">
#include </span>&lt;list&gt;<span style="color: #000000">
#include </span>&lt;stdio.h&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
   
    </span><span style="color: #0000ff">try</span><span style="color: #000000">
    {
        Queue</span>&lt;<span style="color: #0000ff">string</span>, vector&lt;<span style="color: #0000ff">string</span>&gt; &gt;<span style="color: #000000"> st;
        st.push(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        st.push(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

        Queue</span>&lt;<span style="color: #0000ff">string</span>, list&lt;<span style="color: #0000ff">string</span>&gt; &gt;<span style="color: #000000"> st2(st);
        </span><span style="color: #008000">//</span><span style="color: #008000">st2 = st;</span>

        <span style="color: #0000ff">while</span>(!<span style="color: #000000">st2.empty())
        {
            cout </span>&lt;&lt; st2.front() &lt;&lt;<span style="color: #000000"> endl;
            st2.pop();
        }

        st2.pop(); </span><span style="color: #008000">//</span><span style="color: #008000">引发异常</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">catch</span> (<span style="color: #0000ff">const</span> Exception&amp;<span style="color: #000000"> ex)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">reason: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.what());
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">stack trace: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.stackTrace());
    }

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>]]></description></item><item><title>标准库Stack的一种实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/04/4006267.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sat, 04 Oct 2014 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/04/4006267.html</guid><description><![CDATA[<p>本文实现了STL中stack的大部分功能，同时添加了一些功能。</p>  <p>注意以下几点：</p>  <blockquote>   <p>1.Stack是一种适配器，底层以vector、list、deque等实现</p>    <p>2.Stack不含有迭代器</p> </blockquote>  <p>在本例中，我添加了几项功能，包括不同类型stack之间的复制和赋值功能，可以实现诸如Stack&lt;int, vector&lt;int&gt; &gt;和Stack&lt;double, list&lt;double&gt; &gt;之间的复制和赋值，这主要依靠成员函数模板来实现。</p>  <p>为了更方便的实现以上功能，我添加了一个函数：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>const_container_reference get_container() <span style="color: #0000ff">const</span></pre>
</div>



<p>来获取内部容器的引用。</p>

<p>此外，标准库的stack不检查越界行为，我为stack添加了异常处理，当栈空时，执行pop或者top会抛出异常。这个异常类继承自Exception（见上篇文章），用来标示栈空。</p>

<p>详细代码如下：Exception的实现见：<a href="http://www.cnblogs.com/inevermore/p/4005489.html" target="_blank">借助backtrace和demangle实现异常类Exception</a></p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef STACK_HPP_
</span><span style="color: #0000ff">#define</span> STACK_HPP_<span style="color: #000000">

#include </span><span style="color: #800000">&quot;</span><span style="color: #800000">Exception.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;deque&gt;

<span style="color: #008000">//</span><span style="color: #008000">栈空引发的异常</span>
<span style="color: #0000ff">class</span> EmptyStackException : <span style="color: #0000ff">public</span><span style="color: #000000"> Exception
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    EmptyStackException() :Exception(</span><span style="color: #800000">&quot;</span><span style="color: #800000">read empty stack</span><span style="color: #800000">&quot;</span><span style="color: #000000">) { }
};


template </span>&lt;typename T, typename Container = std::deque&lt;T&gt; &gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> Stack
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef T value_type;
    typedef T</span>&amp;<span style="color: #000000"> reference;
    typedef </span><span style="color: #0000ff">const</span> T&amp;<span style="color: #000000"> const_reference;
    typedef Container container_type; </span><span style="color: #008000">//</span><span style="color: #008000">容器类型</span>
    typedef EmptyStackException exception_type; <span style="color: #008000">//</span><span style="color: #008000">异常类型</span>
<span style="color: #000000">    typedef typename Container::size_type size_type;
    typedef Container </span>&amp;container_reference; <span style="color: #008000">//</span><span style="color: #008000">容器引用</span>
    typedef <span style="color: #0000ff">const</span> Container&amp;<span style="color: #000000"> const_container_reference;

    explicit Stack(const container_type &amp;cont = container_type()) :cont_(cont) { }</span></pre>

  <pre><span style="color: #000000">
    </span><span style="color: #008000">//</span><span style="color: #008000">不同类型间实现复制</span>
    template &lt;typename T2, typename Container2&gt;<span style="color: #000000">
    Stack</span>&lt;T, Container&gt;(<span style="color: #0000ff">const</span> Stack&lt;T2, Container2&gt; &amp;<span style="color: #000000">s); 

    </span><span style="color: #008000">//</span><span style="color: #008000">不同类型间进行赋值</span>
    template &lt;typename T2, typename Container2&gt;<span style="color: #000000">
    Stack</span>&lt;T, Container&gt; &amp;<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> Stack&lt;T2, Container2&gt; &amp;<span style="color: #000000">s);

    </span><span style="color: #0000ff">void</span> push(<span style="color: #0000ff">const</span> value_type &amp;<span style="color: #000000">val) { cont_.push_back(val); }
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> pop() 
    { 
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        cont_.pop_back(); 
    }

    reference top()
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_.back();
    } 
    const_reference top() </span><span style="color: #0000ff">const</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(cont_.empty())
            </span><span style="color: #0000ff">throw</span><span style="color: #000000"> exception_type();
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_.back();
    }

    </span><span style="color: #0000ff">bool</span> empty() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.empty(); }
    size_type size() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> cont_.size(); }

    </span><span style="color: #008000">//</span><span style="color: #008000">获取内部容器的引用</span>
    const_container_reference get_container() <span style="color: #0000ff">const</span><span style="color: #000000">
    { </span><span style="color: #0000ff">return</span><span style="color: #000000"> cont_; } 


    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Stack &amp;a, <span style="color: #0000ff">const</span> Stack &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ ==<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>!=(<span style="color: #0000ff">const</span> Stack &amp;a, <span style="color: #0000ff">const</span> Stack &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ !=<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&lt;(<span style="color: #0000ff">const</span> Stack &amp;a, <span style="color: #0000ff">const</span> Stack &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &lt;<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&gt;(<span style="color: #0000ff">const</span> Stack &amp;a, <span style="color: #0000ff">const</span> Stack &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &gt;<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&lt;=(<span style="color: #0000ff">const</span> Stack &amp;a, <span style="color: #0000ff">const</span> Stack &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &lt;=<span style="color: #000000"> b.cont_;
    }
    friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>&gt;=(<span style="color: #0000ff">const</span> Stack &amp;a, <span style="color: #0000ff">const</span> Stack &amp;<span style="color: #000000">b)
    {
        </span><span style="color: #0000ff">return</span> a.cont_ &gt;=<span style="color: #000000"> b.cont_;
    }

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    Container cont_;
};

template </span>&lt;typename T, typename Container&gt;<span style="color: #000000">
template </span>&lt;typename T2, typename Container2&gt;<span style="color: #000000">
Stack</span>&lt;T, Container&gt;::Stack(<span style="color: #0000ff">const</span> Stack&lt;T2, Container2&gt; &amp;<span style="color: #000000">s)
    :cont_(s.get_container().begin(), s.get_container().end())
{

}

template </span>&lt;typename T, typename Container&gt;<span style="color: #000000">
template </span>&lt;typename T2, typename Container2&gt;<span style="color: #000000">
Stack</span>&lt;T, Container&gt; &amp;Stack&lt;T, Container&gt;::<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> Stack&lt;T2, Container2&gt; &amp;<span style="color: #000000">s)
{
    </span><span style="color: #0000ff">if</span>((<span style="color: #0000ff">void</span>*)<span style="color: #0000ff">this</span> != (<span style="color: #0000ff">void</span>*)&amp;<span style="color: #000000">s) 
    {
        cont_.assign(s.get_container().begin(), s.get_container().end());
    }
    
    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}


</span><span style="color: #0000ff">#endif</span> /* STACK_HPP_ */</pre>
</div>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Stack.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;iostream&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000">
#include </span>&lt;vector&gt;<span style="color: #000000">
#include </span>&lt;list&gt;<span style="color: #000000">
#include </span>&lt;stdio.h&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
   
    </span><span style="color: #0000ff">try</span><span style="color: #000000">
    {
        Stack</span>&lt;<span style="color: #0000ff">string</span>, vector&lt;<span style="color: #0000ff">string</span>&gt; &gt;<span style="color: #000000"> st;
        st.push(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
        st.push(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

        Stack</span>&lt;<span style="color: #0000ff">string</span>, list&lt;<span style="color: #0000ff">string</span>&gt; &gt;<span style="color: #000000"> st2(st);
        </span><span style="color: #008000">//</span><span style="color: #008000">st2 = st;</span>

        <span style="color: #0000ff">while</span>(!<span style="color: #000000">st2.empty())
        {
            cout </span>&lt;&lt; st2.top() &lt;&lt;<span style="color: #000000"> endl;
            st2.pop();
        }

        st2.pop(); </span><span style="color: #008000">//</span><span style="color: #008000">引发异常</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">catch</span> (<span style="color: #0000ff">const</span> Exception&amp;<span style="color: #000000"> ex)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">reason: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.what());
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">stack trace: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.stackTrace());
    }

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>]]></description></item><item><title>借助backtrace和demangle实现异常类Exception</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/03/4005489.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 03 Oct 2014 15:43:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/03/4005489.html</guid><description><![CDATA[<p>C++的异常类是没有栈痕迹的，如果需要获取栈痕迹，需要使用以下函数：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;execinfo.h&gt;

<span style="color: #0000ff">int</span> backtrace(<span style="color: #0000ff">void</span> **buffer, <span style="color: #0000ff">int</span><span style="color: #000000"> size);

</span><span style="color: #0000ff">char</span> **backtrace_symbols(<span style="color: #0000ff">void</span> *<span style="color: #0000ff">const</span> *buffer, <span style="color: #0000ff">int</span><span style="color: #000000"> size);

</span><span style="color: #0000ff">void</span> backtrace_symbols_fd(<span style="color: #0000ff">void</span> *<span style="color: #0000ff">const</span> *buffer, <span style="color: #0000ff">int</span> size, <span style="color: #0000ff">int</span> fd);</pre>
</div>

<p>backtrace将当前程序的调用信息存储在buffer中，backtrace_symbols则是将buffer翻译为字符串。后者用到了malloc，所以需要手工释放内存。</p>

<p>man手册中提供了如下的代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include &lt;execinfo.h&gt;<span style="color: #000000">
#include </span>&lt;stdio.h&gt;<span style="color: #000000">
#include </span>&lt;stdlib.h&gt;<span style="color: #000000">
#include </span>&lt;unistd.h&gt;

<span style="color: #0000ff">void</span><span style="color: #000000">
myfunc3(</span><span style="color: #0000ff">void</span><span style="color: #000000">)
{
   </span><span style="color: #0000ff">int</span><span style="color: #000000"> j, nptrs;
</span><span style="color: #0000ff">#define</span> SIZE 100
   <span style="color: #0000ff">void</span> *buffer[<span style="color: #800080">100</span><span style="color: #000000">];
   </span><span style="color: #0000ff">char</span> **<span style="color: #000000">strings;

   nptrs </span>=<span style="color: #000000"> backtrace(buffer, SIZE);
   printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">backtrace() returned %d addresses\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, nptrs);

   </span><span style="color: #008000">/*</span><span style="color: #008000"> The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)
      would produce similar output to the following: </span><span style="color: #008000">*/</span><span style="color: #000000">

   strings </span>=<span style="color: #000000"> backtrace_symbols(buffer, nptrs);
   </span><span style="color: #0000ff">if</span> (strings ==<span style="color: #000000"> NULL) {
       perror(</span><span style="color: #800000">&quot;</span><span style="color: #800000">backtrace_symbols</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
       exit(EXIT_FAILURE);
   }

   </span><span style="color: #0000ff">for</span> (j = <span style="color: #800080">0</span>; j &lt; nptrs; j++<span style="color: #000000">)
       printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">%s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, strings[j]);

   free(strings);
}

</span><span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span>   <span style="color: #008000">/*</span><span style="color: #008000"> &quot;static&quot; means don't export the symbol... </span><span style="color: #008000">*/</span><span style="color: #000000">
myfunc2(</span><span style="color: #0000ff">void</span><span style="color: #000000">)
{
   myfunc3();
}

</span><span style="color: #0000ff">void</span><span style="color: #000000">
myfunc(</span><span style="color: #0000ff">int</span><span style="color: #000000"> ncalls)
{
   </span><span style="color: #0000ff">if</span> (ncalls &gt; <span style="color: #800080">1</span><span style="color: #000000">)
       myfunc(ncalls </span>- <span style="color: #800080">1</span><span style="color: #000000">);
   </span><span style="color: #0000ff">else</span><span style="color: #000000">
       myfunc2();
}

</span><span style="color: #0000ff">int</span><span style="color: #000000">
main(</span><span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> *<span style="color: #000000">argv[])
{
   </span><span style="color: #0000ff">if</span> (argc != <span style="color: #800080">2</span><span style="color: #000000">) {
       fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">%s num-calls\n</span><span style="color: #800000">&quot;</span>, argv[<span style="color: #800080">0</span><span style="color: #000000">]);
       exit(EXIT_FAILURE);
   }

   myfunc(atoi(argv[</span><span style="color: #800080">1</span><span style="color: #000000">]));
   exit(EXIT_SUCCESS);
}</span></pre>
</div>

<p>编译并执行：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>$  cc -rdynamic prog.c -<span style="color: #000000">o prog
$ .</span>/prog <span style="color: #800080">3</span></pre>
</div>



<p>输出如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>backtrace() returned <span style="color: #800080">8</span><span style="color: #000000"> addresses
.</span>/prog(myfunc3+<span style="color: #000000">0x1f) [0x8048783]
.</span>/<span style="color: #000000">prog() [0x8048810]
.</span>/prog(myfunc+<span style="color: #000000">0x21) [0x8048833]
.</span>/prog(myfunc+<span style="color: #000000">0x1a) [0x804882c]
.</span>/prog(myfunc+<span style="color: #000000">0x1a) [0x804882c]
.</span>/prog(main+<span style="color: #000000">0x52) [0x8048887]
</span>/lib/i386-linux-gnu/libc.so.<span style="color: #800080">6</span>(__libc_start_main+<span style="color: #000000">0xf3) [0xb76174d3]
.</span>/prog() [0x80486d1]</pre>
</div>



<p>&#160;</p>

<p>因此我写出以下的异常类，注意上面的打印结果经过了名字改编，所以我们使用abi::__cxa_demangle将名字还原出来。</p>

<p>Exception.h</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef EXCEPTION_H_
</span><span style="color: #0000ff">#define</span> EXCEPTION_H_<span style="color: #000000">

#include </span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000">
#include </span>&lt;exception&gt;

<span style="color: #0000ff">class</span> Exception : <span style="color: #0000ff">public</span><span style="color: #000000"> std::exception
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">explicit</span> Exception(<span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>*<span style="color: #000000"> what);
    </span><span style="color: #0000ff">explicit</span> Exception(<span style="color: #0000ff">const</span> std::<span style="color: #0000ff">string</span>&amp;<span style="color: #000000"> what);
    </span><span style="color: #0000ff">virtual</span> ~Exception() <span style="color: #0000ff">throw</span><span style="color: #000000">();
    </span><span style="color: #0000ff">virtual</span> <span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>* what() <span style="color: #0000ff">const</span> <span style="color: #0000ff">throw</span><span style="color: #000000">();
    </span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>* stackTrace() <span style="color: #0000ff">const</span> <span style="color: #0000ff">throw</span><span style="color: #000000">();

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span> fillStackTrace();  <span style="color: #008000">//</span><span style="color: #008000">填充栈痕迹</span>
    std::<span style="color: #0000ff">string</span> demangle(<span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>* symbol); <span style="color: #008000">//</span><span style="color: #008000">反名字改编</span>
<span style="color: #000000">
    std::</span><span style="color: #0000ff">string</span> message_;   <span style="color: #008000">//</span><span style="color: #008000">异常信息</span>
    std::<span style="color: #0000ff">string</span> stack_;     <span style="color: #008000">//</span><span style="color: #008000">栈trace</span>
<span style="color: #000000">};


</span><span style="color: #0000ff">#endif</span>  <span style="color: #008000">//</span><span style="color: #008000"> EXCEPTION_H_</span></pre>
</div>

<p>Exception.cpp</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Exception.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;cxxabi.h&gt;<span style="color: #000000">
#include </span>&lt;execinfo.h&gt;<span style="color: #000000">
#include </span>&lt;stdlib.h&gt;<span style="color: #000000">
#include </span>&lt;stdio.h&gt;

<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

Exception::Exception(</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>*<span style="color: #000000"> msg)
  : message_(msg)
{
    fillStackTrace();
}

Exception::Exception(</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">string</span>&amp;<span style="color: #000000"> msg)
  : message_(msg)
{
    fillStackTrace();
}

Exception::</span>~Exception() <span style="color: #0000ff">throw</span><span style="color: #000000"> ()
{
}

</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>* Exception::what() <span style="color: #0000ff">const</span> <span style="color: #0000ff">throw</span><span style="color: #000000">()
{
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> message_.c_str();
}

</span><span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>* Exception::stackTrace() <span style="color: #0000ff">const</span> <span style="color: #0000ff">throw</span><span style="color: #000000">()
{
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> stack_.c_str();
}

</span><span style="color: #008000">//</span><span style="color: #008000">填充栈痕迹</span>
<span style="color: #0000ff">void</span><span style="color: #000000"> Exception::fillStackTrace()
{
    </span><span style="color: #0000ff">const</span> <span style="color: #0000ff">int</span> len = <span style="color: #800080">200</span><span style="color: #000000">;
    </span><span style="color: #0000ff">void</span>*<span style="color: #000000"> buffer[len];
    </span><span style="color: #0000ff">int</span> nptrs = ::backtrace(buffer, len); <span style="color: #008000">//</span><span style="color: #008000">列出当前函数调用关系
    </span><span style="color: #008000">//</span><span style="color: #008000">将从backtrace函数获取的信息转化为一个字符串数组</span>
    <span style="color: #0000ff">char</span>** strings =<span style="color: #000000"> ::backtrace_symbols(buffer, nptrs); 

    </span><span style="color: #0000ff">if</span><span style="color: #000000"> (strings)
    {
        </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = <span style="color: #800080">0</span>; i &lt; nptrs; ++<span style="color: #000000">i)
        {
          </span><span style="color: #008000">//</span><span style="color: #008000"> TODO demangle funcion name with abi::__cxa_demangle
          </span><span style="color: #008000">//</span><span style="color: #008000">strings[i]代表某一层的调用痕迹</span>
<span style="color: #000000">          stack_.append(demangle(strings[i]));
          stack_.push_back(</span><span style="color: #800000">'</span><span style="color: #800000">\n</span><span style="color: #800000">'</span><span style="color: #000000">);
        }
        free(strings);
    }
}

</span><span style="color: #008000">//</span><span style="color: #008000">反名字改编</span>
<span style="color: #0000ff">string</span> Exception::demangle(<span style="color: #0000ff">const</span> <span style="color: #0000ff">char</span>*<span style="color: #000000"> symbol)
{
    size_t size;
    </span><span style="color: #0000ff">int</span><span style="color: #000000"> status;
    </span><span style="color: #0000ff">char</span> temp[<span style="color: #800080">128</span><span style="color: #000000">];
    </span><span style="color: #0000ff">char</span>*<span style="color: #000000"> demangled;
    </span><span style="color: #008000">//</span><span style="color: #008000">first, try to demangle a c++ name</span>
    <span style="color: #0000ff">if</span> (<span style="color: #800080">1</span> == sscanf(symbol, <span style="color: #800000">&quot;</span><span style="color: #800000">%*[^(]%*[^_]%127[^)+]</span><span style="color: #800000">&quot;</span><span style="color: #000000">, temp)) {
        </span><span style="color: #0000ff">if</span> (NULL != (demangled = abi::__cxa_demangle(temp, NULL, &amp;size, &amp;<span style="color: #000000">status))) {
          </span><span style="color: #0000ff">string</span><span style="color: #000000"> result(demangled);
          free(demangled);
          </span><span style="color: #0000ff">return</span><span style="color: #000000"> result;
        }
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">if that didn't work, try to get a regular c symbol</span>
    <span style="color: #0000ff">if</span> (<span style="color: #800080">1</span> == sscanf(symbol, <span style="color: #800000">&quot;</span><span style="color: #800000">%127s</span><span style="color: #800000">&quot;</span><span style="color: #000000">, temp)) {
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> temp;
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">if all else fails, just return the symbol</span>
    <span style="color: #0000ff">return</span><span style="color: #000000"> symbol;
}</span></pre>
</div>



<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Exception.h</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;stdio.h&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Bar
{
 </span><span style="color: #0000ff">public</span><span style="color: #000000">:
  </span><span style="color: #0000ff">void</span><span style="color: #000000"> test()
  {
    </span><span style="color: #0000ff">throw</span> Exception(<span style="color: #800000">&quot;</span><span style="color: #800000">oops</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
  }
};

</span><span style="color: #0000ff">void</span><span style="color: #000000"> foo()
{
  Bar b;
  b.test();
}

</span><span style="color: #0000ff">int</span><span style="color: #000000"> main()
{
  </span><span style="color: #0000ff">try</span><span style="color: #000000">
  {
    foo();
  }
  </span><span style="color: #0000ff">catch</span> (<span style="color: #0000ff">const</span> Exception&amp;<span style="color: #000000"> ex)
  {
    printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">reason: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.what());
    printf(</span><span style="color: #800000">&quot;</span><span style="color: #800000">stack trace: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.stackTrace());
  }
}</span></pre>
</div>



<p>打印结果如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">reason: oops
stack trace: Exception::fillStackTrace()
Exception::Exception(</span><span style="color: #0000ff">char</span> const*<span style="color: #000000">)
Bar::test()
foo()
.</span>/a.out(main+<span style="color: #000000">0xf)
</span>/lib/i386-linux-gnu/libc.so.<span style="color: #800080">6</span>(__libc_start_main+<span style="color: #000000">0xf3)
.</span>/a.out()</pre>
</div>



<p>注意编译的时候，<strong>加上-rdynamic选项</strong></p>

<p>&#160;</p>

<p>有了这个类，我们可以在程序中这样处理异常：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">try</span><span style="color: #000000">
    {
        </span><span style="color: #008000">//
</span><span style="color: #000000">    }
    </span><span style="color: #0000ff">catch</span> (<span style="color: #0000ff">const</span> Exception&amp;<span style="color: #000000"> ex)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">reason: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.what());
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">stack trace: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.stackTrace());
        abort();
    }
    </span><span style="color: #0000ff">catch</span> (<span style="color: #0000ff">const</span> std::exception&amp;<span style="color: #000000"> ex)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">reason: %s\n</span><span style="color: #800000">&quot;</span><span style="color: #000000">, ex.what());
        abort();
    }
    </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (...)
    {
        fprintf(stderr, </span><span style="color: #800000">&quot;</span><span style="color: #800000">unknown exception caught \n</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    </span><span style="color: #0000ff">throw</span>; <span style="color: #008000">//</span><span style="color: #008000"> rethrow</span>
    }</pre>
</div>]]></description></item><item><title>标准库Allocator(三)uninitialized_fill等函数的实现</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/03/4004655.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 02 Oct 2014 16:40:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/03/4004655.html</guid><description><![CDATA[<p>前面我们使用了uninitialized_fill，来批量初始化某一段内存。</p>  <p>下面提供三个函数的实现代码，这三个代码的共同点是：</p>  <blockquote>   <p>1.遇到错误，抛出异常</p>    <p>2.出现异常时，把之前构造的对象全部销毁</p> </blockquote>  <p>所以，这三个函数要么成功，要么无任何副作用。使用异常来通知使用者，所以在catch块中，处理完异常后<strong>要将异常再次向外抛出</strong>。</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef MEMORY_HPP
</span><span style="color: #0000ff">#define</span> MEMORY_HPP<span style="color: #000000">

#include </span>&lt;iterator&gt;<span style="color: #000000">

template </span>&lt;typename ForwIter, typename T&gt;
<span style="color: #0000ff">void</span> uninitialized_fill(ForwIter beg, ForwIter end, <span style="color: #0000ff">const</span> T &amp;<span style="color: #000000"> value)
{
    typedef typename std::iterator_traits</span>&lt;ForwIter&gt;<span style="color: #000000">::value_type VT;
    ForwIter save(beg); </span><span style="color: #008000">//</span><span style="color: #008000">备份beg的初始值</span>
    <span style="color: #0000ff">try</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">for</span>(; beg != end ; ++<span style="color: #000000">beg)
        {
            </span><span style="color: #0000ff">new</span> (static_cast&lt;<span style="color: #0000ff">void</span> *&gt;(&amp;*<span style="color: #000000">beg))VT(value);
        }
    }
    </span><span style="color: #0000ff">catch</span>(...) <span style="color: #008000">//</span><span style="color: #008000">抛出异常</span>
<span style="color: #000000">    {
        </span><span style="color: #0000ff">for</span>(; save != beg; ++<span style="color: #000000">save)
        {
            save</span>-&gt;~VT();    <span style="color: #008000">//</span><span style="color: #008000">逐个进行析构</span>
<span style="color: #000000">        }
        </span><span style="color: #0000ff">throw</span>; <span style="color: #008000">//</span><span style="color: #008000">将catch的异常再次抛出</span>
<span style="color: #000000">    }
}


template </span>&lt;typename ForwIter, typename Size, typename T&gt;
<span style="color: #0000ff">void</span> uninitialized_fill_n(ForwIter beg, Size num, <span style="color: #0000ff">const</span> T &amp;<span style="color: #000000"> value)
{
    typedef typename std::iterator_traits</span>&lt;ForwIter&gt;<span style="color: #000000">::value_type VT;
    ForwIter save(beg);
    </span><span style="color: #0000ff">try</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">for</span>(; num-- ; ++<span style="color: #000000">beg)
        {
            </span><span style="color: #0000ff">new</span> (static_cast&lt;<span style="color: #0000ff">void</span> *&gt;(&amp;*<span style="color: #000000">beg))VT(value);
        }
    }
    </span><span style="color: #0000ff">catch</span><span style="color: #000000">(...)
    {
        </span><span style="color: #0000ff">for</span>(; save != beg; ++<span style="color: #000000">save)
        {
            save</span>-&gt;~<span style="color: #000000">VT();
        }
        </span><span style="color: #0000ff">throw</span><span style="color: #000000">;
    }
}

template </span>&lt;typename InputIter, typename ForwIter&gt;
<span style="color: #0000ff">void</span><span style="color: #000000"> uninitialized_copy(InputIter beg, InputIter end, ForwIter dest)
{
    typedef typename std::iterator_traits</span>&lt;ForwIter&gt;<span style="color: #000000">::value_type VT;
    ForwIter save(dest);
    </span><span style="color: #0000ff">try</span><span style="color: #000000">
    {
        </span><span style="color: #0000ff">for</span>(; beg != end ; ++beg, ++<span style="color: #000000">dest)
        {
            </span><span style="color: #0000ff">new</span> (static_cast&lt;<span style="color: #0000ff">void</span> *&gt;(&amp;*dest))VT(*<span style="color: #000000">beg);
        }
    }
    </span><span style="color: #0000ff">catch</span><span style="color: #000000">(...)
    {
        </span><span style="color: #0000ff">for</span>(; save != dest; ++<span style="color: #000000">save)
        {
            save</span>-&gt;~<span style="color: #000000">VT();
        }
        </span><span style="color: #0000ff">throw</span><span style="color: #000000">;
    }
}

</span><span style="color: #0000ff">#endif</span> /* MEMORY_HPP */</pre>
</div>

<p>可以使用前面的代码自行测试。</p>]]></description></item><item><title>标准库Allocator的简易实现（二）</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/02/4004261.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 02 Oct 2014 09:18:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/02/4004261.html</guid><description><![CDATA[<p>自己实现Allocator并不难，其实只需要改变allocate和deallocate，来实现自己的内存分配策略。</p>  <p>&#160;</p>  <p>下面是一个std::allocator的模拟实现</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef ALLOCATOR_HPP
</span><span style="color: #0000ff">#define</span> ALLOCATOR_HPP<span style="color: #000000">

#include </span>&lt;stddef.h&gt;<span style="color: #000000">
#include </span>&lt;limits&gt;<span style="color: #000000">

template </span>&lt;typename T&gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> Allocator
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T</span>*<span style="color: #000000">  pointer;
    typedef </span><span style="color: #0000ff">const</span> T*<span style="color: #000000"> const_pointer;
    typedef T</span>&amp;<span style="color: #000000"> reference;
    typedef </span><span style="color: #0000ff">const</span> T&amp;<span style="color: #000000"> const_reference;
    typedef T value_type;

    </span><span style="color: #008000">//</span><span style="color: #008000">Allocator::rebind&lt;T2&gt;::other</span>
    template &lt;typename V&gt;
    <span style="color: #0000ff">struct</span><span style="color: #000000"> rebind
    {
        typedef Allocator</span>&lt;V&gt;<span style="color: #000000"> other;
    };

    pointer address(reference value) </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span> &amp;<span style="color: #000000">value; }
    const_pointer address(const_reference value) </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span> &amp;<span style="color: #000000">value; }

    Allocator() </span><span style="color: #0000ff">throw</span><span style="color: #000000">() {   }
    Allocator(</span><span style="color: #0000ff">const</span> Allocator &amp;) <span style="color: #0000ff">throw</span><span style="color: #000000">() {  }
    </span><span style="color: #008000">//</span><span style="color: #008000">不同类型的allcator可以相互复制</span>
    template &lt;typename V&gt; Allocator(<span style="color: #0000ff">const</span> Allocator&lt;V&gt; &amp;<span style="color: #000000">other) { } 
    </span>~Allocator() <span style="color: #0000ff">throw</span><span style="color: #000000">() {  }

    </span><span style="color: #008000">//</span><span style="color: #008000">最多可以分配的数目</span>
    size_type max_size() <span style="color: #0000ff">const</span> <span style="color: #0000ff">throw</span><span style="color: #000000">()
    { </span><span style="color: #0000ff">return</span> std::numeric_limits&lt;size_type&gt;::max() / <span style="color: #0000ff">sizeof</span><span style="color: #000000">(T); }

    </span><span style="color: #008000">//</span><span style="color: #008000">分配内存，返回该类型的指针</span>
<span style="color: #000000">    pointer allocate(size_type num)
    { </span><span style="color: #0000ff">return</span> (pointer)(::<span style="color: #0000ff">operator</span> <span style="color: #0000ff">new</span>(num * <span style="color: #0000ff">sizeof</span><span style="color: #000000">(T))); }

    </span><span style="color: #008000">//</span><span style="color: #008000">执行构造函数，构建一个对象</span>
    <span style="color: #0000ff">void</span> construct(pointer p, <span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">value)
    { </span><span style="color: #0000ff">new</span> ((<span style="color: #0000ff">void</span>*<span style="color: #000000">)p) T(value); }

    </span><span style="color: #008000">//</span><span style="color: #008000">销毁对象</span>
    <span style="color: #0000ff">void</span><span style="color: #000000"> destroy(pointer p)
    { p</span>-&gt;~<span style="color: #000000">T(); }

    </span><span style="color: #008000">//</span><span style="color: #008000">释放内存</span>
    <span style="color: #0000ff">void</span><span style="color: #000000"> deallocate(pointer p, size_type num)
    { ::</span><span style="color: #0000ff">operator</span> delete((<span style="color: #0000ff">void</span> *<span style="color: #000000">)p); }
};

</span><span style="color: #008000">//</span><span style="color: #008000">这两个运算符不需要friend声明</span>
template &lt;typename T, typename V&gt;
<span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> Allocator&lt;T&gt; &amp;, <span style="color: #0000ff">const</span> Allocator&lt;V&gt; &amp;) <span style="color: #0000ff">throw</span><span style="color: #000000">()
{ </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">true</span><span style="color: #000000">; }

template </span>&lt;typename T, typename V&gt;
<span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>!=(<span style="color: #0000ff">const</span> Allocator&lt;T&gt; &amp;, <span style="color: #0000ff">const</span> Allocator&lt;V&gt; &amp;) <span style="color: #0000ff">throw</span><span style="color: #000000">()
{ </span><span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span><span style="color: #000000">; }


</span><span style="color: #0000ff">#endif</span></pre>
</div>



<p>这里注意rebind的实现，如果需要使用Test的分配器分配其他类型，就可以这样：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>Allocator&lt;Test&gt;::rebind&lt;Test2&gt;::other alloc;</pre>
</div>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Allocator.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000">
#include </span>&lt;vector&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;


</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    vector</span>&lt;<span style="color: #0000ff">string</span>, Allocator&lt;<span style="color: #0000ff">string</span>&gt; &gt; vec(<span style="color: #800080">10</span>, <span style="color: #800000">&quot;</span><span style="color: #800000">haha</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    vec.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    vec.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    //Allocator</span>&lt;Test&gt;::rebind&lt;Test2&gt;<span style="color: #000000">::other alloc;

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>]]></description></item><item><title>标准库Allocator的使用（一）</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/02/4004253.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Thu, 02 Oct 2014 09:11:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/02/4004253.html</guid><description><![CDATA[<p>上一篇我们提到了new运算符以及它的工作步骤，其实无非是把两项工作独立出来：</p>
<blockquote>
<p>1.申请原始内存</p>
<p>2.执行构造函数</p>
</blockquote>
<p>delete也涉及了两个工作：</p>
<blockquote>
<p>1.执行析构函数</p>
<p>2.释放原始内存</p>
</blockquote>
<p>其实标准库提供了另外一种<strong>更加高级的手段</strong>实现内存的分配和构造，就是std::allocator&lt;T&gt;的职责。</p>
<p>&nbsp;</p>
<p>allocator提供了四个操作：</p>
<blockquote>
<p>a.allocate(num) 为num个元素分配内存</p>
<p>b.construct(p) 将p所指的元素初始化</p>
<p>destroy(p) 销毁p指向的元素</p>
<p>deallocate(p, num) 回收p指向的&ldquo;可容纳num个元素&rdquo;的内存空间</p>
</blockquote>
<p>使用示例如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>#include &lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;<span style="color: #000000;">
#include </span>&lt;memory&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Test
{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
        Test() { cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Test</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl; }
        </span>~Test() { cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Test ...</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl; }

        Test(</span><span style="color: #0000ff;">const</span> Test &amp;<span style="color: #000000;">t)
        {
            cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Copy .....</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl; 
        }

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Test(const Test &amp;);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">void operator(const Test &amp;);</span>
<span style="color: #000000;">};


</span><span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">argv[])
{
    allocator</span>&lt;Test&gt;<span style="color: #000000;"> alloc;
    Test </span>*pt = alloc.allocate(<span style="color: #800080;">3</span>); <span style="color: #008000;">//</span><span style="color: #008000;">申请三个单位的Test内存
    </span><span style="color: #008000;">//</span><span style="color: #008000;">此时pt指向的是原始内存</span>
<span style="color: #000000;">    {
        alloc.construct(pt, Test()); </span><span style="color: #008000;">//</span><span style="color: #008000;">构建一个对象，使用默认值
        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用的是拷贝构造函数</span>
        alloc.construct(pt+<span style="color: #800080;">1</span><span style="color: #000000;">, Test());
        alloc.construct(pt</span>+<span style="color: #800080;">2</span><span style="color: #000000;">, Test());
    }
    alloc.destroy(pt);
    alloc.destroy(pt</span>+<span style="color: #800080;">1</span><span style="color: #000000;">);
    alloc.destroy(pt</span>+<span style="color: #800080;">2</span><span style="color: #000000;">);

    alloc.deallocate(pt, </span><span style="color: #800080;">3</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>这里注意，allocator提供的allocate函数与operator new函数区别在于返回值，所以前者更加安全。</p>
<p>还有一点，construct一次只能构造一个对象，而且调用的是<strong>拷贝构造函数</strong>。</p>
<p>标准库提供了三个算法用于批量构造对象(前提是已经分配内存)</p>
<blockquote>
<pre>uninitialized_fill(beg, end, val)   //以val初始化[beg,end)</pre>
<pre>uninitialized_fill_n(beg, num, val) //以val初始化beg开始的num个元素</pre>
<pre>uninitialized_copy(beg, end, mem) //以[beg, end)的各个元素初始化mem开始的各个元素</pre>
</blockquote>
<p><span style="color: #333333;">以上三个函数操控的对象都是原始内存</span><span style="color: #333333;">示例如下：</span></p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>#include &lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;<span style="color: #000000;">
#include </span>&lt;memory&gt;<span style="color: #000000;">
#include </span>&lt;stdlib.h&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Test
{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
        Test(</span><span style="color: #0000ff;">int</span> val) :val_(val) { cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Test</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl; }

        </span>~Test() { cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Test ...</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl; }

        Test(</span><span style="color: #0000ff;">const</span> Test &amp;<span style="color: #000000;">t)
            :val_(t.val_)
        {
            cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Copy .....</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl; 
        }

        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> val_;
};


</span><span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">argv[])
{

    Test </span>*pt = (Test *)malloc(<span style="color: #800080;">3</span> * <span style="color: #0000ff;">sizeof</span><span style="color: #000000;"> (Test));

    Test t(</span><span style="color: #800080;">12</span><span style="color: #000000;">);

    uninitialized_fill(pt, pt </span>+ <span style="color: #800080;">3</span><span style="color: #000000;">, t);
    cout </span>&lt;&lt; pt[<span style="color: #800080;">0</span>].val_ &lt;&lt;<span style="color: #000000;"> endl;
    

    Test </span>*pt2 = (Test *)malloc(<span style="color: #800080;">2</span> * <span style="color: #0000ff;">sizeof</span><span style="color: #000000;"> (Test));
    uninitialized_copy(pt, pt </span>+ <span style="color: #800080;">2</span><span style="color: #000000;">, pt2);

    free(pt);
    free(pt2);</span></pre>
<pre><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>这里注意标准库的copy、fill函数与uninitialized_系列函数的区别：</p>
<blockquote>
<p>copy、fill等操作的是已经初始化对象的内存，因此调用的是<strong>赋值运算符</strong></p>
<p>而uninitialized_针对的是原始内存，调用的是<strong>拷贝构造函数</strong></p>
</blockquote>
<p>OK，我们到此，可以总结出<strong>分配原始内存</strong>的三种手段：</p>
<blockquote>
<p>1.使用malloc</p>
<p>2.使用operator new</p>
<p>3.allocator的allocate函数</p>
</blockquote>
<p>这三者从上到下，是一个由低级到高级的过程。</p>
<p>那么执行构造函数，有两种手段：</p>
<blockquote>
<p>1.使用placement new运算符</p>
<p>2.使用allocator的construct函数</p>
</blockquote>
<p>&nbsp;</p>
<p>最后，C语言中的数据都是POD类型，使用原始内存即可，但是C++中的大部分都是<strong>非POD类型</strong>，需要执行相应的初始化函数，所以，<strong>在C++中应该尽可能避免使用memcpy之类的直接操控原始内存的函数</strong>。</p>]]></description></item><item><title>简单的内存分配器</title><link>http://www.cnblogs.com/inevermore/archive/2014/10/01/4003710.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Wed, 01 Oct 2014 15:43:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/10/01/4003710.html</guid><description><![CDATA[<p>采用自定义的operator运算符实现自己的内存分配策略，在某些时候可以提高程序的效率。</p>  <p>&#160;</p>  <p>C++中的new运算符，具体工作流程如下：</p>  <blockquote>   <p>1.调用operator new申请原始内存</p>    <p>2.调用place new表达式，执行类的构造函数</p>    <p>3.返回内存地址</p> </blockquote>  <p>而delete操作符的工作是：</p>  <blockquote>   <p>1.调用对象的析构函数</p>    <p>2.调用operator delete释放内存</p> </blockquote>  <p>例如：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;iostream&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">class</span><span style="color: #000000"> Test
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    Test() { cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">Test</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl; }
    </span>~Test() { cout &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">~Test</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl; }
};

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{

    </span><span style="color: #008000">//</span><span style="color: #008000">这里的pt指向的是原始内存</span>
    Test *pt = static_cast&lt;Test*&gt;(<span style="color: #0000ff">operator</span> <span style="color: #0000ff">new</span>[] (<span style="color: #800080">5</span> * <span style="color: #0000ff">sizeof</span><span style="color: #000000">(Test)));
    
    </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != <span style="color: #800080">5</span>; ++<span style="color: #000000">ix)
    {
        </span><span style="color: #0000ff">new</span> (pt+ix)Test(); <span style="color: #008000">//</span><span style="color: #008000">调用定位new运算式 执行构造函数</span>
<span style="color: #000000">    }

    </span><span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> ix = <span style="color: #800080">0</span>; ix != <span style="color: #800080">5</span>; ++<span style="color: #000000">ix)
    {
        pt[ix].</span>~Test(); <span style="color: #008000">//</span><span style="color: #008000">调用析构函数，但是并未释放内存</span>
<span style="color: #000000">    }
    </span><span style="color: #0000ff">operator</span> delete[] (pt); <span style="color: #008000">//</span><span style="color: #008000">释放内存</span>
<span style="color: #000000">
}</span></pre>
</div>



<p>&#160;</p>

<p>这里提供一个简单的内存分配器基类，凡是继承该类的class均具有自定义的operator new 和 operator delete</p>

<p>此示例来自《C++Primer》第四版</p>

<p>大概思想是用static变量维持一个链表，管理空闲的内存块。</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #000000">#ifndef CACHED_OBJECT_HPP
</span><span style="color: #0000ff">#define</span> CACHED_OBJECT_HPP<span style="color: #000000">

#include </span>&lt;memory&gt;<span style="color: #000000">
#include </span>&lt;stdexcept&gt;<span style="color: #000000">
#include </span>&lt;iostream&gt; <span style="color: #008000">//</span><span style="color: #008000">debug</span>
<span style="color: #000000">
template </span>&lt;typename T&gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> CachedObject
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    </span><span style="color: #0000ff">void</span> *<span style="color: #0000ff">operator</span> <span style="color: #0000ff">new</span><span style="color: #000000">(std::size_t);
    </span><span style="color: #0000ff">void</span> <span style="color: #0000ff">operator</span> delete(<span style="color: #0000ff">void</span> *<span style="color: #000000">, std::size_t);
    </span><span style="color: #0000ff">virtual</span> ~<span style="color: #000000">CachedObject() { }
</span><span style="color: #0000ff">protected</span><span style="color: #000000">:
    T </span>*<span style="color: #000000">next_;
</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    </span><span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> addToFreeList(T*);  <span style="color: #008000">//</span><span style="color: #008000">将内存块加入链表</span>
    <span style="color: #0000ff">static</span> std::allocator&lt;T&gt; alloc_;<span style="color: #008000">//</span><span style="color: #008000">内存分配器</span>
    <span style="color: #0000ff">static</span> T *freeStore_;           <span style="color: #008000">//</span><span style="color: #008000">空闲内存的链表</span>
    <span style="color: #0000ff">static</span> <span style="color: #0000ff">const</span> std::size_t chunk_;<span style="color: #008000">//</span><span style="color: #008000">一次分配的块数</span>
<span style="color: #000000">};

template </span>&lt;typename T&gt; std::allocator&lt;T&gt; CachedObject&lt;T&gt;<span style="color: #000000">::alloc_;
template </span>&lt;typename T&gt; T *CachedObject&lt;T&gt;::freeStore_ =<span style="color: #000000"> NULL;
template </span>&lt;typename T&gt; <span style="color: #0000ff">const</span> std::size_t CachedObject&lt;T&gt;::chunk_ = <span style="color: #800080">24</span><span style="color: #000000">;

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> *CachedObject&lt;T&gt;::<span style="color: #0000ff">operator</span> <span style="color: #0000ff">new</span><span style="color: #000000">(std::size_t sz)
{
    </span><span style="color: #0000ff">if</span>(sz != <span style="color: #0000ff">sizeof</span><span style="color: #000000">(T))
        </span><span style="color: #0000ff">throw</span> std::runtime_error(<span style="color: #800000">&quot;</span><span style="color: #800000">CachedObject: wrong size object in operator new</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    
    std::cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">operator new </span><span style="color: #800000">&quot;</span> &lt;&lt; std::endl; <span style="color: #008000">//</span><span style="color: #008000">DEBUG

    </span><span style="color: #008000">//</span><span style="color: #008000">没有空闲内存</span>
    <span style="color: #0000ff">if</span>(freeStore_ ==<span style="color: #000000"> NULL)
    {
        T </span>*array =<span style="color: #000000"> alloc_.allocate(chunk_);
        </span><span style="color: #0000ff">for</span>(std::size_t ix = <span style="color: #800080">0</span>; ix != chunk_; ++<span style="color: #000000">ix)
        {
            addToFreeList(</span>&amp;<span style="color: #000000">array[ix]);
        }
    }

    </span><span style="color: #008000">//</span><span style="color: #008000">取出一块内存，从链表取出第一个元素</span>
    T *p =<span style="color: #000000"> freeStore_;
    freeStore_ </span>= freeStore_-&gt;CachedObject&lt;T&gt;<span style="color: #000000">::next_;
    </span><span style="color: #0000ff">return</span><span style="color: #000000"> p;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> CachedObject&lt;T&gt;::<span style="color: #0000ff">operator</span> delete(<span style="color: #0000ff">void</span> *<span style="color: #000000">p, std::size_t)
{
    std::cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">operator delete </span><span style="color: #800000">&quot;</span> &lt;&lt; std::endl; <span style="color: #008000">//</span><span style="color: #008000">DEBUG</span>

    <span style="color: #0000ff">if</span>(p !=<span style="color: #000000"> NULL)
        addToFreeList(static_cast</span>&lt;T*&gt;<span style="color: #000000">(p));
}


template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> CachedObject&lt;T&gt;::addToFreeList(T *<span style="color: #000000">p)
{
    </span><span style="color: #008000">//</span><span style="color: #008000">使用头插法</span>
    p-&gt;CachedObject&lt;T&gt;::next_ =<span style="color: #000000"> freeStore_;
    freeStore_ </span>=<span style="color: #000000"> p;
}

</span><span style="color: #0000ff">#endif</span> /* CACHED_OBJECT_HPP */</pre>
</div>

<p>每次执行new时，调用我们自定义的operator new去空闲链表中取出一块内存，如果链表为空，则执行真正的申请内存操作。</p>

<p>每次delete时，把内存归还给链表。</p>

<p>这样减少了每次new都去申请内存的开销。</p>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">CachedObject.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;iostream&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #008000">//</span><span style="color: #008000">使用继承的策略去使用这个内存分配器</span>
<span style="color: #0000ff">class</span> Test : <span style="color: #0000ff">public</span> CachedObject&lt;Test&gt;<span style="color: #000000">
{

};

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    
    </span><span style="color: #008000">//</span><span style="color: #008000">调用自定义的new分配内存</span>
    Test *pt = <span style="color: #0000ff">new</span><span style="color: #000000"> Test;
    delete pt;

    </span><span style="color: #008000">//</span><span style="color: #008000">调用默认的new和delete</span>
    pt = ::<span style="color: #0000ff">new</span><span style="color: #000000"> Test;
    ::delete pt;

    </span><span style="color: #008000">//</span><span style="color: #008000">不会调用自定义的new和delete</span>
    pt = <span style="color: #0000ff">new</span> Test[<span style="color: #800080">10</span><span style="color: #000000">];
    delete[] pt; 

}</span></pre>
</div>]]></description></item><item><title>扩充STL-编写自己的迭代器</title><link>http://www.cnblogs.com/inevermore/archive/2014/09/29/4001001.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Mon, 29 Sep 2014 13:17:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/09/29/4001001.html</guid><description><![CDATA[<p>这里的迭代器能够与STL组件共同工作，是对STL的一种扩充。</p>  <p>&#160;</p>  <p>自定义迭代器必须提供iterator_traits的五种特性，分别是迭代器类型、元素类型、距离类型、指针类型与reference类型。</p>  <p>&#160;</p>  <p>这里我们继承标准库提供的iterator&lt;&gt;即可。</p>  <p>&#160;</p>  <p>代码如下： MyIterator.hpp 该迭代器针对于关联容器</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef MYITERATOR_H_
</span><span style="color: #0000ff">#define</span> MYITERATOR_H_<span style="color: #000000">

#include </span>&lt;iterator&gt;

<span style="color: #008000">//</span><span style="color: #008000">必须提供五种类型，作为迭代器traits</span>
template &lt;typename Container&gt;
<span style="color: #0000ff">class</span> MyInsertIterator : <span style="color: #0000ff">public</span> std::iterator&lt;<span style="color: #000000">std::output_iterator_tag, 
                                            </span><span style="color: #0000ff">void</span>, <span style="color: #0000ff">void</span>, <span style="color: #0000ff">void</span>, <span style="color: #0000ff">void</span>&gt;<span style="color: #000000">
{
    </span><span style="color: #0000ff">public</span><span style="color: #000000">:
        </span><span style="color: #0000ff">explicit</span> MyInsertIterator(Container &amp;<span style="color: #000000">c)
            :container_(c)
        {   }

        </span><span style="color: #008000">//</span><span style="color: #008000">将赋值转化为insert操作</span>
        MyInsertIterator&lt;Container&gt; &amp;<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> typename Container::value_type &amp;<span style="color: #000000">value)
        {
            container_.insert(value); </span><span style="color: #008000">//</span><span style="color: #008000">针对的是关联容器 </span>
            <span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">没有实际动作，起到掩饰的作用</span>
        MyInsertIterator&lt;Container&gt; <span style="color: #0000ff">operator</span>*<span style="color: #000000">()
        {
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }

        MyInsertIterator </span>&amp;<span style="color: #0000ff">operator</span>++<span style="color: #000000">()
        {
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }

        MyInsertIterator </span>&amp;<span style="color: #0000ff">operator</span>++(<span style="color: #0000ff">int</span><span style="color: #000000">)
        {
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }

    </span><span style="color: #0000ff">protected</span><span style="color: #000000">:
        Container </span>&amp;<span style="color: #000000">container_;
};


template </span>&lt;typename Container&gt;<span style="color: #000000">
MyInsertIterator</span>&lt;Container&gt; MyInsert(Container &amp;<span style="color: #000000">c)
{
    </span><span style="color: #0000ff">return</span> MyInsertIterator&lt;Container&gt;<span style="color: #000000">(c);
}


</span><span style="color: #0000ff">#endif</span> /* MYITERATOR_H_ */</pre>
</div>

<p>&#160;</p>

<p>这里面重载的*和++没有实际操作，为的是起到掩饰的作用，从而仅仅返回自身引用。</p>

<p>&#160;</p>

<p>注意=操作符执行了insert操作，所以当我们写下：</p>

<p>&#160;</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>*iter = <span style="color: #800080">3</span>;</pre>
</div>



<p>&#160;</p>

<p>时，自动将3插入至容器中。</p>

<p>&#160;</p>

<p>我们还提供了一个MyInsert函数，用于快速生成迭代器对象，于是我们可以这样使用：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>MyInsert(coll) = <span style="color: #800080">55</span>;</pre>
</div>



<p>&#160;</p>

<p>我们只需改动代码中的
  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
    <pre>container_.insert(value); <span style="color: #008000">//</span><span style="color: #008000">针对的是关联容器</span></pre>
  </div>
</p>

<p>如果改为push_back就变成了back_inserter，如果调用push_front则成为front_inserter</p>

<p>&#160;</p>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">MyIterator.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">set</span>&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000">
#include </span>&lt;iostream&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

template </span>&lt;typename CONT&gt;
<span style="color: #0000ff">void</span> print(<span style="color: #0000ff">const</span> CONT &amp;<span style="color: #000000">s)
{
    </span><span style="color: #0000ff">for</span>(typename CONT::const_iterator it =<span style="color: #000000"> s.begin();
        it </span>!=<span style="color: #000000"> s.end();
        </span>++<span style="color: #000000">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000">&quot;</span> <span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
    cout </span>&lt;&lt;<span style="color: #000000"> endl;
}

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    </span><span style="color: #0000ff">set</span>&lt;<span style="color: #0000ff">int</span>&gt;<span style="color: #000000"> coll;

    MyInsertIterator</span>&lt;<span style="color: #0000ff">set</span>&lt;<span style="color: #0000ff">int</span>&gt; &gt;<span style="color: #000000"> iter(coll);

    </span>*iter = <span style="color: #800080">1</span><span style="color: #000000">;
    iter</span>++<span style="color: #000000">;
    </span>*iter = <span style="color: #800080">2</span><span style="color: #000000">;
    iter</span>++<span style="color: #000000">;
    </span>*iter = <span style="color: #800080">3</span><span style="color: #000000">;

    print(coll);

    MyInsert(coll) </span>= <span style="color: #800080">44</span><span style="color: #000000">;
    MyInsert(coll) </span>= <span style="color: #800080">55</span><span style="color: #000000">;


    print(coll);

    </span><span style="color: #0000ff">int</span> vals[] = {<span style="color: #800080">33</span>, <span style="color: #800080">67</span>, -<span style="color: #800080">4</span>, <span style="color: #800080">13</span>, <span style="color: #800080">5</span>, <span style="color: #800080">2</span><span style="color: #000000">};
    </span><span style="color: #0000ff">int</span> size = <span style="color: #0000ff">sizeof</span>(vals) / <span style="color: #0000ff">sizeof</span>(vals[<span style="color: #800080">0</span><span style="color: #000000">]);
    copy(vals, vals </span>+<span style="color: #000000"> size, MyInsert(coll));

    print(coll);

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>&#160;</p>

<p>结果为：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> 
<span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> <span style="color: #800080">44</span> <span style="color: #800080">55</span> 
-<span style="color: #800080">4</span> <span style="color: #800080">1</span> <span style="color: #800080">2</span> <span style="color: #800080">3</span> <span style="color: #800080">5</span> <span style="color: #800080">13</span> <span style="color: #800080">33</span> <span style="color: #800080">44</span> <span style="color: #800080">55</span> <span style="color: #800080">67</span></pre>
</div>]]></description></item><item><title>Vector的一种实现（二）</title><link>http://www.cnblogs.com/inevermore/archive/2014/09/29/3999346.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Sep 2014 18:20:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/09/29/3999346.html</guid><description><![CDATA[<p>&#160;</p>  <p>增加了逆置迭代器的实现</p>  <p>以及swap功能</p>  <p>&#160;</p>  <p>完整代码如下：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #000000">#ifndef VECTOR_H_
</span><span style="color: #0000ff">#define</span> VECTOR_H_<span style="color: #000000">

#include </span>&lt;stddef.h&gt;<span style="color: #000000">
#include </span>&lt;algorithm&gt;<span style="color: #000000">
#include </span>&lt;memory&gt;<span style="color: #000000">

template </span>&lt;typename T&gt;
<span style="color: #0000ff">class</span><span style="color: #000000"> Vector
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    typedef T </span>*<span style="color: #000000">iterator;
    typedef </span><span style="color: #0000ff">const</span> T *<span style="color: #000000">const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    </span><span style="color: #008000">//</span><span style="color: #008000">逆置迭代器</span>
    <span style="color: #0000ff">class</span><span style="color: #000000"> reverse_iterator
    {
    </span><span style="color: #0000ff">public</span><span style="color: #000000">:
        reverse_iterator(iterator it </span>=<span style="color: #000000"> NULL) :current_(it) { }
        iterator </span><span style="color: #0000ff">base</span>() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> current_; }

        reverse_iterator </span>&amp;<span style="color: #0000ff">operator</span>++<span style="color: #000000">()
        {
            </span>--<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }
        reverse_iterator </span><span style="color: #0000ff">operator</span>++(<span style="color: #0000ff">int</span><span style="color: #000000">)
        {
            reverse_iterator temp(</span>*<span style="color: #0000ff">this</span><span style="color: #000000">);
            </span>--<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> temp;
        }
        reverse_iterator </span>&amp;<span style="color: #0000ff">operator</span>--<span style="color: #000000">()
        {
            </span>++<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }
        reverse_iterator </span><span style="color: #0000ff">operator</span>--(<span style="color: #0000ff">int</span><span style="color: #000000">)
        {
            reverse_iterator temp(</span>*<span style="color: #0000ff">this</span><span style="color: #000000">);
            </span>++<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> temp;
        }

        T </span>&amp;<span style="color: #0000ff">operator</span>*<span style="color: #000000">()
        {
            iterator temp </span>=<span style="color: #000000"> current_;
            </span><span style="color: #0000ff">return</span> *--<span style="color: #000000">temp;
        }

        T </span>*<span style="color: #0000ff">operator</span>-&gt;<span style="color: #000000">()
        {
            iterator temp </span>=<span style="color: #000000"> current_;
            </span><span style="color: #0000ff">return</span> --<span style="color: #000000">temp;
        }

        friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> reverse_iterator &amp;lhs, <span style="color: #0000ff">const</span> reverse_iterator &amp;<span style="color: #000000">rhs)
        {
            </span><span style="color: #0000ff">return</span> lhs.current_ ==<span style="color: #000000"> rhs.current_;
        }

        friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>!=(<span style="color: #0000ff">const</span> reverse_iterator &amp;lhs, <span style="color: #0000ff">const</span> reverse_iterator &amp;<span style="color: #000000">rhs)
        {
            </span><span style="color: #0000ff">return</span> lhs.current_ !=<span style="color: #000000"> rhs.current_;
        }

    </span><span style="color: #0000ff">private</span><span style="color: #000000">:
        iterator current_;
    };

    </span><span style="color: #008000">//</span><span style="color: #008000">const逆置迭代器</span>
    <span style="color: #0000ff">class</span><span style="color: #000000"> const_reverse_iterator
    {
    </span><span style="color: #0000ff">public</span><span style="color: #000000">:
        const_reverse_iterator(const_iterator it </span>=<span style="color: #000000"> NULL) :current_(it) { }
        const_iterator </span><span style="color: #0000ff">base</span>() <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> current_; }

        const_reverse_iterator </span>&amp;<span style="color: #0000ff">operator</span>++<span style="color: #000000">()
        {
            </span>--<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }
        const_reverse_iterator </span><span style="color: #0000ff">operator</span>++(<span style="color: #0000ff">int</span><span style="color: #000000">)
        {
            const_iterator temp(</span>*<span style="color: #0000ff">this</span><span style="color: #000000">);
            </span>--<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> temp;
        }
        const_reverse_iterator </span>&amp;<span style="color: #0000ff">operator</span>--<span style="color: #000000">()
        {
            </span>++<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
        }
        const_reverse_iterator </span><span style="color: #0000ff">operator</span>--(<span style="color: #0000ff">int</span><span style="color: #000000">)
        {
            const_iterator temp(</span>*<span style="color: #0000ff">this</span><span style="color: #000000">);
            </span>++<span style="color: #000000">current_;
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> temp;
        }

        </span><span style="color: #0000ff">const</span> T &amp;<span style="color: #0000ff">operator</span>*() <span style="color: #0000ff">const</span><span style="color: #000000">
        {
            const_iterator temp </span>=<span style="color: #000000"> current_;
            </span><span style="color: #0000ff">return</span> *(--<span style="color: #000000">temp);
        }

        </span><span style="color: #0000ff">const</span> T *<span style="color: #0000ff">operator</span>-&gt;() <span style="color: #0000ff">const</span><span style="color: #000000">
        {
            const_iterator temp </span>=<span style="color: #000000"> current_;
            </span><span style="color: #0000ff">return</span> --<span style="color: #000000">temp;
        }

        friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>==(<span style="color: #0000ff">const</span> const_reverse_iterator &amp;lhs, <span style="color: #0000ff">const</span> const_reverse_iterator &amp;<span style="color: #000000">rhs)
        {
            </span><span style="color: #0000ff">return</span> lhs.current_ ==<span style="color: #000000"> rhs.current_;
        }

        friend </span><span style="color: #0000ff">bool</span> <span style="color: #0000ff">operator</span>!=(<span style="color: #0000ff">const</span> const_reverse_iterator &amp;lhs, <span style="color: #0000ff">const</span> const_reverse_iterator &amp;<span style="color: #000000">rhs)
        {
            </span><span style="color: #0000ff">return</span> lhs.current_ !=<span style="color: #000000"> rhs.current_;
        }

    </span><span style="color: #0000ff">private</span><span style="color: #000000">:
        const_iterator current_;
    };

    Vector() { create(); }
    </span><span style="color: #0000ff">explicit</span> Vector(size_type n, <span style="color: #0000ff">const</span> T &amp;t =<span style="color: #000000"> T())  { create(n, t); }
    Vector(</span><span style="color: #0000ff">const</span> Vector &amp;<span style="color: #000000">v) { create(v.begin(),  v.end()); }
    </span>~<span style="color: #000000">Vector() { uncreate(); }

    Vector </span>&amp;<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> Vector &amp;<span style="color: #000000">other);
    T </span>&amp;<span style="color: #0000ff">operator</span>[] (size_type i) { <span style="color: #0000ff">return</span><span style="color: #000000"> data_[i]; }
    </span><span style="color: #0000ff">const</span> T &amp;<span style="color: #0000ff">operator</span>[] (size_type i) <span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> data_[i]; }

    </span><span style="color: #0000ff">void</span> push_back(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">t);
    </span><span style="color: #0000ff">void</span> swap(Vector &amp;<span style="color: #000000">rhs)
    {
        std::swap(data_, rhs.data_);
        std::swap(avail_, rhs.avail_);
        std::swap(limit_, rhs.limit_);
    }

    size_type size() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span> avail_ -<span style="color: #000000"> data_; }
    size_type capacity() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span> limit_ -<span style="color: #000000"> data_; }

    iterator begin() { </span><span style="color: #0000ff">return</span><span style="color: #000000"> data_; }
    const_iterator begin() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> data_; }
    iterator end() { </span><span style="color: #0000ff">return</span><span style="color: #000000"> avail_; }
    const_iterator end() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> avail_; }


    reverse_iterator rbegin() { </span><span style="color: #0000ff">return</span><span style="color: #000000"> reverse_iterator(end()); }
    const_reverse_iterator rbegin() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> const_reverse_iterator(end()); }
    reverse_iterator rend() { </span><span style="color: #0000ff">return</span><span style="color: #000000"> reverse_iterator(begin()); }
    const_reverse_iterator rend() </span><span style="color: #0000ff">const</span> { <span style="color: #0000ff">return</span><span style="color: #000000"> const_reverse_iterator(begin()); }
    

</span><span style="color: #0000ff">private</span><span style="color: #000000">:
    iterator data_; </span><span style="color: #008000">//</span><span style="color: #008000">首元素</span>
    iterator avail_; <span style="color: #008000">//</span><span style="color: #008000">末尾元素的下一个位置</span>
    iterator limit_; <span style="color: #008000">//</span><span style="color: #008000">内存的后面一个位置</span>
<span style="color: #000000">
    std::allocator</span>&lt;T&gt; alloc_; <span style="color: #008000">//</span><span style="color: #008000">内存分配器</span>

    <span style="color: #0000ff">void</span><span style="color: #000000"> create();
    </span><span style="color: #0000ff">void</span> create(size_type, <span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">);
    </span><span style="color: #0000ff">void</span><span style="color: #000000"> create(const_iterator, const_iterator);

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> uncreate();

    </span><span style="color: #0000ff">void</span><span style="color: #000000"> grow();
    </span><span style="color: #0000ff">void</span> uncheckedAppend(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">);
};

template </span>&lt;typename T&gt;<span style="color: #000000">
Vector</span>&lt;T&gt; &amp;Vector&lt;T&gt;::<span style="color: #0000ff">operator</span>=(<span style="color: #0000ff">const</span> Vector &amp;<span style="color: #000000">rhs)
{
    </span><span style="color: #0000ff">if</span>(<span style="color: #0000ff">this</span> != &amp;<span style="color: #000000">rhs)
    {
        uncreate(); </span><span style="color: #008000">//</span><span style="color: #008000">释放原来的内存</span>
<span style="color: #000000">        create(rhs.begin(), rhs.end());
    }

    </span><span style="color: #0000ff">return</span> *<span style="color: #0000ff">this</span><span style="color: #000000">;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;::push_back(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">t)
{
    </span><span style="color: #0000ff">if</span>(avail_ ==<span style="color: #000000"> limit_)
    {
        grow();
    }
    uncheckedAppend(t);
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;<span style="color: #000000">::create()
{
    </span><span style="color: #008000">//</span><span style="color: #008000">分配空的数组</span>
    data_ = avail_ = limit_ = <span style="color: #800080">0</span><span style="color: #000000">;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;::create(size_type n, <span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">val)
{
    </span><span style="color: #008000">//</span><span style="color: #008000">分配原始内存</span>
    data_ =<span style="color: #000000"> alloc_.allocate(n);
    limit_ </span>= avail_ = data_ +<span style="color: #000000"> n;
    </span><span style="color: #008000">//</span><span style="color: #008000">向原始内存填充元素</span>
<span style="color: #000000">    std::uninitialized_fill(data_, limit_, val);
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;<span style="color: #000000">::create(const_iterator i, const_iterator j)
{
    data_ </span>= alloc_.allocate(j-<span style="color: #000000">i);
    limit_ </span>= avail_ =<span style="color: #000000"> std::uninitialized_copy(i, j, data_);
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;<span style="color: #000000">::uncreate()
{
    </span><span style="color: #0000ff">if</span><span style="color: #000000">(data_)
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">逐个进行析构</span>
        iterator it =<span style="color: #000000"> avail_;
        </span><span style="color: #0000ff">while</span>(it !=<span style="color: #000000"> data_)
        {
            alloc_.destroy(</span>--<span style="color: #000000">it);
        }

        </span><span style="color: #008000">//</span><span style="color: #008000">真正的释放内存</span>
        alloc_.deallocate(data_, limit_ -<span style="color: #000000"> data_);
    }
    </span><span style="color: #008000">//</span><span style="color: #008000">重置指针</span>
    data_ = limit_ = avail_ = <span style="color: #800080">0</span><span style="color: #000000">;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;<span style="color: #000000">::grow()
{
    </span><span style="color: #008000">//</span><span style="color: #008000">内存变为两倍</span>
    size_type new_size = std::max(<span style="color: #800080">2</span> * (limit_ - data_), std::ptrdiff_t(<span style="color: #800080">1</span><span style="color: #000000">));
    </span><span style="color: #008000">//</span><span style="color: #008000">分配原始内存</span>
    iterator new_data =<span style="color: #000000"> alloc_.allocate(new_size);
    </span><span style="color: #008000">//</span><span style="color: #008000">复制元素</span>
    iterator new_avail =<span style="color: #000000"> std::uninitialized_copy(data_, avail_, new_data);

    uncreate(); </span><span style="color: #008000">//</span><span style="color: #008000">释放以前的内存，以及析构元素</span>
<span style="color: #000000">
    data_ </span>=<span style="color: #000000"> new_data;
    avail_ </span>=<span style="color: #000000"> new_avail;
    limit_ </span>= data_ +<span style="color: #000000"> new_size;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff">void</span> Vector&lt;T&gt;::uncheckedAppend(<span style="color: #0000ff">const</span> T &amp;<span style="color: #000000">val)
{
    alloc_.construct(avail_</span>++<span style="color: #000000">, val);
}


</span><span style="color: #0000ff">#endif</span>  /* VECTOR_H_ */</pre>
</div>

<p>&#160;</p>

<p>测试代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>#include <span style="color: #800000">&quot;</span><span style="color: #800000">Vector.hpp</span><span style="color: #800000">&quot;</span><span style="color: #000000">
#include </span>&lt;iostream&gt;<span style="color: #000000">
#include </span>&lt;<span style="color: #0000ff">string</span>&gt;
<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #008000">//</span><span style="color: #008000">测试const reverse迭代器</span>
<span style="color: #0000ff">void</span> print(<span style="color: #0000ff">const</span> Vector&lt;<span style="color: #0000ff">string</span>&gt; &amp;<span style="color: #000000">vec)
{
    </span><span style="color: #0000ff">for</span>(Vector&lt;<span style="color: #0000ff">string</span>&gt;::const_reverse_iterator it =<span style="color: #000000"> vec.rbegin();
        it </span>!=<span style="color: #000000"> vec.rend();
        </span>++<span style="color: #000000">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000">&quot;</span> <span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
    cout </span>&lt;&lt;<span style="color: #000000"> endl;
}

</span><span style="color: #0000ff">int</span> main(<span style="color: #0000ff">int</span> argc, <span style="color: #0000ff">char</span> <span style="color: #0000ff">const</span> *<span style="color: #000000">argv[])
{
    Vector</span>&lt;<span style="color: #0000ff">string</span>&gt; vec(<span style="color: #800080">3</span>, <span style="color: #800000">&quot;</span><span style="color: #800000">hello</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    </span><span style="color: #0000ff">for</span>(Vector&lt;<span style="color: #0000ff">string</span>&gt;::const_iterator it =<span style="color: #000000"> vec.begin();
        it </span>!=<span style="color: #000000"> vec.end();
        </span>++<span style="color: #000000">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000">&quot;</span> <span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
    cout </span>&lt;&lt;<span style="color: #000000"> endl;

    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">size = </span><span style="color: #800000">&quot;</span> &lt;&lt; vec.size() &lt;&lt;<span style="color: #000000"> endl;
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">capacity = </span><span style="color: #800000">&quot;</span> &lt;&lt; vec.capacity() &lt;&lt;<span style="color: #000000"> endl;
    vec.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">foo</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    vec.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">bar</span><span style="color: #800000">&quot;</span><span style="color: #000000">);

    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">size = </span><span style="color: #800000">&quot;</span> &lt;&lt; vec.size() &lt;&lt;<span style="color: #000000"> endl;
    cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">capacity = </span><span style="color: #800000">&quot;</span> &lt;&lt; vec.capacity() &lt;&lt;<span style="color: #000000"> endl;

    </span><span style="color: #0000ff">for</span>(Vector&lt;<span style="color: #0000ff">string</span>&gt;::reverse_iterator it =<span style="color: #000000"> vec.rbegin();
        it </span>!=<span style="color: #000000"> vec.rend();
        </span>++<span style="color: #000000">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000">&quot;</span> <span style="color: #800000">&quot;</span><span style="color: #000000">;
    }
    cout </span>&lt;&lt;<span style="color: #000000"> endl;


    print(vec);

    Vector</span>&lt;<span style="color: #0000ff">string</span>&gt;<span style="color: #000000"> vec2;
    vec2.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">beijing</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    vec2.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">shanghai</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    vec2.push_back(</span><span style="color: #800000">&quot;</span><span style="color: #800000">guangzhou</span><span style="color: #800000">&quot;</span><span style="color: #000000">);
    print(vec2);

    vec.swap(vec2);
    print(vec);
    print(vec2);

    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>]]></description></item><item><title>JDBC的封装</title><link>http://www.cnblogs.com/inevermore/archive/2014/09/29/3999296.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Sep 2014 16:42:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/09/29/3999296.html</guid><description><![CDATA[<p>&#160;</p>  <p>连接数据库的步骤：</p>  <p>1.加载JDBC驱动</p>  <p>2.提供连接参数</p>  <p>3.建立数据库连接</p>  <p>4.创建一个statement</p>  <p>5.执行SQL语句</p>  <p>6.处理结果</p>  <p>7.关闭JDBC对象</p>  <p>&#160;</p>  <p>&#160;</p>  <p>新建一个JDBCUtil类</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #0000ff">package</span><span style="color: #000000"> com.jdbc.utils;

</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.sql.Connection;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.sql.DriverManager;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.sql.PreparedStatement;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.sql.ResultSet;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.sql.ResultSetMetaData;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.sql.SQLException;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.ArrayList;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.HashMap;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.List;
</span><span style="color: #0000ff">import</span><span style="color: #000000"> java.util.Map;

</span><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span><span style="color: #000000"> JDBCUtil
{
    </span><span style="color: #0000ff">private</span> <span style="color: #0000ff">final</span> String USERNAME = &quot;root&quot;; <span style="color: #008000">//</span><span style="color: #008000">用户名</span>
    <span style="color: #0000ff">private</span> <span style="color: #0000ff">final</span> String PASSWORD = &quot;a123&quot;; <span style="color: #008000">//</span><span style="color: #008000">密码</span>
    <span style="color: #0000ff">private</span> <span style="color: #0000ff">final</span> String DRIVER = &quot;com.mysql.jdbc.Driver&quot;; <span style="color: #008000">//</span><span style="color: #008000">需要加载的驱动</span>
    <span style="color: #0000ff">private</span> <span style="color: #0000ff">final</span> String URL = &quot;jdbc:mysql://localhost:3306/test&quot;; <span style="color: #008000">//</span><span style="color: #008000">访问数据库的url</span>

    <span style="color: #0000ff">private</span> Connection connection; <span style="color: #008000">//</span><span style="color: #008000">数据库连接</span>
    <span style="color: #0000ff">private</span> PreparedStatement preparedStatement;<span style="color: #008000">//</span><span style="color: #008000">定义sql语句的执行对象</span>
    <span style="color: #0000ff">private</span> ResultSet resultSet; <span style="color: #008000">//</span><span style="color: #008000">查询返回的结果集合</span>
<span style="color: #000000">

}</span></pre>
</div>

<p>&#160;</p>

<p>在构造函数中注册驱动:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">public</span><span style="color: #000000"> JDBCUtil()
    {
        </span><span style="color: #0000ff">try</span><span style="color: #000000">
        {
            Class.forName(DRIVER); </span><span style="color: #008000">//</span><span style="color: #008000">注册驱动</span>
            System.out.println(&quot;注册成功&quot;<span style="color: #000000">);
        } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
        {
            e.printStackTrace();
        }
    }</span></pre>
</div>

<p>获取连接:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">public</span><span style="color: #000000"> Connection getConnection()
    {
        </span><span style="color: #0000ff">try</span><span style="color: #000000">
        {
            </span><span style="color: #008000">//</span><span style="color: #008000">获取连接</span>
            connection =<span style="color: #000000"> DriverManager.getConnection(URL, USERNAME, PASSWORD);

        } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
        {
            </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">        }
        </span><span style="color: #0000ff">return</span><span style="color: #000000"> connection;
    }</span></pre>
</div>

<p>执行更新语句:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">执行更新语句</span>
    <span style="color: #0000ff">public</span> <span style="color: #0000ff">boolean</span> updateByPreparedStatement(String sql, List&lt;Object&gt;<span style="color: #000000"> params)
            </span><span style="color: #0000ff">throws</span><span style="color: #000000"> SQLException
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">获取sql执行对象</span>
        preparedStatement =<span style="color: #000000"> connection.prepareStatement(sql);
        </span><span style="color: #008000">//</span><span style="color: #008000">填充sql中的占位符</span>
        <span style="color: #0000ff">if</span> (params != <span style="color: #0000ff">null</span> &amp;&amp; !<span style="color: #000000">params.isEmpty())
        {
            </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = 0; i &lt; params.size(); ++<span style="color: #000000">i)
            {
                preparedStatement.setObject(i </span>+ 1<span style="color: #000000">, params.get(i));
            }
        }
        
        </span><span style="color: #008000">//</span><span style="color: #008000">执行update</span>
        <span style="color: #0000ff">int</span> result =<span style="color: #000000"> preparedStatement.executeUpdate();
        </span><span style="color: #0000ff">return</span> result &gt; 0<span style="color: #000000">;
    }</span></pre>
</div>

<p>查询单条结果:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">查询单条结果</span>
    <span style="color: #0000ff">public</span> Map&lt;String, Object&gt; findSimpleResult(String sql, List&lt;Object&gt;<span style="color: #000000"> params)
            </span><span style="color: #0000ff">throws</span><span style="color: #000000"> SQLException
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">map对应一条结果</span>
        Map&lt;String, Object&gt; map = <span style="color: #0000ff">new</span> HashMap&lt;String, Object&gt;<span style="color: #000000">();
        
        </span><span style="color: #008000">//</span><span style="color: #008000">填充占位符</span>
        preparedStatement =<span style="color: #000000"> connection.prepareStatement(sql);
        </span><span style="color: #0000ff">if</span> (params != <span style="color: #0000ff">null</span> &amp;&amp; !<span style="color: #000000">params.isEmpty())
        {
            </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = 0; i &lt; params.size(); ++<span style="color: #000000">i)
            {
                preparedStatement.setObject(i </span>+ 1<span style="color: #000000">, params.get(i));
            }
        }
        
        </span><span style="color: #008000">//</span><span style="color: #008000">执行sql语句</span>
        resultSet =<span style="color: #000000"> preparedStatement.executeQuery();
        </span><span style="color: #008000">//</span><span style="color: #008000">获取列的信息</span>
        ResultSetMetaData metaData =<span style="color: #000000"> resultSet.getMetaData();
        </span><span style="color: #008000">//</span><span style="color: #008000">获取列的个数</span>
        <span style="color: #0000ff">int</span> colLen =<span style="color: #000000"> metaData.getColumnCount();

        </span><span style="color: #0000ff">while</span><span style="color: #000000"> (resultSet.next())
        {
            </span><span style="color: #008000">//</span><span style="color: #008000">依次取出每列，放入map中</span>
            <span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = 0; i &lt; colLen; ++<span style="color: #000000">i)
            {
                </span><span style="color: #008000">//</span><span style="color: #008000">获取列名</span>
                String colsName = metaData.getColumnName(i + 1<span style="color: #000000">);
                </span><span style="color: #008000">//</span><span style="color: #008000">获取该列的value</span>
                Object colsValue =<span style="color: #000000"> resultSet.getObject(colsName);
                </span><span style="color: #0000ff">if</span> (colsValue == <span style="color: #0000ff">null</span><span style="color: #000000">)
                {
                    colsValue </span>= &quot;&quot;<span style="color: #000000">;
                }
                </span><span style="color: #008000">//</span><span style="color: #008000">将该列放入map</span>
<span style="color: #000000">                map.put(colsName, colsValue);
            }
        }

        </span><span style="color: #0000ff">return</span><span style="color: #000000"> map;
    }</span></pre>
</div>

<p>查询多条结果:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">public</span> List&lt;Map&lt;String, Object&gt;&gt;<span style="color: #000000"> findMoreResult(String sql,
            List</span>&lt;Object&gt; params) <span style="color: #0000ff">throws</span><span style="color: #000000"> SQLException
    {
        </span><span style="color: #008000">//</span><span style="color: #008000">每个map对应一行数据</span>
        List&lt;Map&lt;String, Object&gt;&gt; list = <span style="color: #0000ff">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;<span style="color: #000000">();
        
        preparedStatement </span>=<span style="color: #000000"> connection.prepareStatement(sql);
        </span><span style="color: #0000ff">if</span> (params != <span style="color: #0000ff">null</span> &amp;&amp; !<span style="color: #000000">params.isEmpty())
        {
            </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = 0; i &lt; params.size(); ++<span style="color: #000000">i)
            {
                preparedStatement.setObject(i </span>+ 1<span style="color: #000000">, params.get(i));
            }
        }

        resultSet </span>=<span style="color: #000000"> preparedStatement.executeQuery();
        ResultSetMetaData metaData </span>=<span style="color: #000000"> resultSet.getMetaData();
        </span><span style="color: #0000ff">int</span> colLen =<span style="color: #000000"> metaData.getColumnCount();

        </span><span style="color: #008000">//</span><span style="color: #008000">逐行进行遍历</span>
        <span style="color: #0000ff">while</span><span style="color: #000000"> (resultSet.next())
        {
            Map</span>&lt;String, Object&gt; map = <span style="color: #0000ff">new</span> HashMap&lt;String, Object&gt;<span style="color: #000000">();
            </span><span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = 0; i &lt; colLen; ++<span style="color: #000000">i)
            {
                String colsName </span>= metaData.getColumnName(i + 1<span style="color: #000000">);
                Object colsValue </span>=<span style="color: #000000"> resultSet.getObject(colsName);
                </span><span style="color: #0000ff">if</span> (colsValue == <span style="color: #0000ff">null</span><span style="color: #000000">)
                {
                    colsValue </span>= &quot;&quot;<span style="color: #000000">;
                }
                map.put(colsName, colsValue);
            }
            list.add(map);
        }

        </span><span style="color: #0000ff">return</span><span style="color: #000000"> list;
    }</span></pre>
</div>

<p>释放连接:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #008000">//</span><span style="color: #008000">释放连接</span>
    <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span><span style="color: #000000"> releaseConn()
    {
        </span><span style="color: #0000ff">if</span> (resultSet != <span style="color: #0000ff">null</span><span style="color: #000000">)
        {
            </span><span style="color: #0000ff">try</span><span style="color: #000000">
            {
                resultSet.close();
            } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
            {
                </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">                e.printStackTrace();
            }
        }

        </span><span style="color: #0000ff">if</span> (preparedStatement != <span style="color: #0000ff">null</span><span style="color: #000000">)
        {
            </span><span style="color: #0000ff">try</span><span style="color: #000000">
            {
                preparedStatement.close();
            } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
            {
                </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">                e.printStackTrace();
            }
        }

        </span><span style="color: #0000ff">if</span> (connection != <span style="color: #0000ff">null</span><span style="color: #000000">)
        {
            </span><span style="color: #0000ff">try</span><span style="color: #000000">
            {
                connection.close();
            } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
            {
                </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">                e.printStackTrace();
            }
        }
    }</span></pre>
</div>

<p>&#160;</p>

<p>&#160;</p>

<p>测试代码如下:</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span><span style="color: #000000"> main(String[] args)
    {
        JDBCUtil jdbcUtil </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> JDBCUtil();
        jdbcUtil.getConnection();

        String sql </span>= &quot;insert into person(name, age) values(?, ?)&quot;<span style="color: #000000">;
        List</span>&lt;Object&gt; params = <span style="color: #0000ff">new</span> ArrayList&lt;Object&gt;<span style="color: #000000">();
        params.add(</span>&quot;rose&quot;<span style="color: #000000">);
        params.add(</span>123<span style="color: #000000">);
        </span><span style="color: #0000ff">try</span><span style="color: #000000">
        {
            </span><span style="color: #0000ff">boolean</span> flag =<span style="color: #000000"> jdbcUtil.updateByPreparedStatement(sql, params);
            System.out.println(flag);
        } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
        {
            </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">            e.printStackTrace();
        }

        sql </span>= &quot;select * from person where id = 1&quot;<span style="color: #000000">;
        </span><span style="color: #0000ff">try</span><span style="color: #000000">
        {
            Map</span>&lt;String, Object&gt; map = jdbcUtil.findSimpleResult(sql, <span style="color: #0000ff">null</span><span style="color: #000000">);
            System.out.println(map);
        } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
        {
            </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">            e.printStackTrace();
        }

        System.out.println(</span>&quot;--------------------------&quot;<span style="color: #000000">);

        sql </span>= &quot;select * from person&quot;<span style="color: #000000">;
        </span><span style="color: #0000ff">try</span><span style="color: #000000">
        {
            List</span>&lt;Map&lt;String, Object&gt;&gt; list = jdbcUtil.findMoreResult(sql, <span style="color: #0000ff">null</span><span style="color: #000000">);
            System.out.println(list);
        } </span><span style="color: #0000ff">catch</span><span style="color: #000000"> (Exception e)
        {
            </span><span style="color: #008000">//</span><span style="color: #008000"> TODO: handle exception</span>
<span style="color: #000000">            e.printStackTrace();
        }

    }</span></pre>
</div>

<p>&#160;</p>

<p>&#160;</p>

<p>后面改动Java的反射特性改写查找函数.</p>]]></description></item><item><title>Vector的一种实现（一）</title><link>http://www.cnblogs.com/inevermore/archive/2014/09/28/3998981.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Sep 2014 13:03:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/09/28/3998981.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>注意几点：</p>
<p>分配内存不要使用new和delete，因为new的同时就把对象构造了，而我们需要的是原始内存。</p>
<p>所以应该使用标准库提供的allocator类来实现内存的控制。当然也可以重载operator new操作符，因为二者都是使用malloc作为底层实现，所以直接采用malloc也可以。</p>
<p>对象的复制必须使用系统提供的uninitialized_fill和uninitialized_copy，因为我们无法手工调用构造函数。</p>
<p>对于C++中的对象，除了POD之外，使用memcpy系列的函数是绝对错误的。</p>
<p>&nbsp;</p>
<p>代码如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #000000;">#ifndef VECTOR_H_
</span><span style="color: #0000ff;">#define</span> VECTOR_H_<span style="color: #000000;">

#include </span>&lt;stddef.h&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;<span style="color: #000000;">
#include </span>&lt;memory&gt;<span style="color: #000000;">

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Vector
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    typedef T </span>*<span style="color: #000000;">iterator;
    typedef </span><span style="color: #0000ff;">const</span> T *<span style="color: #000000;">const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vector() { create(); }
    </span><span style="color: #0000ff;">explicit</span> Vector(size_type n, <span style="color: #0000ff;">const</span> T &amp;t =<span style="color: #000000;"> T())  { create(n, t); }
    Vector(</span><span style="color: #0000ff;">const</span> Vector &amp;<span style="color: #000000;">v) { create(v.begin(),  v.end()); }
    </span>~<span style="color: #000000;">Vector() { uncreate(); }

    Vector </span>&amp;<span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> Vector &amp;<span style="color: #000000;">other);
    T </span>&amp;<span style="color: #0000ff;">operator</span>[] (size_type i) { <span style="color: #0000ff;">return</span><span style="color: #000000;"> data_[i]; }
    </span><span style="color: #0000ff;">const</span> T &amp;<span style="color: #0000ff;">operator</span>[] (size_type i) <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> data_[i]; }

    </span><span style="color: #0000ff;">void</span> push_back(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">t);

    size_type size() </span><span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> avail_ -<span style="color: #000000;"> data_; }
    size_type capacity() </span><span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> limit_ -<span style="color: #000000;"> data_; }

    iterator begin() { </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data_; }
    const_iterator begin() </span><span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> data_; }
    iterator end() { </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> avail_; }
    const_iterator end() </span><span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> avail_; }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    iterator data_; </span><span style="color: #008000;">//</span><span style="color: #008000;">首元素</span>
    iterator avail_; <span style="color: #008000;">//</span><span style="color: #008000;">末尾元素的下一个位置</span>
    iterator limit_; <span style="color: #008000;">//</span><span style="color: #008000;">内存的后面一个位置</span>
<span style="color: #000000;">
    std::allocator</span>&lt;T&gt; alloc_; <span style="color: #008000;">//</span><span style="color: #008000;">内存分配器</span>

    <span style="color: #0000ff;">void</span><span style="color: #000000;"> create();
    </span><span style="color: #0000ff;">void</span> create(size_type, <span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">);
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> create(const_iterator, const_iterator);

    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> uncreate();

    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> grow();
    </span><span style="color: #0000ff;">void</span> uncheckedAppend(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">);
};

template </span>&lt;typename T&gt;<span style="color: #000000;">
Vector</span>&lt;T&gt; &amp;Vector&lt;T&gt;::<span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> Vector &amp;<span style="color: #000000;">rhs)
{
    </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span> != &amp;<span style="color: #000000;">rhs)
    {
        uncreate(); </span><span style="color: #008000;">//</span><span style="color: #008000;">释放原来的内存</span>
<span style="color: #000000;">        create(rhs.begin(), rhs.end());
    }

    </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;::push_back(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">t)
{
    </span><span style="color: #0000ff;">if</span>(avail_ ==<span style="color: #000000;"> limit_)
    {
        grow();
    }
    uncheckedAppend(t);
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;<span style="color: #000000;">::create()
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">分配空的数组</span>
    data_ = avail_ = limit_ = <span style="color: #800080;">0</span><span style="color: #000000;">;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;::create(size_type n, <span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">val)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">分配原始内存</span>
    data_ =<span style="color: #000000;"> alloc_.allocate(n);
    limit_ </span>= avail_ = data_ +<span style="color: #000000;"> n;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">向原始内存填充元素</span>
<span style="color: #000000;">    std::uninitialized_fill(data_, limit_, val);
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;<span style="color: #000000;">::create(const_iterator i, const_iterator j)
{
    data_ </span>= alloc_.allocate(j-<span style="color: #000000;">i);
    limit_ </span>= avail_ =<span style="color: #000000;"> std::uninitialized_copy(i, j, data_);
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;<span style="color: #000000;">::uncreate()
{
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(data_)
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">逐个进行析构</span>
        iterator it =<span style="color: #000000;"> avail_;
        </span><span style="color: #0000ff;">while</span>(it !=<span style="color: #000000;"> data_)
        {
            alloc_.destroy(</span>--<span style="color: #000000;">it);
        }

        </span><span style="color: #008000;">//</span><span style="color: #008000;">真正的释放内存</span>
        alloc_.deallocate(data_, limit_ -<span style="color: #000000;"> data_);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">重置指针</span>
    data_ = limit_ = avail_ = <span style="color: #800080;">0</span><span style="color: #000000;">;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;<span style="color: #000000;">::grow()
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">内存变为两倍</span>
    size_type new_size = std::max(<span style="color: #800080;">2</span> * (limit_ - data_), std::ptrdiff_t(<span style="color: #800080;">1</span><span style="color: #000000;">));
    </span><span style="color: #008000;">//</span><span style="color: #008000;">分配原始内存</span>
    iterator new_data =<span style="color: #000000;"> alloc_.allocate(new_size);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">复制元素</span>
    iterator new_avail =<span style="color: #000000;"> std::uninitialized_copy(data_, avail_, new_data);

    uncreate(); </span><span style="color: #008000;">//</span><span style="color: #008000;">释放以前的内存，以及析构元素</span>
<span style="color: #000000;">
    data_ </span>=<span style="color: #000000;"> new_data;
    avail_ </span>=<span style="color: #000000;"> new_avail;
    limit_ </span>= data_ +<span style="color: #000000;"> new_size;
}

template </span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Vector&lt;T&gt;::uncheckedAppend(<span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">val)
{
    alloc_.construct(avail_</span>++<span style="color: #000000;">, val);
}


</span><span style="color: #0000ff;">#endif</span>  /* VECTOR_H_ */</pre>
</div>
<p>&nbsp;</p>
<p>测试代码如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>#include <span style="color: #800000;">"</span><span style="color: #800000;">Vector.hpp</span><span style="color: #800000;">"</span><span style="color: #000000;">
#include </span>&lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">char</span> <span style="color: #0000ff;">const</span> *<span style="color: #000000;">argv[])
{
    Vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; vec(<span style="color: #800080;">3</span>, <span style="color: #800000;">"</span><span style="color: #800000;">hello</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    </span><span style="color: #0000ff;">for</span>(Vector&lt;<span style="color: #0000ff;">string</span>&gt;::const_iterator it =<span style="color: #000000;"> vec.begin();
        it </span>!=<span style="color: #000000;"> vec.end();
        </span>++<span style="color: #000000;">it)
    {
        cout </span>&lt;&lt; *it &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
    }
    cout </span>&lt;&lt;<span style="color: #000000;"> endl;

    cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">size = </span><span style="color: #800000;">"</span> &lt;&lt; vec.size() &lt;&lt;<span style="color: #000000;"> endl;
    cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">capacity = </span><span style="color: #800000;">"</span> &lt;&lt; vec.capacity() &lt;&lt;<span style="color: #000000;"> endl;
    vec.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">foo</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    vec.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">bar</span><span style="color: #800000;">"</span><span style="color: #000000;">);

    cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">size = </span><span style="color: #800000;">"</span> &lt;&lt; vec.size() &lt;&lt;<span style="color: #000000;"> endl;
    cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">capacity = </span><span style="color: #800000;">"</span> &lt;&lt; vec.capacity() &lt;&lt;<span style="color: #000000;"> endl;

    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>]]></description></item><item><title>使用迭代器逆置容器元素</title><link>http://www.cnblogs.com/inevermore/archive/2014/09/28/3998846.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Sun, 28 Sep 2014 11:13:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/09/28/3998846.html</guid><description><![CDATA[<p>&#160;</p>  <p>代码如下：</p>  <p>&#160;</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>template &lt;typename It&gt;
<span style="color: #0000ff">void</span><span style="color: #000000"> reverse(It begin, It end)
{
    </span><span style="color: #0000ff">while</span>(begin !=<span style="color: #000000"> end)
    {
        </span>--<span style="color: #000000">end;
        </span><span style="color: #0000ff">if</span>(begin !=<span style="color: #000000"> end)
            std::swap(</span>*begin++, *<span style="color: #000000">end);
    }
}</span></pre>
</div>



<p>&#160;</p>

<p>&#160;</p>

<p>注意几点：</p>

<p>1.不能一开始就--end，原因是[begin, end)是左闭右开区间，如果begin和end相等，--end则破坏了区间，不是每个迭代器都支持&lt; &gt;操作。</p>

<p>2.在循环内部，不能直接begin++,end--，原因是防止两个相邻的元素。</p>

<p>综合以上原因，只能在循环体内先--end，然后swap的时候begin++；</p>]]></description></item><item><title>测试</title><link>http://www.cnblogs.com/inevermore/archive/2014/09/26/3995839.html</link><dc:creator>inevermore</dc:creator><author>inevermore</author><pubDate>Fri, 26 Sep 2014 15:46:00 GMT</pubDate><guid>http://www.cnblogs.com/inevermore/archive/2014/09/26/3995839.html</guid><description><![CDATA[<p>&#160;</p>  <p>&#160;</p>  <p>使用Windows live Writer编写博客</p>  <p>&#160;</p>  <p>测试代码</p>  <p>&#160;</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre><span style="color: #008000">/**</span><span style="color: #008000">
     * 从一段文本中检索出唯一的结果
     * </span><span style="color: #808080">@param</span><span style="color: #008000"> regx 正则表达式语句
     * </span><span style="color: #808080">@param</span><span style="color: #008000"> text 要检索的文本
     * </span><span style="color: #808080">@return</span>
     <span style="color: #008000">*/</span>
    <span style="color: #0000ff">public</span><span style="color: #000000"> String regx(String regx,String text)
    {
        Matcher matcher</span>=<span style="color: #000000">Pattern.compile(regx).matcher(text);
        </span><span style="color: #0000ff">if</span><span style="color: #000000">(matcher.find())
            </span><span style="color: #0000ff">return</span><span style="color: #000000"> matcher.group();
        </span><span style="color: #0000ff">else</span>
            <span style="color: #0000ff">return</span> <span style="color: #0000ff">null</span><span style="color: #000000">;
    }</span></pre>
</div>]]></description></item></channel></rss>